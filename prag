<?php
# Pragwork 1.1.0
# Prag Console Tool 1.1.0
# Author: Szymon Wrozynski
# Copyright (c) 2009-2011 Szymon Wrozynski (http://wrozynski.com)
# 
# Permission is hereby granted, free of charge, to any person obtaining 
# a copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation 
# the rights to use, copy, modify, merge, publish, distribute, sublicense, 
# and/or sell copies of the Software, and to permit persons to whom the 
# Software is furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, 
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

namespace Prag;

const PRAG_VERSION = '1.1.0';
const AUTHOR = 'Copyright (c) 2009-2011 Szymon Wrozynski';
const PRAGWORK_VERSION = '1.1.0';
const LICENSE = 'Licensed under the MIT License';

# Field class (for Model and Scaffolding) ####################################

class Field
{
	public $name;
	public $type;
	private $_nullable = false;
	private $_text = false;
	
	public function __construct($declaration)
	{
		$parts = explode(':', $declaration);
		
		if (count($parts) !== 2)
			error("Wrong field declaration: $declaration");
		
		$this->name = ensure_ident($parts[0], true);
		
		if (strpos($parts[1], 'nullable ') === 0)
		{
			$parts[1] = substr($parts[1], 9);
			$this->_nullable = true;
		}
		
		if (in_array($parts[1], array('bool', 'int', 'float', 'string'), true))
			$this->type = $parts[1];
		elseif ($parts[1] === 'text')
		{
			$this->type = 'string';
			$this->_text = true;
		}
		else
			error("Unknown type: {$parts[1]}");
	}
	
	public function is_nullable()
	{
		return $this->_nullable;
	}
		
	public function is_bool()
	{
		return $this->type === 'bool';
	}
	
	public function is_int()
	{
		return $this->type === 'int';
	}	 
	
	public function is_float()
	{
		return $this->type === 'float';
	}
	
	public function is_string()
	{
		return $this->type === 'string';
	}
	
	public function is_text()
	{
		return $this->_text;
	}
		
	public function is_id()
	{
		return $this->is_int() 
			&& strrpos($this->name, '_id') === strlen($this->name) - 3;
	}
	
	public function declaration()
	{
		$decl = $this->name . ':';
		
		if ($this->_nullable)
			$decl .= 'nullable ';
		
		if ($this->_text)
			$decl .= 'text';
		else
			$decl .= $this->type;
		
		return $decl;
	}
}

# Globals ####################################################################

$STRIP_PHPDOC = false;
$SSL = false;
$EXT = '';
$ASTERISK_USED = false;
$WRITE_MSG = null;
$THE_SAME_WRITE_MSG = false;

# Basic functions ############################################################

set_error_handler(function($errno, $errstr, $errfile, $errline)
{
	throw new \ErrorException($errstr, 0, $errno, $errfile, $errline);
});

function read($path)
{
	try
	{
		return file_get_contents($path);
	}
	catch (\ErrorException $e)
	{
		error("Cannot find or read $path");
	}
}

function write($path, $text, $asterisk=false)
{
	global $WRITE_MSG, $THE_SAME_WRITE_MSG, $ASTERISK_USED;
	try
	{
		file_put_contents($path, $text);
		$msg = "Writing $path"; 
		if ($asterisk)
		{
			$ASTERISK_USED = true;
			$msg .= ' *';
		}
		
		$THE_SAME_WRITE_MSG = ($msg === $WRITE_MSG);
		
		if ($THE_SAME_WRITE_MSG)
			echo '.';
		else
		{
			if ($WRITE_MSG !== null)
				echo "\n";
				
			$WRITE_MSG = $msg;
			echo $msg;
		}
	}
	catch (\ErrorException $e)
	{
		if ($WRITE_MSG !== null)
			echo "\n";
		
		error("Cannot write $path. Are you in the project directory?");
	}
}
 
function write_binary($path, $binary)
{
	write($path, base64_decode($binary));
}

// ------------ lixlpixel recursive PHP functions -------------
// recursive_remove_directory( directory to delete, empty )
// expects path to directory and optional TRUE / FALSE to empty
// ------------------------------------------------------------
function rmtree($directory, $empty=false)
{
	if (substr($directory, -1) === '/')
		$directory = substr($directory, 0, -1);
	
	if (!is_dir($directory))
		return false;
		
	elseif (is_readable($directory))
	{
		$handle = opendir($directory);
		while (false !== ($item = readdir($handle)))
		{
			if ($item !== '.' && $item !== '..')
			{
				$path = $directory . DIRECTORY_SEPARATOR . $item;
				
				if (is_dir($path)) 
					rmtree($path);
				else
					unlink($path);
			}
		}
		closedir($handle);
		
		if($empty === false)
		{
			if(!rmdir($directory))
				return false;
		}
	}
	return true;
}

function error($msg)
{
	echo "ERROR: $msg\n\n";
	exit(1);
}

function check_file_exists($path)
{
	if (!is_file($path))
		error("Cannot found $path file. Are you in the project directory?");
}

function check_dir_exists($path)
{
	if (!is_dir($path))
		error("Cannot found $path directory. Are you in the project directory?");
}

function ensure_ident($ident, $strict=false)
{
	$pattern = $strict ? '/^[a-z]+[a-z0-9_]*$/' : '/^[a-z]+[\a-z0-9_]*$/';
	
	if (!preg_match($pattern, $ident))
		error("Incorrect identifier: $ident");
	
	return $ident;
}

# Various helper functions ###################################################

function _make_dirs($initial_path, $dirs)
{
	check_dir_exists($initial_path);
	
	foreach ($dirs as $d)
	{
		$initial_path .= DIRECTORY_SEPARATOR . $d;
		if (!is_dir($initial_path))
			mkdir($initial_path, 0755);
	}
	
	return $initial_path;
}

function _make_app_dirs(/*...*/)
{
	return _make_dirs('app', func_get_args());
}

function _make_test_dirs(/*...*/)
{
	return _make_dirs('test', func_get_args());
}

function _make_ns_dirs($path, $ns)
{
	if (strlen($ns) === 0)
		return;
	
	try
	{
		foreach (explode('\\', $ns) as $part)
		{
			$path .= DIRECTORY_SEPARATOR . $part;
		
			if (!is_dir($path))
				mkdir($path, 0755);
		}
	}
	catch (\ErrorException $e)
	{
		error("Cannot create $path. Are you in the project directory?");
	}
}

# Taken from PHP ActiveRecord by and Kien La, Jacques Fuentes (MIT License)
function _pluralize($string)
{
	$plural = array(
		'/(quiz)$/i'			   => "$1zes",
		'/^(ox)$/i'				   => "$1en",
		'/([m|l])ouse$/i'		   => "$1ice",
		'/(matr|vert|ind)ix|ex$/i' => "$1ices",
		'/(x|ch|ss|sh)$/i'		   => "$1es",
		'/([^aeiouy]|qu)y$/i'	   => "$1ies",
		'/(hive)$/i'			   => "$1s",
		'/(?:([^f])fe|([lr])f)$/i' => "$1$2ves",
		'/(shea|lea|loa|thie)f$/i' => "$1ves",
		'/sis$/i'				   => "ses",
		'/([ti])um$/i'			   => "$1a",
		'/(tomat|potat|ech|her|vet)o$/i'=> "$1oes",
		'/(bu)s$/i'				   => "$1ses",
		'/(alias)$/i'			   => "$1es",
		'/(octop)us$/i'			   => "$1i",
		'/(ax|test)is$/i'		   => "$1es",
		'/(us)$/i'				   => "$1es",
		'/s$/i'					   => "s",
		'/$/'					   => "s"
	);

	$irregular = array(
		'move'	 => 'moves',
		'foot'	 => 'feet',
		'goose'	 => 'geese',
		'sex'	 => 'sexes',
		'child'	 => 'children',
		'man'	 => 'men',
		'tooth'	 => 'teeth',
		'person' => 'people'
	);

	$uncountable = array(
		'sheep',
		'fish',
		'deer',
		'series',
		'species',
		'money',
		'rice',
		'information',
		'equipment'
	);

	if (in_array(strtolower($string), $uncountable))
		return $string;

	foreach ($irregular as $pattern => $result)
	{
		$pattern = '/' . $pattern . '$/i';
		if (preg_match($pattern, $string))
			return preg_replace($pattern, $result, $string);
	}

	foreach ($plural as $pattern => $result)
	{
		if (preg_match($pattern, $string))
			return preg_replace($pattern, $result, $string);
	}

	return $string;
}

function _camelize($name, $separator='_')
{
	return str_replace(array('_', ' '), array('', ''), ucwords(str_replace(
		array($separator, '\\'), array(' _ ', ' \\ '), trim($name))));
}

function _uncamelize($name, $separator='_')
{
	$result = '';
	$prev = '';
	$i = 0;
	$special_chars = array('_', '\\');
	$name = trim($name);
	
	while(isset($name[$i]))
	{
		if (ctype_upper($name[$i]) && $prev && !in_array($prev, $special_chars, true))
			$result .= $separator;
		
		$result .= strtolower($name[$i]);
		$prev = $name[$i++];
	}
	return $result;
}
	
function _get_ns_and_name($name)
{
	$rpos = strrpos($name, '\\');
	return ($rpos > -1) ? array(substr($name, 0, $rpos), substr($name, $rpos + 1)) : array('', $name);
}

function _strip_phpdoc($text)
{
	if ($GLOBALS['STRIP_PHPDOC'])
	{
		$comment_start = strpos($text, '/**');
		if ($comment_start > 0)
		{
			$comment_end = strpos($text, '*/', $comment_start);
			if ($comment_end > 0)
				return _strip_phpdoc(substr($text, 0, $comment_start) . substr($text, $comment_end + 2));
		}
	}
	return $text;
}

# Main generator functions ###################################################

function new_actions_with_methods($full_controller_sn, $actions_with_methods, &$prepend_comment)
{
	$http_methods = array('GET', 'POST', 'PUT', 'DELETE');
	$ams = array();
	$ams_size = 0;
	foreach ($actions_with_methods as $entry)
	{
		if (in_array($entry, $http_methods, true))
		{
			if (!$ams)
				error("An action should be specified before the $entry method");
			
			if (!in_array($entry, $ams[$ams_size - 1]['methods']))
				$ams[$ams_size - 1]['methods'][] = $entry;
		}
		else
			$ams[$ams_size++] = array('action' => $entry, 'methods' => array());
	}
	
	foreach ($ams as $am)
		new_action(
			$full_controller_sn, 
			$am['action'], 
			$am['methods'] ? join(' ', $am['methods']) : 'GET',
			$prepend_comment
		);
}

function new_action($full_controller_sn, $action, $methods, &$prepend_comment)
{
	$path = 'app' . DIRECTORY_SEPARATOR . 'Controllers' . DIRECTORY_SEPARATOR
		. str_replace('\\', DIRECTORY_SEPARATOR, _camelize($full_controller_sn)) . 'Controller.php';
	
	check_file_exists($path);
	$controller_text = read($path);
	
	if (preg_match('/\s*public\s+function\s+' . $action . '\s*\(\s*\)\s*\{/', $controller_text))
		return;
	
	$mapping = str_replace(array('_','\\'), array('-','/'), $full_controller_sn) . '/' . str_replace('_', '-', $action);
	
	new_route($full_controller_sn, $action, $methods,$mapping,$prepend_comment);
	
	$first_part = substr($controller_text, 0, strrpos($controller_text, '}'));
	
	global $EXT;
	$new_controller_text = $first_part . PHP_EOL . "\t# $methods /$mapping$EXT" . PHP_EOL 
		. "\tpublic function $action()" . PHP_EOL . "\t{}" . PHP_EOL . '}' . PHP_EOL . '?>';
	
	write($path, $new_controller_text);
	new_view($full_controller_sn, $action);
}

function new_route($full_controller_sn, $action, $methods, $mapping, &$prepend_comment)
{
	$path = 'config' . DIRECTORY_SEPARATOR . 'routes.php';
	check_file_exists($path);
	$routes_text = read($path);
	$first_entry = ($routes_text === <<< 'EOD'
<?php
$ROUTES = array(
);
?>
EOD
);
	if (preg_match('/\s*\'controller\'\s*=>\s*\'' . str_replace('\\', '\\\\', _camelize($full_controller_sn))
		. '\'\s*,\s*\'action\'\s*=>\s*\'' . $action . "'/", $routes_text))
		return;
	
	if ($prepend_comment && ! $first_entry)
	{
		$comment = PHP_EOL . "\t# " . $prepend_comment . PHP_EOL;
		$prepend_comment = null;
	}
	else
		$comment = '';
	
	$routes_text = substr($routes_text, 0, strrpos($routes_text, PHP_EOL . ');' . PHP_EOL . '?>')); 
	
	global $SSL, $EXT;
	
	$asterisk = $SSL || $EXT;
	$ssl_line = $SSL ? ',' . PHP_EOL . "\t\t'ssl' => true" : '';
	
	if ($first_entry)
	{
		$routes_text .= PHP_EOL . "\t# Root";
		$mapping_line = '';
	}
	else
	{
		$routes_text .= ',';
		$mapping_line = PHP_EOL . "\t\t'/" . $mapping . $EXT . "',";
	}
	
	$routes_text .= PHP_EOL . $comment . "\tarray($mapping_line" . PHP_EOL 
		. "\t\t'controller' => '" . _camelize($full_controller_sn) . "'," . PHP_EOL 
		. "\t\t'action' => '$action',"	. PHP_EOL 
		. "\t\t'methods' => '$methods'$ssl_line" . PHP_EOL
		. "\t)" . PHP_EOL . ');' . PHP_EOL . '?>';
	
	write($path, $routes_text, $asterisk);
}

function new_view($full_controller_sn, $action)
{
	$dir_path = _make_app_dirs('views');
	$full_ns = _camelize($full_controller_sn);
	_make_ns_dirs($dir_path, $full_ns);
	$dirs = str_replace('\\', DIRECTORY_SEPARATOR, $full_ns);
	$path = $dir_path . DIRECTORY_SEPARATOR . $dirs . DIRECTORY_SEPARATOR . $action . '.php';
		
	if (is_file($path))
		return;
	
	$place = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR . $dirs . DIRECTORY_SEPARATOR . $action.'.php';
		
	write($path, sprintf(
		'<h1>%s\%s</h1>' . PHP_EOL . PHP_EOL . '<p>Find me in %s</p>',
		_camelize($full_controller_sn),
		$action,
		$place
	));
}

function new_controller($full_controller_sn, $actions_with_methods,	&$prepend_comment)
{
	$path = _make_app_dirs('Controllers');
	$test_path = _make_test_dirs('Controllers');
	
	list($ns, $cont) = _get_ns_and_name($full_controller_sn);
	
	_make_ns_dirs($path, _camelize($ns));
	_make_ns_dirs($test_path, _camelize($ns));
	
	$path .= DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, _camelize($full_controller_sn)) 
		. 'Controller.php';
		
	$test_path .= DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, _camelize($full_controller_sn))
		. 'ControllerTest.php';
	
	$ns_clause = $ns ? '\\' . _camelize($ns) : '';
	
	$abstract = $actions_with_methods ? '' : 'abstract ';
	
	$use_app_cont = $ns_clause ? 'use Controllers\ApplicationController;' . PHP_EOL : '';
	
	$text = '<?php' . PHP_EOL . 'namespace Controllers' . $ns_clause . ';' . PHP_EOL . $use_app_cont . PHP_EOL 
		. $abstract . 'class ' . _camelize($cont) . 'Controller extends ApplicationController' 
		. PHP_EOL . '{}' . PHP_EOL . '?>';
	
	$test_text = sprintf(<<< 'TC'
<?php
namespace Controllers%s;
modules('test');

class %sControllerTest extends \Test\ControllerTestCase
{	
	public function test_the_truth() 
	{
		ensure(true);
	}
}
?>
TC
		, $ns_clause, _camelize($cont));
	
	write($path, $text);
	
	if (!$abstract && !is_file($test_path))
		write($test_path, $test_text);
	
	new_helper($ns, $cont);
	new_actions_with_methods($full_controller_sn, $actions_with_methods, 
		$prepend_comment);
}

function new_helper($namespace_sn, $controller_sn)
{
	$path = _make_app_dirs('helpers');
	$camelized_ns = _camelize($namespace_sn);
	_make_ns_dirs($path, $camelized_ns);
	$path .= DIRECTORY_SEPARATOR 
		. str_replace('\\', DIRECTORY_SEPARATOR, $camelized_ns) 
		. _camelize($controller_sn) . 'Helper.php';
	write($path, '');
}

# Help printing function #####################################################
		
function help()
{
	printf(<<< HELPMSG
USAGE:

  php prag work name
  
    - Generates a new project.
	

  php prag help[|h]
  
    - Prints this information.


Commands available in the project directory:

  php prag [ssl] [.ext] controller[|c] name
  php prag [ssl] [.ext] controller[|c] namespace\\\\name action_1 [action_2] ...
  php prag [ssl] [.ext] controller[|c] name action_1 [GET POST PUT DELETE] ...
  
    - Generates a new controller with given actions and HTTP methods 
      or adds new actions to the existing one. This command also adds 
      the default routes to "routes.php" file and creates the default 
      view templates. The 4 HTTP methods are allowed: GET, POST, PUT, DELETE.
      They should be passed in upper case and follow the action. 
      If no HTTP method follows the action then the GET method is assumed.
	  
      This command may be prepended with the "ssl" particle. It causes 
      all generated routes to have the "ssl" option set to "true".
	  
      Also, this command may be prepended with an extension starting with a dot.
      The extension will be appended to all generated routes.
	  
      Examples: 
      php prag .html controller my_controller get_post GET POST post_only POST
      php prag c my_controller get_post GET POST post_only POST
	  
  
  php prag [ssl] [.ext] scaffold[|s][!] entity field_1:type [field_2:type] ...
  
    - Generates a scaffolding around a given model using ActiveRecord module. 
      This command creates a controller, view templates, model class, 
      and routing entries for CRUD actions. 
	  
      The Pragwork uses 5 predefined field types: "bool", "float", "int", 
      "string", and "text". Each type can be prepended with the keyword 
      "nullable" if it is allowed to hold a null value. The field name
      and type are separated with a colon.
	  
      If the field type is an "int" and its name ends with "_id" then 
      the "INT UNSIGNED" is used within the SQL generated code. This is 
      because of an assumption that the field acts as a foreign key in 
      the relationship between tables.
	  
      To overwrite existing files, add an exclamation mark (!) to the command.
	  
      This command may be prepended with the "ssl" particle. It causes 
      all generated routes to have the "ssl" option set to "true".
	  
      Also, this command may be prepended with an extension starting with a dot.
      The extension will be appended to all generated routes.
	  
      Examples: 
      php prag scaffold person name:string last_name:string age:int
      php prag s! person name:string last_name:string age:int
  

  php prag model[|m][!] entity field_1:type [field_2:type] ...
  
    - Creates (or overwrites) model class for the given entity. 
      Generates the SQL code if needed. Follows exactly the same 
      syntax as the "scaffold" command.
	  
      To overwrite existing files, add an exclamation mark (!) to the command.

	  
  php prag form[|f][!] entity field_1:type [field_2:type] ...
  
    - Creates a tableless model class used as a plain model without 
      a database connection. It is especially useful within forms because of 
      the ActiveRecord validation features. Also, this command generates the 
      corresponding form partial template.
      The command follows exactly the same syntax as the "scaffold" command.
	  
      To overwrite existing files, add an exclamation mark (!) to the command.
	  
      Examples:
      php prag form! login name:string password:string
      php prag f login name:string password:string
	  
	  
  php prag localize[|l][!] [locale_code] [locale_code_2] ...
  
    - Creates localization files according to specified locale codes. Also, this
      command appends stub entries based on possible keys found in the code 
      to the localization files. 
	  
      If no locale codes were specified all available locales are evaluated.
	  
      To overwrite existing files, add an exclamation mark (!) to the command.
	  
      Examples:
      php prag localize!
      php prag l en pl
	  
	  
  php prag db prepare [all|development|test|production|other...] name [password]

    - Creates database for all environments or for the chosen one. Also, this 
      command creates writes the default schema and data to the database.
      Requires database root user name and password.
	  
      Warning: This command will erase the whole database prior to the creation.
	  
      Example:
      php prag db prepare all root root
	  
      Example without password:
      php prag db prepare development root
	 
	 
  php prag db schema [all|development|test|production|other...]
  
    - Writes the default schema to the databases in all environments or in the
      chosen one. 
	  
      Warning: Probably all your data existing in the database will be erased.
	 
	  
  php prag db data [all|development|test|production|other...]
  
    - Writes the default data to the databases in all environments or in the
      chosen one. 
  
      Warning: Probably all your data existing in the database will be erased.
	  
  
  php prag test[|t] [fixture_name] [fixture_name_2] ...
  
    - Runs tests available in the 'test' directory. If no fixture is given then
      all fixtures are run one by one. Test are performed in the 'test' 
      environment and the test database is filled with default data before each
      test fixture.

  
  php prag update [nodoc]
  
    - Updates modules of the current project to Pragwork %s.
      The optional "nodoc" parameter causes writing modules without
      PHPDoc comments. That makes some modules significantly smaller and 
      therefore they can be loaded a bit faster.

HELPMSG
	, PRAGWORK_VERSION);
}

# Localization functions

function _make_locale_file($locale)
{
	$path = 'locales' . DIRECTORY_SEPARATOR . $locale . '.php';
	write($path, sprintf(<<< 'EOD'
<?php
$LOCALE = array(
	'%s'
);
?>
EOD
	, $locale));	
}

function _add_locale_stub($locale, $key, &$prepend_comment, $value='null')
{
	$path = 'locales' . DIRECTORY_SEPARATOR . $locale . '.php';

	if (($key[0] === '"') && (strpos($key, "'") === false)) 
		$key = "'" . trim($key, '"') . "'";
	
	$locale_text = read($path);
	
	preg_match_all('/\s*(\'[^\\\']+\'|"[^\\"]+")\s*=>/', $locale_text, $matches);
	
	if (isset($matches[1]) && in_array($key, $matches[1], true))
		return;
	
	if ($prepend_comment)
	{
		$comment = PHP_EOL . "\t# " . $prepend_comment . PHP_EOL;
		$prepend_comment = null;
	}
	else
		$comment = '';
	
	$first_part = substr($locale_text, 0, strrpos($locale_text, PHP_EOL . ');' . PHP_EOL . '?>'));
	
	$new_locale_text = $first_part . ',' . PHP_EOL . "$comment\t$key => $value" . PHP_EOL . ');' . PHP_EOL . '?>';
		
	write($path, $new_locale_text);
}

function _find_locale_keys_in_dir($locale, $directory, &$prepend_comment)
{
	foreach (scandir($directory) as $entry)
	{
		if ($entry[0] === '.')
			continue;
		
		$entry = $directory . DIRECTORY_SEPARATOR . $entry;
		if (is_dir($entry))
			_find_locale_keys_in_dir($locale, $entry, $prepend_comment);
		else
		{
			$keys = array();
			
			preg_match_all('/[^\w$][tT]\s*\(\s*(\'[^\\\']+\'|"[^\\"]+")\s*\)/', read($entry), $keys);

			foreach ($keys[1] as $key)
				_add_locale_stub($locale, $key, $prepend_comment);
		}
	}
}

function _find_model_validation_messages_in_dir($locale, $directory, &$keys)
{
	foreach (scandir($directory) as $entry)
	{
		if ($entry[0] === '.')
			continue;
		
		$entry = $directory . DIRECTORY_SEPARATOR . $entry;
		if (is_dir($entry))
			_find_model_validation_messages_in_dir($locale, $entry, $keys);
		else
		{
			$text = read($entry);
			$matches = array();
preg_match_all('/\s*(\'message\'|"message"|\'wrong_length\'|"wrong_length"|\'too_long\'|"too_long"|\'too_short\'|"too_short")\s*=>\s*(\'[^\\\']+\'|"[^\\"]+")/', $text, $matches);

			if (isset($matches[2]))
			{
				if (is_array($matches[2]))
					$keys = array_merge($keys, $matches[2]);
				else
					$keys[] = $matches[2];
			}
			
			$matches = array();
preg_match_all('/\$this\s*->\s*errors\s*->\s*add\s*\(\s*(\'\w+\'|"\w+")\s*,\s*(\'[^\\\']+\'|"[^\\"]+")\s*\)/', $text, $matches);

			if (isset($matches[2]))
			{
				if (is_array($matches[2]))
					$keys = array_merge($keys, $matches[2]);
				else
					$keys[] = $matches[2];
			}
		}
	}
}

function _find_model_validation_messages($locale, &$prepend_comment)
{
	$keys = array(
		"'is not included in the list'",
		"'is reserved'",
		"'is invalid'",
		'"can\'t be empty"',
		'"can\'t be blank"',
		"'is too long (maximum is %d characters)'",
		"'is too short (minimum is %d characters)'",
		"'is the wrong length (should be %d characters)'",
		"'is not a number'",
		"'must be greater than %d'",
		"'must be equal to %d'",
		"'must be less than %d'",
		"'must be odd'",
		"'must be even'",
		"'must be unique'",
		"'must be less than or equal to %d'",
		"'must be greater than or equal to %d'"
	);
	
	$path = 'app' . DIRECTORY_SEPARATOR . 'Models';
	
	if (is_dir($path)) 
		_find_model_validation_messages_in_dir($locale, $path, $keys);
	
	foreach ($keys as $key)
		_add_locale_stub($locale, $key, $prepend_comment);
}

function _find_model_fields_in_dir($locale, $directory, &$keys)
{
	foreach (scandir($directory) as $entry)
	{
		if ($entry[0] === '.')
			continue;
		
		$entry = $directory . DIRECTORY_SEPARATOR . $entry;
		
		if (is_dir($entry)) 
			_find_model_fields_in_dir($locale, $entry, $keys);
		else
		{
			$text = read($entry);
			
			$matches = array();
			preg_match_all('/\s*public\s+\$(\w+)\s*[=;]/', $text, $matches);
			
			if (isset($matches[1]))
			{
				if (is_array($matches[1]))
					$keys = array_merge($keys, $matches[1]);
				else
					$keys[] = $matches[1];
			}
			
			$matches = array();
			preg_match_all('/\s*public\s+function\s+set_(\w+)\s*\(/', $text, $matches);
			
			if (isset($matches[1]))
			{
				foreach ($matches[1] as $k)
				{
					if (preg_match('/\s*public\s+function\s+get_' .$k. '\s*\(/', $text))
						$keys[] = $k;
				}
			}
		}
	}
}

function _find_model_fields($locale, &$prepend_comment)
{
	$keys = array();
	$path = 'app' . DIRECTORY_SEPARATOR . 'Models';
	
	if (is_dir($path))
		_find_model_fields_in_dir($locale, $path, $keys);
	
	foreach($keys as $key)
		_add_locale_stub($locale, "'" . $key . "'", $prepend_comment,
			"'" . str_replace('_', ' ', ucfirst($key)) . "'");
}

function _find_model_fields_in_sql($locale, &$prepend_comment)
{
	$path = 'sql' . DIRECTORY_SEPARATOR . 'schema.sql';
	check_file_exists($path);
	
	$matches = array();
	
	preg_match_all('/\s+(\w+)\s*:\s*[a-zA-Z]+/', read($path), $matches);
	
	if (isset($matches[1]) && $matches[1])
	{
		_add_locale_stub($locale, "'id'", $prepend_comment, "'Id'");
		foreach ($matches[1] as $attr)
		{
			$attr = _uncamelize($attr);
			_add_locale_stub($locale, "'" . $attr . "'", $prepend_comment, "'".str_replace('_',' ',ucfirst($attr))."'");
		}
		_add_locale_stub($locale, "'created_at'", $prepend_comment, "'Created at'");
		_add_locale_stub($locale, "'updated_at'", $prepend_comment,	"'Updated at'");
	}
}

function find_locale_keys_and_create_locale($locale, $overwrite)
{
	check_dir_exists('locales');
	check_dir_exists('app');
	check_dir_exists('config');
	check_dir_exists('errors');
	
	$path = 'locales' . DIRECTORY_SEPARATOR . $locale . '.php';
	
	if ($overwrite && is_file($path))
		unlink($path);
		
	if (!is_file($path))
		_make_locale_file($locale);
	
	$comment = 'Fields';
	_find_model_fields_in_sql($locale, $comment);
	_find_model_fields($locale, $comment);
	
	$comment = 'Configuration entries';
	_find_locale_keys_in_dir($locale, 'config', $comment);
	
	$comment = 'Model validation messages';
	_find_model_validation_messages($locale, $comment);
	
	$comment = 'Messages';
	_find_locale_keys_in_dir($locale, 'errors', $comment);
	_find_locale_keys_in_dir($locale, 'app', $comment);
}

# Scaffolding functions ######################################################

function make_scaffolding_controller($full_singular_sn, $fields, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	
	$controller_path = _make_app_dirs('Controllers');
	$test_path = _make_test_dirs('Controllers');
	
	_make_ns_dirs($controller_path, $ns_camel);
	_make_ns_dirs($test_path, $ns_camel);
	
	$controller_path .= DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, $ns_camel) 
		. DIRECTORY_SEPARATOR . $plural_camel . 'Controller.php';
		
	$test_path .= DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, $ns_camel) 
		. DIRECTORY_SEPARATOR . $plural_camel . 'ControllerTest.php';
	
	$helper_path = _make_app_dirs('helpers');
	_make_ns_dirs($helper_path, $ns_camel);
	$helper_path .= DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, $ns_camel)
		. DIRECTORY_SEPARATOR . $plural_camel . 'Helper.php';
		
	if ($overwrite || !is_file($helper_path))
		write($helper_path, '');
	
	if ($ns_camel)
	{
		$mapping_part = str_replace(array('_', '\\'), array('-', '/'), $ns) . '/' 
			. str_replace('_', '-', $plural);
		$ns_clause = '\\' . $ns_camel;
		$use_app_cont = 'use Controllers\ApplicationController;' . PHP_EOL;
	}
	else
	{
		$mapping_part = str_replace('_', '-', $plural);
		$use_app_cont = '';
		$ns_clause = '';
	}
	
	$test_text = sprintf(<<< 'TC'
<?php
namespace Controllers%s;
modules('test');

class %sControllerTest extends \Test\ControllerTestCase
{
	public function test_the_truth() 
	{
		ensure(true);
	}
}
?>
TC
		, $ns_clause, $plural_camel);
			
	if (!is_file($test_path))
		write($test_path, $test_text);
		
	if (!$overwrite && is_file($controller_path))
		return;
	
	$controller_text = <<< 'CONTROLLER_TEXT'
<?php
namespace Controllers%s;
%suse Models\%s;

class %sController extends ApplicationController
{
	static $layout = '%s';


CONTROLLER_TEXT;
	$layout = join('\\', array_filter(array($ns_camel, $plural), function($x) { return !empty($x); }));
	
	$controller_text = sprintf($controller_text, $ns_clause, $use_app_cont, $singular_camel, $plural_camel, $layout);
	
	global $EXT;
	
	$index_pattern = 'GET /' . $mapping_part . $EXT;
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function index()
	{
		$this->%s = %s::all();
	}


CONTROLLER_TEXT
		, $index_pattern, $plural, $singular_camel);

	$add_pattern = 'GET /' . $mapping_part . '/add' . $EXT;
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function add()
	{
		$this->%s = new %s;
	}


CONTROLLER_TEXT
		, $add_pattern, $singular, $singular_camel);
		
	$create_pattern = 'POST /' . $mapping_part . '/add' . $EXT;
	
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function create()
	{
		$this->%s = new %s($this->params);
		
		if ($this->%s->save())
			$this->redirect_to(array('index', 'notice' => '%s was successfully created.'));
		
		$this->render('add');
	}


CONTROLLER_TEXT
		, $create_pattern, $singular, $singular_camel, $singular, 
		str_replace('_', ' ', ucfirst($singular)));
	
	$show_pattern = 'GET /' . $mapping_part . '/:id' . $EXT;
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function show()
	{
		$this->%s = %s::find($this->params->id);
	}


CONTROLLER_TEXT
		, $show_pattern, $singular, $singular_camel);
	
	$edit_pattern = 'GET /' . $mapping_part . '/:id/edit' . $EXT;
	
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function edit()
	{
		$this->%s = %s::find($this->params->id);
	}


CONTROLLER_TEXT
		, $edit_pattern, $singular, $singular_camel);
	
	$update_pattern = 'POST PUT /' . $mapping_part . '/:id' . $EXT;
	$controller_text .= sprintf(<<<'CONTROLLER_TEXT'
	# %s
	public function update()
	{
		$this->%s = %s::find($this->params->id);
		
		if ($this->%s->update_attributes($this->params))
			$this->redirect_to(array(
				'action' => 'show', 
				'params' => $this->%s->id,
				'notice' => '%s was successfully updated.'
			));

		$this->render('edit');
	}


CONTROLLER_TEXT
		, $update_pattern, $singular, $singular_camel, $singular, $singular,
		str_replace('_', ' ', ucfirst($singular)));
	
	$delete_pattern = 'POST DELETE /' . $mapping_part . '/:id/delete' . $EXT;
	$controller_text .= sprintf(<<< 'CONTROLLER_TEXT'
	# %s
	public function delete()
	{
		$%s = %s::find($this->params->id);
		$%s->delete();
		$this->redirect_to(array('index', 'notice' => '%s was successfully deleted.'));
	}
}
?>
CONTROLLER_TEXT
		, $delete_pattern, $singular, $singular_camel, $singular,
		str_replace('_', ' ', ucfirst($singular)));
		
	write($controller_path, $controller_text);
}

function make_scaffolding_routes($full_singular_sn)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
		
	if ($ns)
	{
		$full_cont_sn = $ns . '\\' . $plural;
		$m_part = str_replace(array('_', '\\'), array('-', '/'), $ns)
			. '/' . str_replace('_', '-', $plural);
	}
	else
	{
		$full_cont_sn = $plural;
		$m_part = str_replace('_', '-', $plural);
	}
	$pc = 'Controller ' . _camelize($full_cont_sn);
	new_route($full_cont_sn, 'index', 'GET', $m_part, $pc);
	new_route($full_cont_sn, 'create', 'POST', $m_part . '/add', $pc);
	new_route($full_cont_sn, 'add', 'GET', $m_part . '/add', $pc);
	new_route($full_cont_sn, 'update', 'POST PUT', $m_part . '/:id', $pc);
	new_route($full_cont_sn, 'edit', 'GET', $m_part . '/:id/edit', $pc);
	new_route($full_cont_sn, 'delete','POST DELETE',$m_part.'/:id/delete',$pc);
	new_route($full_cont_sn, 'show', 'GET', $m_part . '/:id', $pc);
}

function add_sql_table($full_singular_sn, $fields)
{
	$path = 'sql' . DIRECTORY_SEPARATOR . 'schema.sql';
	check_file_exists($path);
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$table_name = _pluralize($singular);
	$sql_text = read($path);
	
	if (strpos($sql_text, "CREATE TABLE $table_name") !== false)
		return;
	
	$declarations = array();
	$sql_code = PHP_EOL . "DROP TABLE IF EXISTS $table_name;" . PHP_EOL 
		. "CREATE TABLE $table_name (" . PHP_EOL
		. "\tid INT UNSIGNED NOT NULL AUTO_INCREMENT," . PHP_EOL;
	
	foreach ($fields as $f)
	{
		$sql_code .= "\t$f->name";
		$declarations[] = $f->declaration();
		if ($f->is_int())
		{
			$sql_code .= ' INT';
			if ($f->is_id())
				$sql_code .= ' UNSIGNED';
		}
		elseif ($f->is_float())
			$sql_code .= ' DECIMAL(10,2)';
		elseif ($f->is_bool())
			$sql_code .= ' TINYINT(1)';
		elseif ($f->is_text())
			$sql_code .= ' TEXT';
		else
			$sql_code .= ' VARCHAR(255)';
		
		if (!$f->is_nullable())
			$sql_code .= ' NOT NULL';
		
		$sql_code .= ',' . PHP_EOL;
	}
	
	$sql_code .= "\tcreated_at DATETIME," . PHP_EOL . "\tupdated_at DATETIME," . PHP_EOL 
		. "\tPRIMARY KEY (id)" . PHP_EOL . ') ENGINE=MYISAM DEFAULT ' 
		. 'CHARACTER SET=utf8 COLLATE=utf8_general_ci;' . PHP_EOL;
	
	if ($sql_text)
		$sql_text .= PHP_EOL;
	
	write($path, $sql_text . "-- php prag model $singular " 
		. join(' ', $declarations) . $sql_code);
}

function add_sql_data_reset($full_singular_sn)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$table_name = _pluralize($singular);
	$path = 'sql' . DIRECTORY_SEPARATOR . 'data.sql';
	check_file_exists($path);
	$text = read($path);
	
	if (strpos($text, "TRUNCATE $table_name;") !== false)
		return;
	
	if ($text)
		$text .= PHP_EOL;
	
	$text .= "TRUNCATE $table_name;";
	write($path, $text);
}

function new_model($full_singular_sn, $fields, $overwrite, $tableless=false)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$singular_camel = _camelize($singular);
	
	$path = _make_app_dirs('Models') . DIRECTORY_SEPARATOR . $singular_camel . '.php';
	
	$test_path = _make_test_dirs('Models') . DIRECTORY_SEPARATOR . $singular_camel . 'Test.php';
	
	$test_text = sprintf(<<< 'TC'
<?php
namespace Models;
modules('test');

class %sTest extends \Test\UnitTestCase
{
	public function test_the_truth() 
	{
		ensure(true);
	}
}
?>
TC
		, $singular_camel);
		
	if (!is_file($test_path))
		write($test_path, $test_text);
	
	if (!$overwrite && is_file($path))
		return;
	
	$validates_presence = array();
	$validates_numericality = array();
	$validates_inclusion = array();
	
	foreach ($fields as $f)
	{
		if (!$f->is_nullable())
			$validates_presence[] = "'$f->name'";
		if ($f->is_int() || $f->is_float())
			$validates_numericality[] = "'$f->name'";
		if ($f->is_bool())
			$validates_inclusion[] = "'$f->name'";
	}
	
	$validations = array();
	
	if (count($validates_presence) === 1)
		$validations[] = 'static $validates_presence_of = ' . $validates_presence[0] . ';';
	elseif (count($validates_presence) > 1)
	{
		$one_line = 'static $validates_presence_of = array(' . join(', ', $validates_presence) . ');';
		
		if (strlen($one_line) <= 110)
			$validations[] = $one_line;
		else
			$validations[] = 'static $validates_presence_of = array(' . PHP_EOL . "\t\t" 
				. join(',' . PHP_EOL . "\t\t", $validates_presence) . PHP_EOL . "\t);";
	}
	
	if (count($validates_numericality) == 1)
		$validations[] = 'static $validates_numericality_of = ' . $validates_numericality[0] . ';';
	elseif (count($validates_numericality) > 1)
	{
		$one_line = 'static $validates_numericality_of = array(' . join(', ', $validates_numericality) . ');';
		
		if (strlen($one_line) <= 110)
			$validations[] = $one_line;
		else
			$validations[] = 'static $validates_numericality_of = array(' . PHP_EOL . "\t\t"
				. join(',' . PHP_EOL . "\t\t", $validates_numericality) . PHP_EOL . "\t);";
	}
	
	if (count($validates_inclusion) > 0)
	{
		$validates_inclusion[] = "'in' => array(0, 1)";
		$one_line = 'static $validates_inclusion_of = array(' . join(", ", $validates_inclusion) . ");";
		if (strlen($one_line) <= 110)
			$validations[] = $one_line;
		else
			$validations[] = 'static $validates_inclusion_of = array(' . PHP_EOL . "\t\t"
				. join(',' . PHP_EOL . "\t\t", $validates_inclusion) . PHP_EOL . "\t);";
	}
	
	$validations_str = PHP_EOL . "\t" . join(PHP_EOL . PHP_EOL . "\t", $validations) . PHP_EOL;
	
	if ($tableless)
	{
		$attrs = PHP_EOL . join(PHP_EOL, array_map(function($f) { return "\tpublic $" . $f->name . ';'; }, $fields)) 
			. PHP_EOL;
		$model_class = "TablelessModel";
	}
	else
	{
		$model_class = "Model";
		$attrs = '';
		add_sql_table($full_singular_sn, $fields);
		add_sql_data_reset($full_singular_sn);
	}
	
	write($path, sprintf(<<< 'MODEL_TEXT'
<?php
namespace Models;
modules('activerecord');

class %s extends \ActiveRecord\%s
{%s%s}
?>
MODEL_TEXT
		, $singular_camel, $model_class, $attrs, $validations_str));
}

function make_scaffolding_form($full_singular_sn, $fields, $overwrite,
	$scaffold=true)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	if ($scaffold)
	{
		$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR
			. str_replace('\\', DIRECTORY_SEPARATOR, $ns_camel) . DIRECTORY_SEPARATOR 
			. $plural_camel . DIRECTORY_SEPARATOR . 'form.part.php';
		$button_name = 'Save';
	}
	else
	{
		$path = $ns_camel
			? 'app' . DIRECTORY_SEPARATOR . 'views' . str_replace('\\', PHP_EOL, $ns_camel)
			: 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR . 'shared';
		
		$path .= DIRECTORY_SEPARATOR . $singular . '_form.part.php';
		$button_name = 'Send';
	}
	
	if (!$overwrite && is_file($path))
		return;
		
	$inputs = '';
	$required = '';
	foreach ($fields as $f)
	{
		$inputs .= PHP_EOL . "\t<div class=\"field\">" . PHP_EOL;
		
		if ($f->is_bool())
			$inputs .= "\t\t" . '<?php echo $f->check_box(\'' . $f->name . "') ?>" . PHP_EOL 
				. "\t\t" . '<?php echo $f->label(\'' . $f->name ."') ?>"  . PHP_EOL;
		else
		{
			if ($f->is_nullable())
				$suffix = '';
			else
			{
				$suffix = ' *';
				if (!$required)
					$required = PHP_EOL . PHP_EOL . '<p><small>* Fields required</small></p>';
			}
			
			$inputs .="\t\t" . '<?php echo $f->label(\'' . $f->name . "') ?>" . $suffix . "<br />" . PHP_EOL;
			
			if ($f->is_text())
				$inputs .= "\t\t" . '<?php echo $f->text_area(\'' . $f->name 
					. "', array('rows' => 10, 'cols' => 80)) ?>" . PHP_EOL;
			elseif ($f->is_float() || $f->is_int())
				$inputs .= "\t\t" . '<?php echo $f->text_field(\'' . $f->name . "', array('size' => 10)) ?>" . PHP_EOL;
			else
				$inputs .= "\t\t" . '<?php echo $f->text_field(\'' . $f->name . "', array('size' => 60)) ?>" . PHP_EOL;
		}
		$inputs .= "\t\t". '<?php echo $f->error_messages(\'' . $f->name 
			. "', array('wrap_in' => 'p', 'class' => 'error')) ?>" . PHP_EOL . "\t</div>" . PHP_EOL;
	}
	write($path, sprintf(<<< 'FORM_TEXT'
<?php echo form_for($this->%s, $options, function($f) { ?>
%s
	<div class="actions">
		<?php echo $f->submit('%s') ?>
	</div>

<?php }) ?>%s
FORM_TEXT
		, $singular, $inputs, $button_name, $required));
}

function make_scaffolding_edit($full_singular_sn, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name_camel = join('\\', array_filter(array($ns_camel, $plural_camel), function($x) { return !empty($x); }));
	$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR 
		. str_replace('\\', DIRECTORY_SEPARATOR, $full_name_camel) . DIRECTORY_SEPARATOR . 'edit.php';
	
	if (!$overwrite && is_file($path))
		return;
		
	write($path, sprintf(<<< 'EDIT_TEXT'
<h1>Edit %s</h1>

<?php echo $this->render(array('form', 'options' => array('update', 'params' => $this->%s->id))) ?>

<p>Updated at: <?php echo $this->%s->updated_at->format('Y-m-d H:i:s') ?></p>

<nav>
	<?php echo link_to('Show', array('show', 'params' => $this->%s->id)) ?> |
	<?php echo button_to('Delete', array('delete', 'params' => $this->%s->id, 'confirm' => 'Are you sure?')) ?> |		 
	<?php echo link_to('Back to index', 'index') ?>
</nav>
EDIT_TEXT
		, ucwords(str_replace('_', ' ', $singular)), $singular, $singular,
		$singular, $singular));
}

function make_scaffolding_add($full_singular_sn, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name_camel = join('\\', array_filter(array($ns_camel, $plural_camel), function($x) { return !empty($x); }));
	
	$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR
		. str_replace('\\', DIRECTORY_SEPARATOR, $full_name_camel) . DIRECTORY_SEPARATOR . 'add.php';
	
	if (!$overwrite && is_file($path))
		return;
	
	write($path, sprintf(<<< 'ADD_TEXT'
<h1>New %s</h1>

<?php echo $this->render(array('form', 'options' => 'create')) ?>

<nav><?php echo link_to('Back to index', 'index') ?></nav>
ADD_TEXT
		, ucwords(str_replace('_', ' ', $singular))));
}

function make_scaffolding_index($full_singular_sn, $fields, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name_camel = join('\\', array_filter(array($ns_camel, $plural_camel), function($x) { return !empty($x); }));
	
	$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR 
		. str_replace('\\', DIRECTORY_SEPARATOR, $full_name_camel) . DIRECTORY_SEPARATOR . 'index.php';
	
	if (!$overwrite && is_file($path))
		return;
	
	$headers = '';
	$data = '';
	
	foreach ($fields as $f)
	{
		$headers .= "\t\t<th>" . str_replace('_', ' ', ucfirst($f->name)) . "</th>" . PHP_EOL;
		if ($f->is_bool())
		              
			$data .= "\t\t\t<td class=\"bool\"><?php echo $" . $plural[0] . "->" . $f->name 
				. " ? 'Yes' : 'No' ?></td>" . PHP_EOL;
		elseif ($f->is_float() || $f->is_int())
			$data .= "\t\t\t<td class=\"numeric\"><?php echo $" . $plural[0] . "->" . $f->name . " ?></td>" . PHP_EOL;
		else
			$data .= "\t\t\t<td><?php echo $" . $plural[0] . "->" . $f->name . " ?></td>" . PHP_EOL;
	}
	
	write($path, sprintf(<<< 'INDEX_TEXT'
<h1>%s</h1>

<table>
	<tr>
%s		<th colspan="3" />
	</tr>

	<?php foreach ($this->%s as $%s): ?>
		<tr>
%s			<td><?php echo link_to('Show', array('show', 'params' => $%s->id)) ?></td>
			<td><?php echo link_to('Edit', array('edit', 'params' => $%s->id)) ?></td>
			<td><?php echo button_to('Delete', array('delete', 'params' => $%s->id, 'confirm' => 'Are you sure?')) ?></td>
		</tr>
	<?php endforeach ?>
</table>
<br />
<nav><?php echo link_to('Add the new %s', 'add') ?></nav>
INDEX_TEXT
		, ucwords(str_replace('_', ' ', $plural)), $headers, $plural, $plural[0], $data, $plural[0], $plural[0],
			$plural[0], str_replace('_', ' ', $singular)));
}

function make_scaffolding_show($full_singular_sn, $fields, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name_camel = join('\\', array_filter(array($ns_camel, $plural_camel), function($x) { return !empty($x); }));
	
	$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR
		. str_replace('\\', DIRECTORY_SEPARATOR, $full_name_camel) . DIRECTORY_SEPARATOR . 'show.php';
	
	if (!$overwrite && is_file($path))
		return;
	
	$data = '';
	
	foreach ($fields as $f)
	{
		$screen_name = ucfirst(str_replace('_', ' ', $f->name));
		
		if ($f->is_bool())
			$data .= "<p><strong>" . $screen_name . '</strong>: <?php echo $this->' . $singular 
				. "->" . $f->name . " ? 'Yes' : 'No' ?></p>";
		else
			$data .= "<p><strong>" . $screen_name . '</strong>: <?php echo $this->' . $singular 
				. "->" . $f->name . " ?></p>";
		
		$data .= PHP_EOL . PHP_EOL;
	}
	
	write($path, sprintf(<<< 'SHOW_TEXT'
<h1>%s</h1>

%s<br />

<p>Updated at: <?php echo $this->%s->updated_at->format('Y-m-d H:i:s') ?></p>

<nav>
	<?php echo link_to('Edit', array('edit', 'params' => $this->%s->id)) ?> | 
	<?php echo button_to('Delete', array('delete', 'params' => $this->%s->id, 'confirm' => 'Are you sure?')) ?> | 
	<?php echo link_to('Back to index', 'index') ?>
</nav>
SHOW_TEXT
		, ucwords(str_replace('_', ' ', $singular)), $data, $singular,
		$singular, $singular));
}

function make_scaffolding_layout($full_singular_sn, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name = join('\\', array_filter(array($ns_camel, $plural),
		function($x) { return !empty($x); }));
	
	$path = 'app' . DIRECTORY_SEPARATOR . 'views' . DIRECTORY_SEPARATOR . 'layouts' . DIRECTORY_SEPARATOR 
		. str_replace('\\', DIRECTORY_SEPARATOR, $full_name) . '.php';
	
	if (!$overwrite && is_file($path))
		return;
	
	write($path, sprintf(<<< 'LAYOUT_TEXT'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<?php echo stylesheet_link_tag('scaffold.css') ?>
	<title>%s</title>
	<!--[if lt IE 9]>
	<?php echo javascript_include_tag('http://html5shiv.googlecode.com/svn/trunk/html5.js') ?>
	<![endif]-->
</head>
<body>
	<?php if ($this->flash->notice): ?>
		<aside class="notice"><?php echo $this->flash->notice ?></aside>
	<?php endif ?>
	<section>
		<?php echo $this->yield() ?>
	</section>
</body>
</html>
LAYOUT_TEXT
		, ucwords(str_replace('_', ' ', $plural))));
}

function make_scaffolding_templates($full_singular_sn, $fields, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$plural = _pluralize($singular);
	$ns_camel = _camelize($ns);
	$plural_camel = _camelize($plural);
	$singular_camel = _camelize($singular);
	$full_name_camel = join('\\', array_filter(array($ns_camel, $plural_camel), function($x) { return !empty($x); }));	  
	
	_make_ns_dirs(_make_app_dirs('views'), $full_name_camel);
	_make_ns_dirs(_make_app_dirs('views', 'layouts'), $ns_camel);
	
	make_scaffolding_layout($full_singular_sn, $overwrite);
	make_scaffolding_form($full_singular_sn, $fields, $overwrite);
	make_scaffolding_index($full_singular_sn, $fields, $overwrite);
	make_scaffolding_show($full_singular_sn, $fields, $overwrite);
	make_scaffolding_edit($full_singular_sn, $overwrite);
	make_scaffolding_add($full_singular_sn, $overwrite);
}

function new_scaffolding($full_singular_sn, $fields, $overwrite)
{
	make_scaffolding_routes($full_singular_sn);
	make_scaffolding_controller($full_singular_sn, $fields, $overwrite);
	new_model($full_singular_sn, $fields, $overwrite);
	make_scaffolding_templates($full_singular_sn, $fields, $overwrite);
}

function new_form($full_singular_sn, $fields, $overwrite)
{
	list($ns, $singular) = _get_ns_and_name($full_singular_sn);
	$ns_camel = _camelize($ns);
	
	if (!$ns_camel) 
		_make_app_dirs('views', 'shared');
	else
		_make_ns_dirs(_make_app_dirs('views'), $ns_camel);
	
	new_model($full_singular_sn, $fields, $overwrite, true);
	make_scaffolding_form($full_singular_sn, $fields, $overwrite, false);
}

# New work functions ######################################################
	
function new_work($work)
{
	if (is_dir($work))
		error("Directory $work already exists");
	
	mkdir($work, 0755);
	
	if (function_exists('symlink'))
		symlink(__FILE__, $work . DIRECTORY_SEPARATOR . 'prag');
	else
		copy(__FILE__, $work . DIRECTORY_SEPARATOR . 'prag');
	
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'app')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'app', 'Controllers')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'app', 'Models')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'modules')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'config')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'sql')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'app', 'helpers')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'temp')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'app', 'views')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work,'app','views','layouts')),0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'locales')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'errors')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'test')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'test', 'Controllers')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'test', 'Models')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'test', 'fixtures')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'public')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work, 'public', 'images')), 0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work,'public', 'stylesheets')),0755);
	mkdir(join(DIRECTORY_SEPARATOR, array($work,'public', 'javascripts')),0755);
	make_modules($work);
	make_controllers($work);
	make_config($work);
	make_db($work);
	make_helpers($work);
	make_errors($work);
	make_public($work);
	make_images($work);
	make_test($work);
}

function make_test($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'test' . DIRECTORY_SEPARATOR . 'fixtures' . DIRECTORY_SEPARATOR;
	
	write($path . 'default_test_fixture.php', sprintf(<<< 'RT'
<?php
const USE_COLOR = %s;
modules('test');

# Add your setup stuff specific to your test suite here, e.g. fill the test
# database with default testing data.

$suite = new Test\TestSuite('%s Tests');
$suite->require_all('Models');
$suite->require_all('Controllers');
$suite->run();
?>
RT
		,(strtoupper(stripos(PHP_OS, 'WIN') !== 0) ? 'true' : 'false'), 
		ucwords(str_replace('_', ' ', $work)), 
		ucwords(str_replace('_', ' ', $work))));
}

function make_images($work)
{
	$pragwork = <<< IMG
iVBORw0KGgoAAAANSUhEUgAAALUAAAAoCAYAAAC4q7s0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAR3AAAEdwBflke3gAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABXOSURBVHic7V15eJvFmf99kmzZsk7LsmRLcuw4vu0kzkFOkjQQSAJ0oW1aNmmzoZSjRxayB90CIbBdKGR7sO3DQtkSmpZAOUIgHGnSkANykMNXLju+z0jyJcmyJMuW5ts/ZMuSZj7JTvM8odS/55k/vm9+8847M+838847I5vjeR459/whH8CzYhG3IkB4DaYwhb8hiEWcPUD4IwD+o+XVjfVc9qad+RyHap5H8vVWbgpT+GvAcfDyPGaLADw7ZdBT+DJg1I6flYy6HNdbny8V1ClS7Niy8nqr8XeBQe8IfrmnGtXNvQAAsYhbIZnyoa89JGIO5bm6663G3xU2/uIgACBAeI3oOusyhSn81ZAnJ0Q8S66THn9TUMoSUWBSw6iVQy2XorN3EK22AbR1uzDiJxSf47jroGVs1HXY0WRxorXbBZlUghy9EkVZGujVsuut2jWHoFH/z4M3YlGhgZnnHfaj2+FFt8MLm8ODmuZe7DvbjmF/QLCi/1g3F19bMp2ZNzQcgM3hgdXugaXfg4ttfXHlCeHn31uCZaWZ1Ps9J5rxs7cqJiVr9vQ0bFpVhNVzsyBNEFP5AcKjrduFPx66jD8drcfQcFDfET/Bon95B/4AbfC7HrkF+UZ1xLuf/P4kDlZ1RLwTi0Q49OydkEkjh2jdM39Gq22AkvvE+htwx4LsiHeE5/H2Z43YcaAW9V0OqoxYxOHmcjMeWFMS01166KXPcKLWwsxLSUqAQSNDRmoK9JpkzJ2RjpWzTBCLhD/spf+2G74Remz3brsNGakpoeePz7Rh22unmDK23DUb61fkM/MEjVolS4ROJRwUydIpIp6fWD+Etz5rxGuHLqOrz03x5ckJMeWZdfKI520bfPjT0QbsOsyWx4JYxOGWOWYokhOpvNXzsiZs1GIRhy13zcb3byuFKMasKxZxmG5QYtv6+fjh7WV4ed9F7Dp8GRIxB1WKFJc77VSZZusAZdRHz19B78AQxa1p7sWiovGJheeBcy19zI89x6CMePb4/Nj84qc4VNMpqH+A8Nhf0Y6DVR14/O552LSqiMlzuH1M/QCgd2AIbd2usDcXYdDIsOEr+bh7eT7SlElUmR7nELMN4QELf4Bg+zuVzHpzDEqsWzpDsF3XzKdOVSThwbWl+OipOzAjU/VXy9PIpfj+baX480+/iuKs1AmVmTNDxzRoIPgRZuuVzLxwiEUcXvzRCvzw9rKYBh2NNGUSHv3WXBSZg/vu0mlsnaNnWUu/G5Z+9kdb0dgT8Wy1u5nGIBGLUBD2ofgDBN/5+V9iGnQ4AoTHU6+fwQsfnp8QPx6sdg9+8W411j7xAdp7XPELMLDrcH3UxzKO//z2AiRIhE1XMIfneRBCJp0UyRK8umUl9OrkKHmTl0UIgUwqxo6HvwJzmlxA03HcWJIZU9aykoy4Mratn4+bZhmvStd3jzeFDLE4ix1UarUNRJQ5W98tqEtFY3cEl+V2AEC+UQWxCCHez96qQGXUBzER/GpPNU5ftlLtulr0OL3Y+POD6HF4JiRvLN/l8eHXe88xOWvmZWFxkT5SRz4yJB3TqK82ZWhkeHnziih5Vy8zTZmEV7esjPl1AsCy0oyYcm4sjW3UZdlarF+RJ1i+qqkHe04042StFVf63AgQEspzD43guXcqQ7KEjdoVIfNso7BRVzX2gJBxrpBRl2SlhjhNFid2HKgVlDktXQGljL2aBQiPJ3edYbb9atHW7cJ9vzkSJYstb8xGXt53Cf0u2u1Ilkrw6Dfn0rpF6SfoU5PRmToa/7e/FscvWVGSpUFZthYLC9OhTpFSvCKzGjNztDjX0jeqMFvee5+3YtfhesikEkxLV2DDijwUmNQUL0uXguWlmThYzV5StYokFJnUMWeCG/LTkSgRYZgRsQCAB9cUM8v7AwT//NvjVN0auRS3zZ+GuxblYH9lB7od3lBeoVEFjqP6G23drog6KhqEjdrpGUbjFQdyM4JuU5uNvRwXmzUhmbuPNTE5c3LT8ON15SifngbfSACfVHfhiV1nMOAZjuDVdthxobVP8KMMx323FmFVuQku7wiarQPY+Uk9OnsHKV5Ncy/OtfQKumRj4HkCm8ODV/7C/ih/cFsJ9OokaoyinwWNmhdYKtq7XThRa8WJWisAIEsnxxuP3AStgt4QLCvJiGvU1n43akY5J+tsePdEM/ZuXY1svYLirpwpbNRLivXgeUIZUTikEg7z8nQ4UWuj8mZkKLFyZiZTxxc+vMCs1z7ow2uH6/Ha4XoqLzlRjCydgvILbQ4PPL4RJCWI4fX5UddJRyXCUdHYjRx90PVqFfAxC02q0DL83uctVH6iRIRnNy1Alk4OQggSxBxWzzXB5vDgZ29XUfy3jzVh691zQs9CM7VRm4KZ2UFDXVKkx23zsrD2yY/hcA9T3EM1XSg205NVOAgh+M3ei/D6/FRejl6BTSvzmeMTrV8M94PtLkSjvWcQ+ys6mFyDJjlMHntJj8awn+D9U60Cbo1w9GRpsWFCrszSYnaY8r7VRQBofm2HHS/tuyRYL7PvRttbnEUPIs8DHT1BF6S6pQ/xrihUNfWGdGnvoWdBEcehwKgCz/M4fskKW9hqMYa7l+XCnJZCtW398lwYNHSc+oPTbfCNBOK6HtHyNPJE3DTLyOR29g7GlddiG8Dbx5qZeVvvngOJmJuQHYnAE7CS0MaOZ3AbrjiYXGWyJL48Qsuz9ruZXJUsgakrB4JFhekU/8i5LurdkqJ0qryY43HrbPbmcNfhegQCAWa9sRIhBEVGFTOvxRrcLFY2dMeVU9k0vlls73ZS+dPSZZAmiEAIwUenW5kyyqdrmW0TcUDZNDXFH3AP4dML433HGnOhMU1XSZncXuf4ZlGorc+/d47Z17eWG7EgXxdzkx7Ol/CEfcBBSIA91ZMAosuoZQlMbtMVR4gr5M4QhjyDWsrkWvrdFBcAiqelUjrwPPDix+extFgfwZ2uVyBdKYXN4Qm902tSQtGDiLbywNFzncw6Y4Ef7btCo5JZts3mBCEZqGi0UfmK5AS4vCOh5xaLA3bXEAjPY9Djo2QVGVUhvZutDmZ9uXq54F5jhkGOA4wyrVYnyOjGmjXmwff0mHbb2WOkV42PaVAerc/5Fjpik5wowb9/rSxu1CS8TgnPOPUCABIQMMIAQXSZOblaJvdCS2+IKySPJ5HyOA5YXprB5LbZnFTdALCkIJ3iN1qcqG7ogc3upg59lhSmY/fx8WXOrE1h1lfbYYdNIIYcE6NtzTeqmPq2WgfgDwRQ3dgTkS/iOCzMT8eByvHTRR5AVVM3VDIpU1ZhmFFf6RlkcjJTZYJGkamRMctY+tzjRsgYc4Ae02E/wbELV5jcbJ08rjwWHlhdCJ2S3hyGI9qGBGdqIf+Hj/oqVpWbMT9Px+Seb+kZn6l5ElcexwEPrC1FoUnN5H5S1cGcBRYX6yn+mcvBWbCioRu3zs2i+O981hB6NqfJmPW1WJ2TnqWB0dWH56FOSYReJYXV7onIb7M50djlgMsdGbYypMkxI0OB/VF1VjX2YLqBPesXmIL+tD9A0GN30/6liAv5oixIE0RMuZa+wVCZ6DEfQ/iY+gME29+qxJVeejPLccCysowweeyZOho5BiW+szI/bkiR56NmaggZtYC78N1bCmHUJsM5OIyyHC1WzjYzeScvWWAJa+DYkhyNm8tNEHM8CA/cUKhHcVYqk3epvR+na69Q7xWyRJRNo8ucqbMAJICzl61YVW6KyFuQnw4xSGiTZtayZzJL7yCE+icmwtpaZFLB2hc50JZeF5quOCjZuXo5phsU1Pv6jj7IEkRMXQpGZ2prvxskQEcNpAmSmLNcohhMudY+V4S7wOK8deQyunoH4BsO4MQlC1qs7Dj6splGmNPCVkMSACZg1D/5ZjlEHO0WRoMQEqHfpH1qgyYZ/3RzYeiZFUYb9I7giZ0nIr4eodMko1aGb99UEKlgFHwjATzz+inmbHFDng4ADxIVRai4bAVPAjh72ULJlEnFKJ2mQXXTqA/Hs3Vze32CM/U/fqUASxkXp154vwa20RM0IHjad6iqLYJj6x9EZ88AJbvIrAquUlHvWywOGLUy6n2mNgXyJEnYppvl93KT8kfHywUijJrFqWvvRV17r6BsIHjD8aE7Z0budyYwU4tEHBLEsXUXasOk3Y+J4Lk3T1Ozk5D7EQ+E5/HYK8dQ00jHlgFg0WgoLxyttgH0OILhr4bOPjgGh6CKOiBaXGxAVUMw1t7VO8DUTZGcIGjUOQYFFhfTJ5SvHbwEa38gJK/QTBupdyiA2rZe6n2hWYOMVBmUyRI43eObwg6bA9YMBc0Pc9N0qiRwPH1kPOSL3e9DvhFmG9NVSePuAs82/HiQJojx/PeXIVuvjNBByJ0JR4AAj7x8FG8+fjvUcvpwLxw84aPdD/aXIOR+xIJj0Idn3ziNA2dbr4m8mqYebH/zDGrb+gQ5i4oMlNx2mzPi9KrV4kTZ9DSq3At7guW6ok75xqCSSQSXSaH28IQAYXn5RjVTRlW9jXpfaAqeDBaZ1Pg87KpngADVDTS/IOwEVcQBaQopuh2R/jshgG/YL3jFwOsbYeoXfnI31qbJ4MaZJvzrunnISlfQ/TRBeba+QTz6u0/xm803Idbdsmj9Ju1+MLk8j0NV7Xju9VPMM/ugvMkZtT9A8NTOY2ixOAU5uZlq6FT0znhxcQY1i0ZzCkwaqFMSYHcNoavHydStKCtVcEYRak9w2R7vO50qKVRPOKx9kf6nVpkMrTIY9iowq3HyYuQJZo+dPngpiLoWoFcnwdZPb9Q6up3INrBvTrbb2GHA8IiDkPshBGWKFFs3LECqQNRiMvKOn+/AKx/X4LtrygQ50WHhSbsfL75fhVarE7Ny02Gzu1Hb1ofatj54fCMMKREtYcr7+PMmLCkzUe6BWMThufuXYeMzHzKPTQFgYRHtekwGCwr12HeqGV09bPcjK12BTK0MXYzrkzyJFc2JzCswqXHyYldMXQrN6jCXRTOhQS8wayLqyUqXo6bRSvEaOvsxTeDabUNHH7Muk04eN/rxjeUF2Hu8kboO63R58OOXD+OlLbdCxPixgJBRLy4x4gSjn/73vQrMytVhTp6eygNGbTVMnghjO9uoNLa8Rqd+pxsHzzThF386idf2n0NFXRc83iGmjPBEAgGmPGu/C9t2HGXmZeuVePzbiwRlLirOiHnKFC8tKsoASACDbi+qG+grl4QQ3DI3S6B/2O0JtTfsXYFRHbd/CkcvJRFCUGjWxOVr5YnQyKUR9ayaO43Jraq3MHX1DftxoclG8ZVJYiwM61shHWZkqvDw1+cw8ypqu/Dr3Wdi9lF0eujrc2FOS6Ftx+/HT146FHEqGUumaOyriU5jS2h0GvtqJ5+Ej8k/rWrFGwcvMPNvnjsN61YUUPKkEg4zc2MfncZLNxRlAHxQ3h/+XMPk3Lt2FgpGIxITaQ8htMHnm1nlI1NBmFEbUlOgSJbE4aupuucXGpCmlFLc3Ycvoc1KX2V485ML6O53Ufxb5+dAIuKoNrH64OvLC7B8lomZ/4d91ThU0cIYc7Y8aYII2zYtAQea02N34fGXD8HPmByjuaLQckkloUtBQvw4SeiS0Wj+r986hbq2XibnoW/MR0l2WoS8Ofl6JIhFFNfu8uL1v1ygkts7THHVcinyTangCcHRyla025wURyLm8PT9K7CoOBMSESbQHp7KzxutI1YqzNJGlCkwaWLy80ypVN0cgDULcimub3gET75yFOcabeB5Hr5hPw6cbsLvPqhkyr598Qx2mwTG9PGNS6BXy5icJ3ccQZvVwRxzlrzSHB023lLKzD91sROvfFAV0454QiZ/+CIUiI8H4bskwaVjeDiAx146iJ1b70SyNPIn7yIOeOb+Fdj40z1wjG64Fhaxr4mePN+BX71xnHpv1smxuMxMvV9YnIG6FhsIgF37a/DIhiUUJ1Mrxy83r4LbO4KqBguSEiWYYWQfEoW7H+HlU6QiuL3sfUeqMhnaqE1VgTkVpy92MPlAcKPLqn/twlzs/KiSen+u4QrufeY9mNKVcA4OweWhr4cCQL5Zi7xo2QJjPjamKUkJ+On3luHB7R8hEKWT2x3Aj184gFce/QckJQZvOgvZ0Ji8e2+fjePn2lDfTke9fvf+WczM1WFeYWZYucjDl0m7H7GWj6txP8KXtjZLP57742dMXpoqGU/duxzcaMx0QTH7p1uVdZ3M+ivq6Bt7hBAsKM4McT78rA6NHX2C7U6WirG41IQ5+QYoUxIn7H7wPEGeUSPYN+Gux1gqMAvzeRJAHqMMIQTmdAW+dVOxYLkOqx0Dg15mHgeCLXcviDlGQmNakqPDfXfMZvIaO3rx9O/H903CNhfMF3HAE/csQ4IYFCcQ8GPrbw+ixz4oaJOCRh3bXbg6oxaWOc77+Hgd9p2sZ/LmFWaibLoOmdoUGHUKJqeirotZf2VdJ5NfkqNDilQMngQw5PPh4V99CFv/oLCu8dJY/0S9z4thpAVm2pXIz9IK8uVJEhhS5YI6/OBr81GSkzbpMbrvjjmYmaufxJhHjumG1TMxr9DA5O4/eRntY26IoA7jsnIy1HjwzrlMXp9jEO99WhvlEocZtWC0QmC2ircrn2w0hWdwt+88gjaLncnnQARn6R77INqv9DHrr2u2we31MeQBcwsMIV533wDuf3o3zl7qEOyDWEmo//JNqYJ9k59F33fO0MqhSJKw+Sb2LB0+0z3/8BosKTVNaGxEIHj4WwvxnTWzJjXm0WMKnsfWe1YgVZ7I5I9t8iZqc+tWlqI8T8/kBvz+MBuKlCkROoMfGPSilxHw9/qGMZEbVtFweYaY8jweHyXP4/Vh60v7sX3zGurPFAwPjyA/S8uUdeJcu6BufkJwoqYVs/Loo+2ibB2OnG0KPVt7B7D5v9/H2iWF+OqyIpRMZ8dHx9BqsePz8+04ea4dNQ0WKFPo++D5Zi00Ase9eWb21d3yfAPOM+LOZbn0VdtoSBPEeOaHt+CjY3V4++B5NHf1UxyRiMPS2dnYsHo2SqbrBWXKkxOYuidKRFQZjSIJj92zAv+143DwQnoYOAR/0peqSMLwCH32MJYfjsfuWYEfbX8fvuFIflKCOMQNGfaYHO2izVN/8jQOjOkqTDemQq+VQyVPhnPQiz6nB/1ODyw9LnRHfWCpShn2Pr/p+igrgKaOPrRZ7ei0OZEsTYDZoMYMsxZp6pT4hb/guNhkwwNP7w49C54oTmEcndZ+dFrpmU4IY5ueLxJyjBrkGOlfiH/R9LwahNzYUQiG9KZw9fgiGvWXGa5Bb0RITyICbw8QMvU3qq8hRkaGUXlJOMY8hWsH99Awdu49HZqpxSKRnVOXf/ddAHddX9WmMIVrhj2cevamqX9kNIUvBUL/yMhe9Wo9z2M2gD1iEUf/7dkpTOELjlG73cPzmG2verX+/wEW9xi4m5UG5wAAAABJRU5ErkJggg==
IMG;
	
	$pragwork_small = <<< IMG
iVBORw0KGgoAAAANSUhEUgAAAEgAAAAQCAYAAAC1MDndAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAaBSURBVFiF7ZhZbJxXFcd/534zY9dBSVM31sy3OHGSQkLNotahkRFZRFrRVn0IPFSKKqjEjgoUKiF4gIgtquhDQEQVJS9IqE8sFYhSp0VRolTsiUNJ4zqpEzMz3+fBjpWlTeLZ7uFh7ud8TGJRiYe+5EiWzzn/e9Z7v7uMlEqlx0Xk28ByblKWLqnqbvF9/wKw4u3OBvi0qlbf7iRSEpGHgZ05rjVnHjjn+NuAVV02WbwfuH0J33Vg2vER0HeD4CdU9R/AWuAuoMdaGxtjpj3Pu1Qul5MgCPqAQRGx1Wr1FEAURXdYaz3gXBzH5wBKpdIqz/O2ttvtkzMzMyfTGOvWrVuxsLBQAsjn8xenp6dnsjmUSqVVxph+Y0yrUqm8nsYDMMbMttttRORRk7HZF8fxBvc3AGxQ1c8Ar94AX6Wq7xaRzwGTXfX/Jh0nIvu7GnMG2FitVt8Tx/EjcRyP5vP5IeCAMeZpYKLVaj0LoKqPABOqOlksFgeiKLrFWjsJTIjIxwDCMNxrjPm3qv7CGPNqEAR/X7169UqAer2+E5gAJprNZhIEwZkgCH4WRdE9rglPABPW2pddek+68cdFZGWac7ZBaREmiqLb4jieTJJkv+d59wEXs/jAwEAxSZKJarX6DHAfcCnjYixlrLVjGf2lRqPxwTiOX4ui6JYgCHYEQXC7iJwHNorIMed/vfs/mhp6njfaarXWAgLQbreP+b7/ZVV93I39G3AZuLvZbP66uyYgAYaAT1hrx3zfX50Fi8XiEPBZNzFPlcvlqSUbtGbNmuXW2vkwDH8OUC6XExH5YxbP5/MzYRj+EiCO4zKwiBtjXswUdhhYcOIzs7OztZGRkbybtZeA2UajMUVnaY+7ccHQ0FAvsNggYNQYs97xrVwud0JEvujkH1Sr1Q+IyA7XrG1RFL03W1OhULhTVUeceKsx5v4s7nned4EC8C/P8/ZksesalJKq3pvhZ2+Avy8jXnDJnahUKnEYhv1hGL6/UqlcBQ4DGGN+BZAkyWY6+w50VoTvbI+luoWFhXuAO7jW3NF0ZdH5LAaBdc7uJYBqtfpn4E0Aa+0D3fmKyATQcLnfmoFWAruc/isu50W6rkGNRqMBHBGRrzvHAmxO8atXrzaBg8BXHW6AHS7AmEtwC7A9qwNOu0Zt6o7pbM7gGu153i6nPgK0gbuBdzrdMREJMqaVbl5V12R9t1qtUWAfnVUCcCADF+hM1ItJkjzXnVeuWxHH8RVgSyr7vv8E8K5UrtVql4EPAwwPDxd833+aayfaAQBjzFaX5F4ReQHYm8vlrBuzeKoZYx5stVonjTGfd4UdF5FtqrrVyX8xxpRUdVhVP+R04505e+tkrX3esSoiu6vV6ngQBA93DcuLiFFVm1Vet4JGRkbyvu9viaLoAbcPPZXFh4eHC8VicRnA+fPnPwJ80kFX+vr6jgC0Wq09nud9ASCO40lgutlsrnEF/jP1parJzMzMNHDeqdLPbHG1WGtT3cZUp6pxJqWomxeR6a6yUv/jcRzv6cLqQAvY7vv+N7uw6xs0Pz+/TEQOW2ufd0ftf9Hly5f7PM/bBxDH8W+B/QCqeuj06dN1gFqtNlsul5PURlXHrLX3A/T29h4ClroQLu5DrtCjInI0g2uz2TyeJMkpYMr5vhcgDMPNwDsAjDG/zzpV1U8BFrgrCILvdMW8AHzP8d8Kw3B7Flxyk/4f9GgQBLsACoXCl4BxETkAUCwWB4IguBoEwUKpVNrkCh0TkceKxeKyqampi729vcMi8lC9Xp/KOlXV8Yx4zp2Q2Qa9Pjc394Z26MdO97UwDP+qqn9wPg5VKpVXsn57enoOisiTDv9GGIYPZvEkSb7v4hhVfbZYLA78vw0C+Mng4OC6s2fPLojIT0VkDCCXy20DeoEeY8x2gEajcRBY5Xne4cHBQX9qaupitVr93dzc3BsjIyN5Ojd3arXaJHDF+T8G0G63j9OZ/UWdK+pHIvJDV/QmYBlwNJ/Pf/RGycZxvBv4EyCq+lgWU9WWtfbjdD63Ui6X25li4vu+Oj59Shg6R2w33QhPdSu4dpnMPkMuAjXHrwXydE6lV+jcWjcAdwI9wMY4jl8rFotrPc8rNJvNC7OzszWAKIrWW2tz1tr5mZmZuWxSb+WpkSTJKVW1/f39y3t7e30RebPdbtezTw2AIAgiYFmhUKjV6/XNIvLCzcfqEpQ+VuXmzx1L0iVV3f0fWN7tZqpxA8EAAAAASUVORK5CYII=
IMG;
	
	$favicon = <<< IMG
AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwRyyEZDYX+mAwEP9gMBD/YDAQ/2AwEP9gMBD/YDAQ/2AwEP9gMBD/YDAQ/2AwEP9gMBD/YDAQ/2Q2F/pwRyyEZzkY+mMzEf9jMxH/YzMR/2MzEf9jMxH/YzMR/2MzEf9jMxH/YzMR/2MzEf9jMxH/YzMR/2MzEf9jMxH/ZzkY+mo4E/9qOBP/ajgT/2o4E/9xQyD/eU8w/3lPL/9qOBP/ajgT/2o4E/9qOBP/ajgT/2o4E/9qOBP/ajgT/2o4E/9xPRT/cT0U/3E9FP9xPRT/n4Nt/9PT0//Qzs3/cT0U/3E9FP9xPRT/cT0U/3E9FP9xPRT/cT0U/3E9FP9xPRT/eEIW/3hCFv94Qhb/eEIW/6SIcP/X19f/1NLR/3hCFv94Qhb/eEIW/3hCFv94Qhb/eEIW/3hCFv94Qhb/eEIW/39HGP9/Rxj/f0cY/39HGP+qjHP/29vb/9jW1f9/Rxj/f0cY/39HGP9/Rxj/f0cY/39HGP9/Rxj/f0cY/39HGP+FTBn/hUwZ/4VMGf+FTBn/r5F1/9/f3//e3t3/yLqt/8a1p/+ng2T/hUwZ/4VMGf+FTBn/hUwZ/4VMGf+FTBn/jFEb/4xRG/+MURv/jFEb/7WVeP/j4+P/4+Pj/+Pj4//j4+P/4+Pj/76ljv+MURv/jFEb/4xRG/+MURv/jFEb/5NWHf+TVh3/k1Yd/5NWHf+6mnv/5+fn/+Xk4/+neU3/xa2W/+fn5//n5+f/onBB/5NWHf+TVh3/k1Yd/5NWHf+aWx7/mlse/5pbHv+aWx7/wJ5+/+vr6//o5uX/mlse/59kK//r6+v/6+vr/7uVcf+aWx7/mlse/5pbHv+aWx7/oWAg/6FgIP+hYCD/oWAg/8Wjgf/v7+//7evp/6FgIP+7j2T/7+/v/+/v7/+6jWL/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP/HpYL/8/Pz//Py8v/t6OP/8/Pz//Pz8//s5uH/p2sw/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/yaaE//f39//39/f/9/f3/+vh2P/WvKT/sXxI/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6drL/+veEH/r3hB/6ltM/+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6RmKfqhYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6RmKfqueEKEpGYp+qFgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6FgIP+hYCD/oWAg/6RmKfqueEKEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==
IMG;
	
	$path_public = $work . DIRECTORY_SEPARATOR . 'public' . DIRECTORY_SEPARATOR;
	write_binary($path_public .'favicon.ico', $favicon);
	$path_img = $path_public . 'images' . DIRECTORY_SEPARATOR;
	write_binary($path_img . 'pragwork.png', $pragwork);
	write_binary($path_img . 'pragwork_small.png', $pragwork_small);
}

function make_public($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'public' . DIRECTORY_SEPARATOR;
	write($path . '.htaccess', <<< HTACCESS
DirectorySlash Off

RewriteEngine On

RewriteRule ^$ index.html [QSA]
RewriteRule ^([^.]+)$ $1.html [QSA]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteRule ^(.*)$ index.php [QSA,L]

php_flag magic_quotes_gpc off
php_flag register_globals off
HTACCESS
	);
	write($path . 'robots.txt', <<< ROBOTS
# Uncomment these lines to disallow spiders read the site:
# User-Agent: *
# Disallow: /
ROBOTS
	);
	write($path . 'index.html', sprintf(<<< 'INDEX'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<style type="text/css" media="screen">
		article, footer, header {
			display: block;
		}

		body {
			width: 920px;
			font-size: 100%%;
			margin: 0 auto;
			font-family: Helvetica, Arial, sans-serif;
			color: #1a1a1a;
			line-height: 130%%;
		}

		p {
			font-size: 1em;
		}

		h1 {
			font-size: 2em;
			font-weight: bold;
			line-height: 1.5em;
		}

		h2 {
			font-size: 1.2em;
			font-weight: bold;
			line-height: 1.2em;
		}

		img {
			border: none;
		}

		small {
			font-size: 0.75em;
		}

		a:link {
			color: #2060a1;
			text-decoration: underline;
		}

		a:visited {
			color: #2060a1;
			text-decoration: none;
		}

		a:hover {
			color: #d40000;
			text-decoration: none;
		}

		header {
			height: 60px;
		}

		.pragwork-logo {
			margin-top: 15px;
			display: block;
			float: left;
		}

		.pragwork-small-logo {
			text-align: center;
		}

		.info {
			font-size: 0.75em;
			padding-top: 15px;
			padding-bottom: 5px;
		}

		article {
			clear: both;
		}

		footer {
			text-align: center;
			margin-top: 20px;
			border-top: 1px solid #2060a1;
		}
	</style>
	<title>Welcome to %s</title>
</head>
<body>
<header>
	<a href="http://pragwork.com"><img src="/images/pragwork.png" class="pragwork-logo" /></a>
</header>
<article>
<h1>Welcome to %s!</h1>
<h2>Pragwork works! Thank you for choosing Pragwork %s &mdash; the pragmatic PHP web framework</h2>

<p>Pragwork is a pragmatic web framework for PHP 5.3+ inspired by the ideas of <a href="http://rubyonrails.org">Ruby on Rails</a>. The framework supports <a href="http://en.wikipedia.org/wiki/Model-view-controller">MVC</a> and <a href="http://en.wikipedia.org/wiki/RESTful">RESTful</a> approaches. It uses the <a href="http://www.phpactiverecord.org">PHP ActiveRecord</a> library for <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">O/R mapping</a>. Pragwork has also the internal support for localization, testing (using <a href="https://github.com/jaz303/ztest">ZTest</a> library by Jason Frame), <a href="http://en.wikipedia.org/wiki/AJAX">AJAX</a>, <a href="http://michelf.com/projects/php-markdown">Markdown</a>, <a href="http://phpmailer.worxware.com">PHP Mailer</a>, and more. And all of that is slightly mixed with a rationale philosophy utilizing the best sides of PHP along with the common sense of making software.</p>

<p>Pragwork is the technology created by <a href="http://pragwork.com/en/about-author-and-contributors#szymon">Szymon Wrozynski</a> &mdash; a freelance software developer from Poland. Currently, Pragwork is free, open source software in continuous development, publicly available under the <a href="http://pragwork.com/en/license">MIT license</a>. Pragwork requires a web server (PHP 5.3, URL rewriting) and a database server.</p>

<p>For further information, FAQ, and tutorials please visit the Pragwork website at <a href="http://pragwork.com">http://pragwork.com</a>.</p>

<p>I hope you do enjoy pragworking!</p>

<p>Good luck with your projects!</p>

<p>Szymon Wrozynski</p>
</article>
<footer>
<div class="info">
	Pragwork %s &copy; 2009-2011 <a href="http://pragwork.com/en/about-author-and-contributors#szymon">Szymon Wrozynski</a><br />
<small>"Pragwork" and the Pragwork logo are trademarks of Szymon Wrozynski. All rights reserved</small>
</div>
<a href="http://pragwork.com"><img src="/images/pragwork_small.png" class="pragwork-small-logo" /></a>
</footer>
</body>
</html>
INDEX
		, ucwords(str_replace('_', ' ', $work)), ucwords(str_replace('_', ' ', $work)), PRAGWORK_VERSION, PRAGWORK_VERSION));
	
	write($path . 'index.php', sprintf(<<< 'INDEX'
<?php
# %s BOOTSTRAP
require '..%smodules%sapplication.php';
Application\start();
?>
INDEX
		, strtoupper($work), DIRECTORY_SEPARATOR, DIRECTORY_SEPARATOR));
	
	write($path . 'stylesheets' . DIRECTORY_SEPARATOR . 'scaffold.css', <<< SC
body {
	width: 920px;
	font-size: 100%;
	line-height: 130%;
	margin: 0 auto;
	font-family: Helvetica, Arial, sans-serif;
	color: #1a1a1a;
	padding-bottom: 50px;
}

article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary {
	display: block;
}

h1 {
	font-size: 2em;
	font-weight: bold;
	line-height: 1.5em;
}

h2 {
	font-size: 1.2em;
	font-weight: bold;
	line-height: 1.2em;
}

img {
	border: none;
}

small {
	font-size: 0.8em;
}

/* LINKS */

a:link {
	color: #2060a1;
	text-decoration: underline;
}

a:visited {
	color: #2060a1;
	text-decoration: none;
}

a:hover {
	color: #d40000;
	text-decoration: none;
}

/* TABLES */

table {
	border: 1px solid #1a1a1a;
	border-collapse: collapse;
}

td, th {
   border: 1px solid #1a1a1a;
   padding: 5px;
   vertical-align: middle;
   font-size: 0.9em;
}

th {
	color: white;
	font-weight: bold;
	background-color: #2060a1;
	text-align: left;
	padding-left: 20px;
	padding-right: 20px;
	padding-top: 10px;
}

.numeric {
	text-align: right;
}

.bool {
	text-align: center;
}

/* FORMS */

label {
	font-weight: bold;
	vertical-align: text-top;
}

form div {
	margin-top: 20px;
	margin-bottom: 30px;
}

div.field input {
	font-size: 0.9em;
	border: 1px solid #cecece;
	padding: 2px;
}

div.field textarea {
	padding: 2px;
	border: 1px solid #cecece;
	font-size: 1em;
}

div.actions input {
	font-size: 1em;
}

form p.error {
	margin-top: 0;
	margin-bottom: 0;
	font-size: 0.8em;
	line-height: 1.5em;
	font-weight: bold;
	color: #d40000;
}

/* MISC */

.notice {
	margin-top: 20px;
	padding-top: 10px;
	padding-bottom: 10px;
	background-color: #2060a1;
	text-align: center;
	color: white;
	font-size: 1em;
	font-weight: bold;
}

.button-to {
	display: inline;
}

.button-to input {
	font-size: 0.8em;
}
SC
	);
}

function make_errors($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR;
	write($path . '403.php', sprintf(<<< 'E403'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>403 Forbidden</title>
</head>
<body>
	<h1>Forbidden</h1>
	<p>You don't have permission to access <?php echo $_SERVER['REQUEST_URI'] ?> on this server.</p>
	<hr />
	<address>Pragwork %s <?php echo $_SERVER['SERVER_SOFTWARE'] ?> Server at <?php echo $_SERVER['SERVER_NAME'] ?> Port <?php echo $_SERVER['SERVER_PORT'] ?></address>
</body>
</html>
E403
		, PRAGWORK_VERSION));
	write($path . '404.php', sprintf(<<< 'E404'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>404 Not found</title>
</head>
<body>
	<h1>Not found</h1>
	<p>The requested URL <?php echo $_SERVER['REQUEST_URI'] ?> was not found on this server.</p>
	<hr />
	<address>Pragwork %s <?php echo $_SERVER['SERVER_SOFTWARE'] ?> Server at <?php echo $_SERVER['SERVER_NAME'] ?> Port <?php echo $_SERVER['SERVER_PORT'] ?></address>
</body>
</html>
E404
		, PRAGWORK_VERSION));
	
	write($path . '405.php', sprintf(<<< 'E405'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>405 Method Not Allowed</title>
</head>
<body>
	<h1>Method Not Allowed</h1>
	<p>The requested method <?php echo $_SERVER['REQUEST_METHOD'] ?> is not allowed for the URL <?php echo $_SERVER['REQUEST_URI'] ?>.</p>
	<hr />
	<address>Pragwork %s <?php echo $_SERVER['SERVER_SOFTWARE'] ?> Server at <?php echo $_SERVER['SERVER_NAME'] ?> Port <?php echo $_SERVER['SERVER_PORT'] ?></address>
</body>
</html>
E405
	, PRAGWORK_VERSION));
	
	write($path . '500.php', sprintf(<<< 'E500'
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>500 Internal server error</title>
</head>
<body>
	<h1>Internal server error</h1>
	<p>We are sorry but your request cannot be completed due to server errors. This incident has been logged and reported to the site administrator.</p>
	<p>Thank you for understanding.</p>
	<hr />
	<address>Pragwork %s <?php echo $_SERVER['SERVER_SOFTWARE'] ?> Server at <?php echo $_SERVER['SERVER_NAME'] ?> Port <?php echo $_SERVER['SERVER_PORT'] ?></address>
</body>
</html>
E500
		, PRAGWORK_VERSION));
}

function make_controllers($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR
		. 'Controllers' . DIRECTORY_SEPARATOR;
	write($path . 'ApplicationController.php', <<< 'AP'
<?php
namespace Controllers;
modules('tags');

abstract class ApplicationController extends \Application\Controller
{}
?>
AP
	);
}

function make_config($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR;
	write($path . 'routes.php', <<< 'ROUTES'
<?php
$ROUTES = array(
);
?>
ROUTES
	);
	write($path . 'application.php', <<< 'AR'
<?php
date_default_timezone_set('Europe/Warsaw');

Application\Configuration::initialize(function($config) 
{
	$config->environment = 'development';
});
?>
AR
	);

	write($path . 'activerecord.php', sprintf(<<< 'AR'
<?php
ActiveRecord\Configuration::initialize(function($config) 
{
	$config->connection = array(
		'development' => 'mysql://%s:secret@localhost/%s_development?charset=utf8',
		'test' => 'mysql://%s:secret@localhost/%s_test?charset=utf8',
		'production' => 'mysql://%s:secret@localhost/%s_production?charset=utf8'
	);
});
?>
AR
		, $work, $work, $work, $work, $work, $work));
}

function make_db($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'sql' . DIRECTORY_SEPARATOR;
	write($path . 'schema.sql', '');
	write($path . 'data.sql', '');
}

function make_helpers($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR 
		. 'helpers' . DIRECTORY_SEPARATOR . 'ApplicationHelper.php';
	write($path, '');
}

function make_modules($work)
{
	make_activerecord_module($work);
	make_application_module($work);
	make_image_module($work);
	make_mailer_module($work);
	make_paginate_module($work);
	make_tags_module($work);
	make_markdown_module($work);
	make_test_module($work);
}

function make_test_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR;
	write($path . 'test.php', sprintf(<<< 'TEST'
<?php
/**
 * Test Module 1.0 for Pragwork %s
 *
 * @copyright Copyright (c) 2009 Jason Frame (ztest), 
 *			  Szymon Wrozynski (the module and additions)
 * @license %s
 * @version %s
 * @package Activerecord
 */


TEST
		, PRAGWORK_VERSION, LICENSE, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'TEST'
// Assertions are written as normal functions and we use a static property on
// Test_Base to keep track of state. The reason: it's less to type. No one likes
// writing $this->assert() over and over.

function pass() 
{
	ensure(true);
}

function fail($msg='') 
{
	ensure(false, $msg);
}

/**
 * Assert
 * 
 * @param $v value to be checked for truthiness
 * @param $msg message to report on failure
 */
function ensure($v, $msg='') 
{
	if (!$v) 
	{
		Test\TestCase::$reporter->assert_fail();
		throw new Test\AssertionFailed($msg);
	} else {
		Test\TestCase::$reporter->assert_pass();
	}
}

function assert_each($iterable, $test, $msg='') 
{
	foreach ($iterable as $i) 
		ensure($test($i), $msg);
}

function assert_object($v, $msg='') 
{
	ensure(is_object($v), $msg ?: "'" . strval($v) . "' should be an object.");
}

function assert_array($v, $msg='') 
{
	ensure(is_array($v), $msg ?: "'" . strval($v) . "' should be an array.");
}

function assert_scalar($v, $msg='') 
{
	ensure(is_scalar($v), $msg ?: "'" . strval($v) . "' should be a scalar.");
}

function assert_not_equal($l, $r, $msg='') 
{
	ensure($l != $r, $msg ?: 'Values should not be equal.');
}

function assert_equal($l, $r, $msg='') 
{
	ensure($l == $r, $msg ?: "Values should be equal (expected '" . strval($l) . "' but was '" . strval($r) . "').");
}

function assert_identical($l, $r, $msg='') 
{
	ensure($l === $r, $msg ?: "Values should be identical (expected '" . strval($l) . "' but was '" . strval($r)."')."); 
}

function assert_equal_strings($l, $r, $msg='') 
{
	ensure(strcmp($l, $r) === 0, $msg ?: "Dtrings should be equal (expected '$l' but was '$r').");	
}

function assert_match($regex, $r, $msg='') 
{
	ensure(preg_match($regex, $r), $msg ?: "'$r' does not match the pattern '$r'.");	
}

function assert_null($v, $msg='') 
{
	ensure($v === null, $msg ?: "Value should be null (was '".strval($v)."').");
}

function assert_not_null($v, $msg='') 
{
	ensure($v !== null, $msg ?: 'Value should not be null.');
}

// NOTE: this assertion swallows all exceptions
function assert_throws($exception_class, $lambda, $msg='') 
{
	try 
	{
		$lambda();
		fail($msg ?: "Expected $exception_class but nothing was thrown.");
	} 
	catch (Exception $e) 
	{
		if (is_a($e, $exception_class))
			pass();
		else
			fail($msg ?: "Expected $exception_class but was " . get_class($e) . '.');
	}
}

/**
 * Wraps the common pattern of having a map of input => expected output that you
 * wish to check against some function.
 * 
 * @param $data_array map of input value => expected output
 * @param $lambda each input value will be passed to this function and compared
 *		  against expected output.
 */
function assert_output($data_array, $lambda) 
{
	foreach ($data_array as $input => $expected_output)
		assert_equal($expected_output, $lambda($input));
}

/**
 * This one's a bit dubious - it tests that an assertion made by the supplied
 * lambda fails. It primarily exists for self-testing the ztest library, and
 * using it causes the displayed assertion stats to be incorrect.
 */
function assert_fails($lambda, $msg='') 
{
	$caught = false;
	try 
	{
		$lambda();
	} 
	catch (Test\AssertionFailed $e) 
	{
		$caught = true;
		pass();
	}
	if (!$caught) 
	{
		throw new Test\AssertionFailed($msg ?: 'The assertion should fails.');
	}
}

## Assertions for controller testing (Szymon Wrozynski)

function assert_status($status, $msg='')
{
	$r = Test\TestResponse::instance();
	
	if (!$r)
		throw new \ErrorException('No response yet.');
	
	$expected = Test\TestResponse::resolve_full_status($status);
	$was = $r->full_status();
	ensure($was === $expected, $msg ?: "Expected status $expected but was: $was.");
}

function assert_redirected_to($options, $msg='')
{
	$r = Test\TestResponse::instance();
	
	if (!$r)
		throw new \ErrorException('No response yet.');
	
	$url = url_for($options);
	ensure($r->location === $url, $msg ?: "Expected a redirection to $url but was: $r->location.");
}

function assert_content_type($expected, $msg='')
{
	$r = Test\TestResponse::instance();
	
	if (!$r)
		throw new \ErrorException('No response yet.');
	
	ensure($r->content_type == $expected, 
		$msg ?: "Expected the rendered content type to be $expected but was: $r->content_type.");
}

function assert_template($expected, $msg='')
{
	$r = Test\TestResponse::instance();
	
	if (!$r)
		throw new \ErrorException('No response yet.');
	
	ensure($r->template == $expected, $msg ?: "Expected the rendered template to be $expected but was: $r->template.");
}

function assert_layout($expected, $msg='')
{
	$r = Test\TestResponse::instance();
	
	if (!$r)
		throw new \ErrorException('No response yet.');
	
	ensure($r->layout == $expected, $msg ?: "Expected the rendered layout to be $expected but was: $r->layout.");
}

spl_autoload_register(function($class)
{
	if (strpos($class, 'Test\\') === 0)
		require MODULES . str_replace('\\', DIRECTORY_SEPARATOR, $class).'.php';
	elseif (strpos($class, 'Application\\') === 0)
	{
		$file = MODULES . 'Test' . DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
		if (is_file($file))
			require $file;
	}
}, true, true);
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	$path .= 'Test';
	
	if (is_dir($path))
		rmtree($path);
	
	mkdir($path, 0755);
	
	$path .= DIRECTORY_SEPARATOR;

	write($path . 'TestRequest.php', _strip_phpdoc(<<< 'TR'
<?php
namespace Test;
use Application\Controller;

class TestRequest extends \Application\Request
{	 
	private $_ip;
	private $_method;
	private $_ssl;
	
	protected function __construct($uri, $m, $ssl, $ip, $route, $pp, $qp, $rp) 
	{
		parent::__construct($uri);
		$this->_method = $m;
		$this->_ssl = $ssl;
		$this->_ip = $ip;
		$this->route = $route;
		$this->path_parameters = $pp;
		$this->query_parameters = $qp;
		$this->request_parameters = $rp;
	}
	
	/**
	 * Sets the test environment and creates a new request or returns 
	 * the existing one.
	 *
	 * The following options are available:
	 *
	 * <ul>
	 * <li><b>locale</b>: the locale code used in the simulated request</li>
	 * <li><b>path_params</b>: the parameters passed via the path
	 * <li><b>query_params</b>: the parmeters passed as the query string</li>
	 * <li><b>request_params</b>: the parameters passed through the request
	 *	   body</li>
	 * <li><b>session</b>: the array used in the {@link Session}</li>
	 * <li><b>cookies</b>: the array used in the {@link Cookies}</li>
	 * <li><b>method</b>: the request method (GET, POST, PUT, DELETE)</li>
	 * <li><b>ip</b>: the client ip (default 127.0.0.1)</li>
	 * </ul>
	 *
	 * @param string $action The action name or null if the request exists
	 * @param array $options Options
	 * @return TestRequest The TestRequest instance
	 */
	public static function &instance($action=null, $options=array())
	{
		if (!static::$instance && $action)
		{
			global $ROUTES, $LOCALE;
			
			$c = Controller::instance();
			
			if (!method_exists($c, $action))
				throw new \ErrorException("The action '$action' of controller " . substr(get_class($c), 12, -10) 
					. " does not exists.");
			
			$r = $ROUTES[$ROUTES['__RC'][substr(get_class($c), 12, -10)][$action]];
			$locale = isset($options['locale']) ? $options['locale'] : null;

			$config = \Application\Configuration::instance();
			$localization = $config->localization;
			
			if ($localization === true)
			{
				if ($locale)
					require LOCALES . $locale . '.php';
				elseif ($r[0] !== '/')
					throw new \ErrorException('Locale required.');
			}
			elseif ($localization)
				require LOCALES . $localization . '.php';		
		
			$_COOKIE = isset($options['cookies']) ? $options['cookies'] : array();
			$_SESSION = isset($options['session']) ? $options['session'] : array();
		
			$rp = isset($options['request_params']) ? $options['request_params'] : array();
			$qp = isset($options['query_params']) ? $options['query_params'] : array();
		
			$pp = isset($options['path_params']) ? $options['path_params'] : array();
		
			$ssl = isset($r['ssl']) ? $r['ssl'] : false;
			$_SERVER['SERVER_PORT'] = $ssl ? $config->ssl_port : $config->http_port;

			$available_methods = explode(' ', $r['methods']);

			if (isset($options['method']))
			{
				if (in_array($options['method'], $available_methods))
					$m = $options['method'];
				else
					throw new \ErrorException('The HTTP method ' . $options['method'] 
						. " is not allowed for the action '$action'.");
			}
			else
				$m = $available_methods[0];
			
			$_SERVER['REQUEST_METHOD'] = $m;
			
			$ip = isset($options['ip']) ? $options['ip'] : '127.0.0.1';
			
			$c->request = new \stdClass; # a fake request (required by url_for)
			$c->request->path_parameters =& $pp;
			$c->request->route =& $r;
			
			$uri = substr(url_for(array('params' => ($pp + $qp) ?: null)), 
				strlen($ssl ? $config->ssl_url() : $config->http_url()));
			
			static::$instance = new TestRequest($uri, $m, $ssl, $ip, $r, $pp, $qp, $rp);
		}
		return static::$instance;
	}
	
	public function remote_ip()
	{
		return $this->_ip;
	}
	
	public function method()
	{
		return $this->_method;
	}

	public function is_ssl()
	{
		return $this->_ssl;
	}

	public function is_get()
	{
		return $this->_method === 'GET';
	}

	public function is_post()
	{
		return $this->_method === 'POST';
	}

	public function is_put()
	{
		return $this->_method === 'PUT';
	}

	public function is_delete()
	{
		return $this->_method === 'DELETE';
	}
}
?>
TR
		), $GLOBALS['STRIP_PHPDOC']);

	write($path . 'ControllerTestCase.php',	 _strip_phpdoc(<<< 'TR'
<?php
namespace Test;

/**
 * Functional test class for controller testing.
 * 
 * @package Test
 * @author Szymon Wrozynski
 */
class ControllerTestCase extends UnitTestCase
{
	/**
	 * The controller instance extended with special testing methods. 
	 * This instance is created anew before each test. The controller class
	 * is guessed after the test class name.
	 *
	 * @var \Application\Controller
	 */
	protected $controller;
	
	protected function do_run_one(TestInvoker $tmi) 
	{
		$controller = substr($this->get_name(), 0, -4);
		$this->controller = $controller::instance();
		try 
		{
			parent::do_run_one($tmi);
		} 
		catch (\Exception $e) 
		{
			$this->controller->clean_up();
			throw $e;
		}
		$this->controller->clean_up();
		$this->controller = null;
	}
	
	/**
	 * Sets the test environment and perform an action. It creates a new request, passes it to the
	 * {@link process()} method of the {@link Application\Controller} class and returns the
	 * {@link TestResponse} object.
	 *
	 * The following options are available:
	 *
	 * <ul>
	 * <li><b>locale</b>: the locale code used in the simulated request</li>
	 * <li><b>path_params</b>: the parameters passed via the path
	 * <li><b>query_params</b>: the parmeters passed as the query string</li>
	 * <li><b>request_params</b>: the parameters passed through the request 
	 *	   body</li>
	 * <li><b>session</b>: the array used in the {@link Session}</li>
	 * <li><b>cookies</b>: the array used in the {@link Cookies}</li>
	 * <li><b>method</b>: the request method (GET, POST, PUT, DELETE)</li>
	 * <li><b>ip</b>: the client ip (default 127.0.0.1)</li>
	 * </ul>
	 *
	 * @param string $action The action name
	 * @param array $options Options
	 * @return TestResponse The response object
	 */
	public function action($action, $options=array())
	{
		$request = TestRequest::instance($action, $options);
		$response = TestResponse::instance(true);
		$this->controller->process($request, $response);
		$response->render();
		return $response;
	}
}
?>
TR
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Storage.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

/**
 * Simulates the disk storage for example to simulate caching operations of the 
 * {@link Application\Controller} in the test environment. It might be used in other
 * mock objects as well.
 *
 * @author Szymon Wrozynski
 * @package Test
 */
class Storage
{
	private $_storages = array(array());
	
	/**
	 * Adds a location to the storage.
	 *
	 * @params string $path The location path e.g. TEMP
	 */
	public function add_location($path)
	{
		if (is_string($path))
			$path = rtrim($path, DIRECTORY_SEPARATOR);
		
		if (!isset($this->_storages[$path]))
			$this->_storages[$path] = array();
	}
	
	/**
	 * Returns the reference to an array simulating the storage. If the <code>$path</code> is 
	 * omitted the array simulating the current working directory is returned.
	 *
	 * @param string $path The path
	 * @return array
	 */
	public function &get_location($path=0)
	{
		if (is_string($path))
			$path = rtrim($path, DIRECTORY_SEPARATOR);
		
		if (isset($this->_storages[$path]))
			return $this->_storages[$path];
	}
	
	private final function get_storage_and_relative_path($path)
	{
		foreach ($this->_storages as $p => &$s)
		{
			if (is_string($p) && (strpos($path, $p) === 0))
				return array(&$s, trim(substr($path, strlen($p)), DIRECTORY_SEPARATOR));
		}
		return array(&$this->_storages[0], trim($path, DIRECTORY_SEPARATOR));
	}
	
	/**
	 * Sets a content a the last path node. It might be a string (representing a file) or an array
	 * (a directory structure).
	 *
	 * @param string $path The full path
	 * @param mixed $content The array with the directory structure or a string
	 */
	public function set_content($path, $content)
	{
		$storage_and_path = $this->get_storage_and_relative_path($path);
		$handle =& $storage_and_path[0];
		$path = $storage_and_path[1];
		$path_parts = explode(DIRECTORY_SEPARATOR, $path);
		
		foreach ($path_parts as $i => $part)
		{
			if (!isset($path_parts[$i + 1])) # if last
				$handle[$part] = $content;
			elseif (is_array($handle) && isset($handle[$part]) && is_array($handle[$part]))
				$handle =& $handle[$part];
			else
				throw new \ErrorException("Wrong path: $path");
		}
	}
	
	/**
	 * Returns the reference to the concrete node of the storage structure.
	 *
	 * @param string $path The path to the node
	 * @return mixed The node reference
	 */
	public function &get_handle($path)
	{
		$storage_and_path = $this->get_storage_and_relative_path($path);
		$handle =& $storage_and_path[0];
		$path = $storage_and_path[1];

		foreach (explode(DIRECTORY_SEPARATOR, $path) as $part)
		{
			if (is_array($handle))
			{
				if (isset($handle[$part]))
					$handle =& $handle[$part];
				else
				{
					unset($handle);
					$handle = null;
					break;
				}
			}
			else
				break;
		}
		return $handle;
	}
	
	/**
	 * Removes the whole structure node. Simulates the <code>unlink()</code> and recursive
	 * <code>rmdir()</code> functions.
	 *
	 * @param string $path The path
	 */
	public function unlink($path)
	{
		$handle =& $this->get_handle($path);
		
		if ($handle !== null)
			$handle = null;
	}
	
	/**
	 * Checks if a node exists.
	 *
	 * @param string $path The path
	 * @return bool True if exists, false otherwise
	 */
	public function file_exists($path)
	{
		return $this->get_handle($path) !== null;
	}
	
	/**
	 * Simulates the <code>file_put_contents()</code> function.
	 *
	 * @param string $path Path to the node
	 * @param string $text Content
	 */
	public function file_put_contents($path, $text)
	{
		if (!$this->is_dir($path))
			$this->set_content($path, $text);
	}
	
	/**
	 * Simulates the <code>file_put_contents()</code> function.
	 *
	 * @param string $path Path to the node
	 * @return string The content of the node (it has to be a file)
	 */
	public final function file_get_contents($path)
	{
		if ($this->is_file($path))
			return $this->get_handle($path);
	}
	
	/**
	 * Simulates a <code>scandir()</code> function but it does not return '.' and '..' entries.
	 *
	 * @param string $path Path to the node
	 * @param string $sorting_order 0 for the ascending alphabetical order, non 0 for descending
	 * @return array The array of entries
	 */
	public final function scandir($path, $sorting_order=0)
	{
		if ($this->is_dir($path))
		{
			$result = array_keys($this->get_handle($path));
			
			if ($sorting_order === 0)
				sort($result);
			else
				rsort($result);
			
			return $result;
		}
	}
	
	/**
	 * Simulates the <code>is_file()</code> function.
	 *
	 * @param string $path Path to the node
	 * @return bool True if the node exists and it is a file
	 */
	public final function is_file($path)
	{
		$handle = $this->get_handle($path);
		return $handle !== null && !is_array($path);
	}
	
	/**
	 * Simulates the <code>is_dir()</code> function.
	 *
	 * @param string $path Path to the node
	 * @return bool True if the node exists and it is a directory
	 */
	public final function is_dir($path)
	{
		$handle = $this->get_handle($path);
		return $handle !== null && is_array($path);
	}
	
	/**
	 * Simulates the <code>mkdir()</code> function in the recursive mode.
	 *
	 * @param string $path Path containing nodes.
	 */
	public final function mkdir($path)
	{
		$storage_and_path = $this->get_storage_and_relative_path($path);
		$handle =& $storage_and_path[0];
		$path = $storage_and_path[1];

		foreach (explode(DIRECTORY_SEPARATOR, $path) as $part)
		{
			if (isset($handle[$part]) && !is_array($handle[$part]))
				throw new \ErrorException("$part is a file, not a directory.");
			else
				$handle[$part] = array();
				
			$handle =& $handle[$part];
		}
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'TestResponse.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

/**
 * Class encapsulating the controller's response details prepared on performing functional tests.
 * 
 * @package Test
 * @author Szymon Wrozynski
 */
class TestResponse extends \Application\Response
{	
	/**
	 * The template name used in the response (if any).
	 *
	 * @var mixed String or null
	 */
	public $template;
	
	/**
	 * The layout name used in the response (if any).
	 *
	 * @var mixed String or null
	 */
	public $layout;
	
	/**
	 * The storage simulating the 'temp' and 'public' directories while performing and action.
	 *
	 * @see Storage
	 * @var Storage
	 */
	public $storage;
	
	protected function __construct()
	{
		$this->storage = new Storage;
		$this->storage->add_location(TEMP);
	}
	
	/**
	 * Returns the TestResponse instance.
	 *
	 * @param bool $create If true and there is no response yet, the new instance will be created
	 * @return TestResponse
	 */
	public static function &instance($create=false)
	{
		if (!static::$instance && $create)
			static::$instance = new TestResponse;
		
		return static::$instance;
	}
	
	/**
	 * Destroys the TestResponse instance.
	 */
	public function clean_up()
	{
		static::$instance = null;
	}
	
	public function remove_header($name)
	{
		foreach ($this->headers as &$h)
		{
			if ($name === substr($h, 0, strpos($h, ':')))
				unset($h);
		}
	}
	
	public function headers_list()
	{
		return $this->headers;
	}
	
	public function render()
	{
		if ((string) $this->status === $this->status)
			$this->status = self::$http_codes_by_symbols[$this->status];
		
		if (($this->status > 300) && ($this->status < 400))
		{
			$this->add_header("Location: $this->location");
			return;
		}
		elseif (($this->status >= 400) && ($this->status < 500) && !$this->body)
		{
			$file = APPLICATION . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR . $this->status . '.php';
			
			if (is_file($file))
			{
				ob_start();
				require $file;
				$this->body = ob_get_clean();
			}
		}
		elseif ($this->status >= 500)
			$this->body = $this->error_500();
		
		$ctype = "Content-Type: $this->content_type";
		
		if ($this->charset)
			$ctype .= "; charset=$this->charset";
		
		$this->add_header($ctype);
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'UnitTestCase.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

/**
 * Base unit test class
 * 
 * @package Test
 * @author Jason Frame
 */
class UnitTestCase extends TestCase
{
	/**
	 * Called before every test case
	 */
	protected function setup() {}
	
	/**
	 * Called after every test case
	 */
	protected function teardown() {}
	
	protected function do_run_one(TestInvoker $tmi) 
	{
		$this->setup();
		$tmi->invoke($this);
		$this->teardown();
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'TestSuite.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class TestSuite
{
	private $name;
	private $tests	= array();
	
	public function __construct($name) 
	{
		$this->name = $name;	
	}
	
	public function require_all($dir, $extensions=array('php')) 
	{
		$ext_match = '/\.(' . implode('|', $extensions) . ')$/'; 
		$dir = APPLICATION . DIRECTORY_SEPARATOR . 'test' . DIRECTORY_SEPARATOR . $dir;
		$stack = array($dir);
		while (count($stack)) 
		{
			$dir = array_pop($stack);
			$dh = opendir($dir);
			while (($file = readdir($dh)) !== false) 
			{
				if ($file[0] == '.') 
					continue;
				
				$fqd = $dir . DIRECTORY_SEPARATOR . $file;
				
				if (is_dir($fqd)) 
					$stack[] = $fqd;
				elseif (preg_match($ext_match, $fqd)) 
					require_once $fqd;
			}
			closedir($dh);
		}
	}
	
	public function auto_fill() 
	{
		$test_case = new \ReflectionClass('Test\\TestCase');
		foreach (get_declared_classes() as $class_name) 
		{
			$r = new \ReflectionClass($class_name);
			
			if ($r->isSubclassOf($test_case) && !$r->isInterface() && !$r->isAbstract()) 
				$this->add_test(new $class_name);	
		}
	}
	
	public function add_test(TestCase $test) 
	{
		$this->tests[] = $test;
	}
	
	public function run(Reporter $reporter=null) 
	{
		if (!$reporter)
			$reporter = new ConsoleReporter;
		
		if (!$this->tests)
			$this->auto_fill();
		
		$reporter->start();
		
		foreach ($this->tests as $test) 
			$test->run($reporter);
		
		$reporter->end();
		$reporter->summary();
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'TestCase.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

abstract class TestCase
{
	public static $reporter = null;
	
	public function get_name()
	{
		return get_class($this);
	}
		
	public function run(Reporter $reporter) 
	{
		self::$reporter = $reporter;
		
		foreach ($this->get_test_invokers() as $ti)
			$this->run_one($ti);	
		
		self::$reporter = null;
	}
	
	protected function run_one(TestInvoker $ti) 
	{
		self::$reporter->test_enter($ti);
		
		try 
		{
			$this->do_run_one($ti);
			self::$reporter->test_pass();
		} 
		catch (AssertionFailed $eaf) 
		{
			self::$reporter->test_fail($eaf);
		} 
		catch (\Exception $e) 
		{
			self::$reporter->test_error($e);
		}
		
		self::$reporter->test_exit($ti);
	}
	
	/**
	 * Returns an array of Test_Invoker instances which, combined, will run all
	 * tests declared by this test class. The default behaviour is to return
	 * a collection of Test_MethodInvoker for all public methods prefixed by
	 * 'test_'
	 */
	protected function get_test_invokers() 
	{
		$reflector = new \ReflectionClass($this);
		$all = array();
		foreach ($reflector->getMethods() as $method) 
		{
			if ($method->isPublic() && preg_match('/^test_/', $method->getName()))
				$all[] = new MethodInvoker($method);
		}
		return $all;
	}
	
	protected abstract function do_run_one(TestInvoker $ti);
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'TestInvoker.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

/**
 * TestInvoker instances know how to run a single test on a given TestCase.
 */
abstract class TestInvoker
{
	public abstract function invoke(TestCase $instance);
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'MethodInvoker.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

/**
 * MethodInvoker runs a single test by invoking a method on the TestCase
 */
class MethodInvoker extends TestInvoker
{
	private $method;
	
	public function __construct(\ReflectionMethod $method) 
	{
		$this->method = $method;	
	}
	
	public function invoke(TestCase $instance) 
	{
		$this->method->invoke($instance);
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Reporter.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

abstract class Reporter
{
	protected $incidents = array();
	
	protected $start_time;
	protected $exec_time;
	
	protected $test_total = 0;
	protected $test_passes = 0;
	protected $test_failures = 0;
	protected $test_errors = 0;
	
	protected $assert_total = 0;
	protected $assert_passes = 0;
	protected $assert_failures = 0;
	
	public function start() 
	{
		$this->start_time = microtime(true);	
	}
	
	public function end() 
	{
		$this->exec_time = microtime(true) - $this->start_time;
	}
	
	public function test_enter(TestInvoker $invoker) 
	{
		$this->test_total++;
		$this->report_test_enter($invoker);
	}
	
	public function test_exit(TestInvoker $invoker) 
	{
		$this->report_test_exit($invoker);	
	}
	
	public function test_pass() 
	{
		$this->test_passes++;
		$this->report_test_pass();
	}
	
	public function test_fail(AssertionFailed $eaf) 
	{
		$this->incidents[] = $eaf;
		$this->test_failures++;
		$this->report_test_fail($eaf);
	}
	
	public function test_error(\Exception $e) 
	{
		$this->incidents[] = $e;
		$this->test_errors++;
		$this->report_test_error($e);
	}
	
	public function assert_pass() 
	{
		$this->assert_total++;
		$this->assert_passes++;
		$this->report_assert_pass();
	}
	
	public function assert_fail() 
	{
		$this->assert_total++;
		$this->assert_failures++;
		$this->report_assert_fail();
	}
	
	public function summary() 
	{
		$this->report_summary();	
	}
	
	protected function report_test_enter(TestInvoker $invoker) {}
	protected function report_test_exit(TestInvoker $invoker) {}

	protected function report_test_pass() {}
	protected function report_test_fail(AssertionFailed $eaf) {}
	protected function report_test_error(\Exception $e) {}
	
	protected function report_assert_pass() {}
	protected function report_assert_fail() {}
	
	protected function report_summary() {}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Mock.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class Mock
{
	private static $id;
	
	public static function generate($class_name = null) 
	{
		if ($class_name === null) 
		{
			$id = self::$id++;
			$class_name = "__GeneratedMock{$id}__";
		}
		
		return new MockSpecification($class_name);
	}
	
	public static function method_matches_pattern($method, $pattern) 
	{
		// TODO: support wildcards
		return strcmp($method, $pattern) === 0;
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'MockSpecification.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class MockSpecification
{
	private static $specs = array();
	
	public static function lookup($instance, $pattern = null) 
	{
		$out = self::$specs[get_class($instance)];
		if ($pattern) 
			$out = $out->methods[$pattern];
		return $out;
	}
	
	private $class_name;
	private $superclass	= null;
	private $interfaces	= array();
	private $methods = array();
	
	private $written = false;
	
	public function __construct($class_name) 
	{
		$this->class_name = $class_name;
		self::$specs[$this->class_name] = $this;
	}
	
	public function get_class_name() 
	{
		return $this->class_name;
	}
	
	public function extend($superclass) 
	{
		$this->superclass = $superclass;
		return $this;
	}
	
	public function implement($interface) 
	{
		$this->interfaces[] = $interface;
		return $this;
	}
	
	public function receives($method_pattern) 
	{
		$mock_method = new MockMethodSpecification($this, $method_pattern);
		$this->methods[$method_pattern] = $mock_method;
		return $mock_method;
	}
	
	public function write() 
	{
		if (!$this->written) 
		{
			eval($this->to_php());
			$this->written = true;
		}
	}
	
	public function construct() 
	{
		$this->write();
		return new $this->class_name;
	}
	
	public function to_php() 
	{
		
		$php = "class {$this->class_name}";
		
		if ($this->superclass)
			$php .= " extends {$this->superclass}";
		
		if (count($this->interfaces))
			$php .= ' implements ' . implode(', ', $this->interfaces);
		
		$php .= " {\n";
		
		//
		// Setup __call() hook to receive all expected methods and throw
		// AssertionFailed on receiving other methods.
		
		$php .= "	 private \$memory = array();\n";
		
		$patterns = array();
		foreach ($this->methods as $m) $patterns[] = $m->get_pattern();
		
		$php .= "	 private \$method_patterns = " . var_export($patterns, true) . ";\n";
		
		$php .= "	 public function __call(\$method, \$args) {\n";
		$php .= "		 foreach (\$this->method_patterns as \$pattern) {\n";
		$php .= "			 if (Mock::method_matches_pattern(\$method, \$pattern)) {\n";
		$php .= "				 \$this->memory[] = array(\$method, \$args);\n";
		$php .= "				 if (\$closure = MockSpecification::lookup(\$this, \$pattern)->get_closure()) {\n";
		$php .= "					 return call_user_func_array(\$closure, \$args);\n";
		$php .= "				 } else {\n";
		$php .= "					 return;\n";
		$php .= "				 }\n";
		$php .= "			 }\n";
		$php .= "		 }\n";
		$php .= "		 throw new Test\\AssertionFailed(\"Unexpected method '\$method' called\");\n";
		$php .= "	 }\n";
		
		//
		// Now implement any interfaces
		
		$iface_methods = array();
		
		foreach ($this->interfaces as $iface) 
		{
			$reflection = new ReflectionClass($iface);
			foreach ($reflection->getMethods() as $method) 
			{
				$args = array();
				foreach ($method->getParameters() as $param) 
				{
					$arg = '';
					
					if ($param->isArray())
						$arg .= 'array ';
					elseif ($pclass = $param->getClass())
						$arg .= $pclass->getName() . ' ';
					
					if ($param->isPassedByReference())
						$arg .= '&';
					
					$arg .= '$' . $param->getName();
					
					if ($param->allowsNull())
						$arg .= ' = null';
					elseif ($param->isOptional())
						$arg .= ' = ' . var_export($param->getDefaultValue(), true);
					
					$args[] = $arg;
				}
				$arg_list = implode(', ', $args);
				$php .= "	 public function {$method->getName()}($arg_list) {\n";
				$php .= "		 return \$this->__call('{$method->getName()}', func_get_args());\n";
				$php .= "	 }\n";
			}
		}
		
		$php .= "}\n";
		
		return $php;
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'MockMethodSpecification.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class MockMethodSpecification
{
	private $mock;
	private $pattern;
	private $closure;
	
	public function __construct(MockSpecification $mock, $pattern) 
	{
		$this->mock = $mock;
		$this->pattern = $pattern;
	}
	
	public function get_pattern() 
	{
		return $this->pattern;
	}
	
	public function get_closure() 
	{
		return $this->closure;
	}
	
	public function returning($thing) 
	{
		if ($thing instanceof Closure)
			$this->closure = $thing;
		
		return $this;
	}
	
	public function back() 
	{
		return $this->mock;
	}
	
	public function __call($method, $args) 
	{
		return call_user_func_array(array($this->mock, $method), $args);
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'AssertionFailed.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class AssertionFailed extends \Exception {}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'ConsoleReporter.php', _strip_phpdoc(<<< 'TEST'
<?php
namespace Test;

class ConsoleReporter extends Reporter
{
	private static $colors = array(
		'red' => "\033[31m",
		'green' => "\033[32m",
		'blue' => "\033[34m",
		'yellow' => "\033[33m",
		'default' => "\033[0m"
	);
	
	private $use_color = USE_COLOR;
	
	public function enable_color() 
	{
		$this->use_color = true;
	}
	
	protected function report_test_pass() 
	{
		echo $this->wrap('.', 'green');
	}
	
	protected function report_test_fail(AssertionFailed $eaf) 
	{
		echo $this->wrap('F', 'red');
	}
	
	protected function report_test_error(\Exception $e) 
	{
		echo $this->wrap('E', 'red');	
	}
	
	protected function print_small_trace($e)
	{
		$app_path_cut_point = strlen(realpath(APPLICATION)) + 1;
		$trace = $e->getTrace();
		$i = 1;
		
		foreach ($trace as $entry)
		{
			# ignore if the entry neither has 'file' nor 'line' keys
			if (!isset($entry['file'], $entry['line']))
				continue;
			
			if (strrpos($entry['file'], DIRECTORY_SEPARATOR . 'prag') 
				=== strlen($entry['file']) - strlen(DIRECTORY_SEPARATOR . 'prag'))
				continue;
			
			$file = substr($entry['file'], $app_path_cut_point);
				
			# omit the modules
			if (strpos($file, 'modules') === 0)
				continue;
				
			echo "$i. $file:", $entry['line'], ' - ';
					
			if (isset($entry['class']) && $entry['class'])
				echo 'method: ', $entry['class'], $entry['type'];
			else
				echo 'function: ';
					
			echo $entry['function'], '(', implode(', ', array_map(function($a) {
				if (($a === null) || ((bool) $a === $a))
					return gettype($a);
				elseif ((object) $a === $a)
					return get_class($a);
				elseif ((string) $a === $a)
					return "'$a'";
				else
					return strval($a);
			}, $entry['args'])), ')';
			echo "\n";
			$i++;
		}
	}
	
	protected function report_summary() 
	{
		echo "\n";
		
		foreach ($this->incidents as $e) 
		{
			echo "\n";
			$message = $e->getMessage() ? $e->getMessage() : '(no message)';
			
			if ($e instanceof AssertionFailed) 
				echo "Failure: $message\n";
			else 
			{
				$class = get_class($e);
				echo "Error: $class {$message}\n";
			}
			
			$this->print_small_trace($e);
		}
		
		echo "\nSummary: ";
		
		echo $this->wrap_by_success("{$this->test_passes}/{$this->test_total} tests passed",
			$this->test_passes,	$this->test_total);
		echo ", ";
		echo $this->wrap_by_success("{$this->assert_passes}/{$this->assert_total} assertions",
			$this->assert_passes, $this->assert_total);
		
		echo sprintf("\n%fs\n", $this->exec_time);
	}
	
	private function wrap($string, $color) 
	{
		return $this->use_color ? self::$colors[$color] . $string . self::$colors['default'] : $string;
	}
	
	private function wrap_by_success($string, $success, $total) 
	{
		return $this->wrap($string, $success == $total ? 'green' : 'yellow');
	}
}
?>
TEST
	), $GLOBALS['STRIP_PHPDOC']);
	
	
	$path .= 'Application';
	
	if (is_dir($path))
		rmtree($path);
	
	mkdir($path, 0755);
	
	$path .= DIRECTORY_SEPARATOR;
	
	write($path . 'Singleton.php', sprintf(<<< 'AP'
<?php
namespace Application;

abstract class Singleton
{	
	protected function __construct() {}

	public static function &instance()
	{
		if (!static::$instance)
		{
			$class = get_called_class();
			static::$instance = new $class;
		}

		return static::$instance;
	}
	
	private final function __clone() {}
	
	/**
	 * Destroys the instance.
	 */
	public function clean_up()
	{
		static::$instance = null;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Session.php', sprintf(<<< 'AP'
<?php
namespace Application;

class Session extends Store
{
	protected static $instance;

	protected function __construct()
	{
		parent::__construct($_SESSION);
	}

	public function kill()
	{
		$_SESSION = array();
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Controller.php', sprintf(<<< 'AP'
<?php
namespace Application;

abstract class Controller extends Singleton
{
	static $layout = null;	 
	static $before_filter = null;
	static $before_render_filter = null;
	static $after_filter = null;
	static $exception_filter = null;
	static $caches_page = null;
	static $caches_action = null;
	
	public $params;
	public $session;
	public $cookies;
	public $flash;
	public $request;
	public $response;
	public $action;
	public $controller;
	
	protected static $instance;
	
	private static $_content;
	private static $_ch_file;
	private static $_ch_dir;
	private static $_ch_layout;
	private static $_ch_if;
	private static $_rendered;
	private static $_ssl_url;
	private static $_http_url;
	private static $_cache;
	
	protected function __construct()
	{
		$class = get_class($this);
		do 
		{
			require HELPERS . str_replace('\\', DIRECTORY_SEPARATOR, substr($class, 12, -10)) . 'Helper.php';
		}
		while (($class = get_parent_class($class)) !== __CLASS__);
	}
	
	/**
	 * Resets all data of the current instance of the controller. It is handled
	 * automatically by the test environment.
	 */
	public final function clean_up()
	{
		self::$_content = null;
		self::$_ch_file = null;
		self::$_ch_dir = null;
		self::$_ch_layout = null;
		self::$_ch_if = null;
		self::$_rendered = null;
		self::$_http_url = null;
		self::$_ssl_url = null;
		self::$_cache = null;
		
		$_SERVER['SERVER_PORT'] = 80;
		
		if ($this->params)
			$this->params->clean_up();
			
		if ($this->session)
			$this->session->clean_up();
		
		if ($this->flash)
			$this->flash->clean_up();
		
		if ($this->cookies)
			$this->cookies->clean_up();
		
		if ($this->request)
			$this->request->clean_up();
		
		if ($this->response)
			$this->response->clean_up();
		
		static::$instance = null;
		$_SESSION = array();
		$_COOKIE = array();
	}
	
	public function process($request, $response)
	{
		$this->action = $action = $request->route['action'];
		$this->controller = $request->route['controller'];
		$config = Configuration::instance();
		
		self::$_ssl_url = $config->ssl_url();
		self::$_http_url = $config->http_url();
		self::$_cache = $config->cache;
		
		$this->request = $request;
		$this->response = $response;
		$this->params = Parameters::instance();
		$this->session = Session::instance();
		$this->flash = Flash::instance();
		$this->cookies = Cookies::instance();

		try
		{
			$this->invoke_filters('before_filter');
			
			if (self::$_cache)
			{
				if (static::$caches_action)
					$this->set_action_cache($request->uri());
				
				if (static::$caches_page)
					$this->set_page_cache($request->uri());
			}	
			
			ob_start();
			
			$this->$action();

			if (!self::$_rendered)
				$this->render();
			
			$this->response->body = ob_get_clean();
			
			$this->invoke_filters('after_filter');
		}
		catch (StopException $e)
		{
			$this->response->body = ob_get_clean();
		}
		catch (\Exception $e) 
		{
			if ($this->invoke_filters('exception_filter', $e) !== false)
			{
				$this->response->body = ob_get_clean();
				$this->response->status = 500;
				$this->response->exception = $e;
				throw $e;
			}
		}
	}
	
	public function default_url_options() {}
	
	public function expire_page($options=array())
	{
		$key = url_for($options);
		$qpos = strpos($key, '?');
		$start = strlen(($key[4] === 's') ? self::$_ssl_url : self::$_http_url);
		$key = ($qpos === false) 
			? trim(substr($key, $start), '/.')
			: trim(substr($key, $start, $qpos - $start), '/.');
		
		if (isset($key[0]))
		{
			$cached_page = str_replace('/', DIRECTORY_SEPARATOR, $key);
			if (substr($key, -5) !== '.html')
				$cached_page .= '.html';
		}
		else
			$cached_page = 'index.html';
		
		if ($this->response->storage->is_file($cached_page))
		{
			$this->response->storage->unlink($cached_page);
		
			while (($dir = dirname($cached_page)) !== '.')
			{
				$handle =& $this->response->storage->get_handle($dir);
				if (!empty($handle))
					break;
					
				$handle = null;
				$cached_page = $dir;
			}
		}
	}
	
	public function expire_action($options=array())
	{
		$key = url_for($options);
		$key = substr($key, strlen(($key[4] === 's') ? self::$_ssl_url : self::$_http_url));
		
		# if longer than 1 char (e.g. longer than '/')
		if (isset($key[1])) 
			$key = rtrim($key, '/.');
			
		$cached_dir = TEMP . 'ca_' . md5($key);
		
		if ($this->response->storage->is_dir($cached_dir))
			$this->response->storage->unlink($cached_dir);

		$cached_action = $cached_dir . '.cache';

		if ($this->response->storage->is_file($cached_action))
			$this->response->storage->storage->unlink($cached_action);
	}
	
	public function fragment_exists($options=array())
	{
		return $this->response->storage->is_file(self::fragment_file($options));
	}
	
	public function expire_fragment($options=array())
	{
		$fragment = self::fragment_file($options);
		if ($this->response->storage->is_file($fragment))
			$this->response->storage->unlink($fragment);
	}
	
	public function cache($options, $closure)
	{
		if (!self::$_cache)
			return $closure($this);
		
		$frag = self::fragment_file($options);
		
		if ($this->response->storage->is_file($frag))
			echo $this->response->storage->file_get_contents($frag);
		
		ob_start();
		$closure($this);
		$output = ob_get_clean();
		$this->response->storage->file_put_contents($frag, $output);
		echo $output;
	}
	
	private static final function fragment_file($options)
	{
		$key = url_for($options);
		$key = substr($key,strlen(($key[4]==='s') ? self::$_ssl_url : self::$_http_url));   
		
		if (isset($options['action_suffix']))
			$key .= $options['action_suffix'];
		
		return TEMP . 'cf_' . md5($key) . '.cache';
	}
	
	private final function render_cache_in_layout()
	{
		if ($this->response->storage->is_dir(self::$_ch_dir))
		{
			foreach($this->response->storage->scandir(self::$_ch_dir) as $f)
			{
				self::$_content[$f] = $this->response->storage->file_get_contents(
					self::$_ch_dir . DIRECTORY_SEPARATOR . $file);
			}
		}
		
		$this->render(array(
			'text' => $this->response->storage->file_get_contents(self::$_ch_file),
			'layout' => true
		));
		
		throw new StopException;
	}
	
	private final function set_action_cache($key)
	{
		if (self::$_ch_file)
			return;
		
		foreach (self::normalize_defs(static::$caches_action) as $ch)
		{
			if ($ch[0] !== $this->action)
				continue;
			
			if (isset($ch['cache_path']))
			{
				if ($ch['cache_path'][0] === '/')
					self::$_ch_dir = TEMP . 'ca_' . md5($ch['cache_path']);
				else
				{
					$chp = $this->$ch['cache_path']();
						
					if ($chp[0] === '/')
						self::$_ch_dir = TEMP . 'ca_' . md5($chp);
					elseif ($chp[4] === 's')
						self::$_ch_dir = TEMP . 'ca_' . md5(substr($chp, strlen(self::$_ssl_url)));
					else
						self::$_ch_dir = TEMP . 'ca_' . md5(substr($chp, strlen(self::$_http_url)));
				}
			}
			else
				self::$_ch_dir = TEMP . 'ca_' . md5(isset($key[1]) ? rtrim($key, '/.') : $key);

			self::$_ch_file = self::$_ch_dir . '.cache';
			
			if (isset($ch['layout']) && !$ch['layout'])
			{ 
				if ($this->response->storage->is_file(self::$_ch_file))
					$this->render_cache_in_layout();
				
				self::$_ch_layout = self::resolve_layout($this->action);
				static::$layout = null;
			}
			elseif ($this->response->storage->is_file(self::$_ch_file))
			{
				echo $this->response->storage->file_get_contents(self::$_ch_file);
				throw new StopException;
			}
			
			if (isset($ch['if']))
				self::$_ch_if = $ch['if'];
			   
			self::add_to_filter('after_filter', 'write_and_show_cache');
			break;
		}
	}
	
	private final function set_page_cache($key)
	{
		if (self::$_ch_file)
			return;
		
		foreach (self::normalize_defs(static::$caches_page) as $ch)
		{	
			if ($ch[0] !== $this->action)
				continue;
						
			$key = trim($key, '/.');
				
			if (isset($key[0]))
			{
				self::$_ch_file = str_replace('/', DIRECTORY_SEPARATOR, $key);
									
				if (!strpos($key, '.'))
					self::$_ch_file .= '.html';
			}
			else
				self::$_ch_file = 'index.html';
			
			if (isset($ch['if']))
				self::$_ch_if = $ch['if'];
			
			self::add_to_filter('after_filter', 'write_and_show_cache');
			break;
		}
	}
	
	private final function write_and_show_cache()
	{
		if (self::$_ch_if)
		{
			if ((array) self::$_ch_if === self::$_ch_if)
			{
				foreach (self::$_ch_if as $ifm)
				{
					if (!$this->$ifm())
						return;
				}
			}
			else
			{
				$ifm = self::$_ch_if;
				if (!$this->$ifm())
					return;
			}
		}
		
		if (!self::$_ch_dir) # if caches page
		{
			$dir = dirname(self::$_ch_file);
				
			if (!$this->response->storage->is_dir($dir))
				$this->response->storage->mkdir($dir);
		}
		
		$this->response->storage->file_put_contents(self::$_ch_file, $this->response->body);
		
		if (self::$_ch_layout)
		{
			if (self::$_content)
			{
				if ($this->response->storage->is_dir(self::$_ch_dir))
				{
					foreach ($this->response->storage->scandir(self::$_ch_dir) as $f)
						$this->response->storage->unlink(self::$_ch_dir . DIRECTORY_SEPARATOR . $f);
				}
				else
					$this->response->storage->mkdir(self::$_ch_dir);
				
				foreach (self::$_content as $r => $c)
					$this->response->storage->file_put_contents(self::$_ch_dir . DIRECTORY_SEPARATOR . $r, $c);	   
			}
			
			ob_start();
			$this->render(array('text' => $this->response->body, 'layout' => self::$_ch_layout));
			$this->response->body = ob_get_clean();
		}
	}
	
	public function redirect_to($options=array())
	{
		if ((array) $options !== $options)
			$this->redirect_to_url(url_for($options));
		elseif (!$this->session)
			$this->redirect_to_url(url_for($options), $options);
		
		$url = url_for($options);
		
		unset(
			$options['params'], 
			$options[0],
			$options['name'],
			$options['ssl'], 
			$options['anchor'],
			$options['locale'],
			$options['action'], 
			$options['controller']
		);
		
		$this->redirect_to_url($url, $options);
	}
	
	public function redirect_to_url($url, $options=array())
	{
		if (isset($options['status']))
		{
			$this->response->status = $options['status'];
			unset($options['status']);
		}
		else 
			$this->response->status = 302;
		
		if ($this->flash)
		{
			foreach ($options as $name => $msg)
				$this->flash->$name = $msg;
		}
		
		$this->response->location = $url;
		throw new StopException;
	} 
	
	public function render($options=array())
	{	
		if ((array) $options !== $options)
		{
			$template = VIEWS . ((strpos($options, '\\') === false)
				? str_replace('\\', DIRECTORY_SEPARATOR, $this->controller) . DIRECTORY_SEPARATOR . $options
				: str_replace('\\', DIRECTORY_SEPARATOR, $options));
			
			$partial = $template . '.part.php';
			
			if (is_file($partial))
			{
				ob_start();
				require $partial;
				return ob_get_clean();
			}
			
			if (!self::$_rendered)
			{
				$this->invoke_filters('before_render_filter');
				self::$_rendered = true;
			}
			
			$this->response->template = str_replace(DIRECTORY_SEPARATOR, '\\', substr($template, strlen(VIEWS)));
			
			$layout = self::resolve_layout($this->action);
			
			if ($layout)
			{
				$this->response->layout = $layout;
				ob_start();
				require $template . '.php';
				self::$_content[0] = ob_get_clean();
				require VIEWS . 'layouts' . DIRECTORY_SEPARATOR . str_replace('\\',DIRECTORY_SEPARATOR,$layout) .'.php';
			}
			else
				require $template . '.php';
			return;
		}
		elseif (isset($options[0]))
		{
			$template = VIEWS . ((strpos($options[0], '\\') === false)
				? str_replace('\\', DIRECTORY_SEPARATOR, $this->controller) . DIRECTORY_SEPARATOR . $options[0]
				: str_replace('\\', DIRECTORY_SEPARATOR, $options[0]));
			
			$partial = $template . '.part.php';
			
			if (is_file($partial))
			{
				unset($options[0]);
				ob_start();
			
				if (isset($options['collection']))
				{
					$name = basename($partial, '.part.php');		
					$key_name = $name . '_key';
				
					foreach ($options['collection'] as $key => $item)
					{
						$this->render_partial(
							$partial,
							array($name => $item, $key_name => $key) + $options
						);
					}
				}
				else
					$this->render_partial($partial, $options);
			
				return ob_get_clean();
			}
		}
		elseif (isset($options['xml']))
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'application/xml';
			
			$options['text'] = $xml;
		}
		elseif (isset($options['json']))
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'application/json';
			
			$options['text'] = isset($options['json_options'])
				? json_encode($options['json'], $options['json_options'])
				: json_encode($options['json']);
		}
		elseif (!isset($options['text']))	 
			$template = VIEWS . str_replace('\\', DIRECTORY_SEPARATOR,
				isset($options['controller']) ? $options['controller'] : $this->controller) 
				. DIRECTORY_SEPARATOR . (isset($options['action']) ? $options['action'] : $this->action);
		
		if (isset($options['status']))
			$this->response->status = $options['status'];
		
		if (isset($options['text']))
		{
			if (isset($options['content_type']))
				$this->response->content_type = $options['content_type'];
				
			if (!self::$_rendered)
			{
				$this->invoke_filters('before_render_filter');
				self::$_rendered = true;
			}
						
			if (isset($options['layout']))
			{
				if ($options['layout'] === true)
					$options['layout'] = self::resolve_layout($this->action);
				
				$this->response->layout = $options['layout'];
				
				self::$_content[0] = $options['text'];
				require VIEWS . 'layouts' . DIRECTORY_SEPARATOR
					. str_replace('\\', DIRECTORY_SEPARATOR, $options['layout']) . '.php';
			}
			else
				echo $options['text'];
			
			return;
		}
		
		if (!isset($options[0]) && !isset($options['action']) && !isset($options['controller'])
			&& $this->response->status_code() >= 400)
		{
			if (isset($options['content_type']))
				$this->response->content_type = $options['content_type'];
			
			throw new StopException;
		}
		
		if (isset($options['format']) && $options['format'] === 'xml')
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'text/xml';
			
			if (!isset($options['layout']))
				$options['layout'] = false;
		}
		elseif (!isset($options['layout']))
			$options['layout'] = self::resolve_layout($this->action);
		
		if (isset($options['content_type']))
			$this->response->content_type = $options['content_type'];
		
		if (!self::$_rendered)
		{
			$this->invoke_filters('before_render_filter');
			self::$_rendered = true;
		}
		
		$this->response->template = str_replace(DIRECTORY_SEPARATOR, '\\', substr($template, strlen(VIEWS)));
		
		if ($options['layout'])
		{
			$this->response->layout = $options['layout'];
			ob_start();
			require $template . '.php';
			self::$_content[0] = ob_get_clean();
			require VIEWS . 'layouts' . DIRECTORY_SEPARATOR 
				. str_replace('\\', DIRECTORY_SEPARATOR, $options['layout']) . '.php';
		}
		else
			require $template . '.php';
	}
	
	public function render_to_string($options=array())
	{
		ob_start();
		
		if (self::$_rendered)
			$str = $this->render($options);
		else
		{
			self::$_rendered = true;
			$str = $this->render($options);
			self::$_rendered = false;
		}
		
		return ob_get_clean() ?: $str;
	}
	
	private function render_partial($___path___, $___args___)
	{	
		foreach ($___args___ as $___n___ => $___v___) 
			$$___n___ = $___v___;
		
		require $___path___;
	}
	
	public function yield($region=0)
	{
		if (isset(self::$_content[$region]))
			return self::$_content[$region];
	}
	
	public function content_for($region, $closure)
	{
		ob_start();
		$closure($this);
		self::$_content[$region] = ob_get_clean();
	}
	
	private static final function resolve_layout($action)
	{
		if (!static::$layout)
			return;
		
		static $layout;
		
		if (!isset($layout))
		{
			$layout = null;
			
			foreach (self::normalize_defs(static::$layout) as $l)
			{
				if (isset($l['only']))
				{
					if ((((array) $l['only'] === $l['only']) && in_array($action, $l['only'], true))
						|| ($l['only'] === $action))
					{
						$layout = $l[0];
						break;
					}
					continue;
				}
				elseif (isset($l['except']) && ((((array) $l['except'] === $l['except']) 
					&& in_array($action, $l['except'], true)) || ($l['except'] === $action)))
					continue;
				
				$layout = $l[0];
				break;
			}
		}
		
		return $layout;
	}
	
	private static final function get_filter_mods(&$entry)
	{
		$modifiers = array();
		if (isset($entry['only']))
		{
			$modifiers['only'] = ((array) $entry['only'] === $entry['only'])
				? $entry['only'] : array($entry['only']);
			unset($entry['only']);
		}
		if (isset($entry['except']))
		{
			$modifiers['except'] = ((array) $entry['except'] === $entry['except'])
				? $entry['except'] : array($entry['except']);
			unset($entry['except']);
		}
		if (isset($entry['exception']))
		{
			$modifiers['exception'] = $entry['exception'];
			unset($entry['exception']);
		}
		return $modifiers;
	}
	
	private static final function normalize_defs($definitions)
	{	
		if ((array) $definitions !== $definitions)
			return array(array($definitions));

		$normalized_definitions = array();
		$outer_options = array();

		foreach ($definitions as $key => $body)
		{	
			if ((string) $key === $key)
				$outer_options[$key] = $body;
			elseif ((array) $body === $body)
			{	 
				$inner_options = array();

				foreach ($body as $k => $v)
				{
					if ((string) $k === $k)
					{
						$inner_options[$k] = $v;
						unset($body[$k]);
					}
				}

				foreach ($body as $b)
					$normalized_definitions[] = array($b) + $inner_options;
			}
			else
				$normalized_definitions[] = array($body);						 
		}

		if ($outer_options)
		{
			foreach ($normalized_definitions as &$nd)
				$nd += $outer_options;
		}

		return $normalized_definitions;
	}
	
	private static final function add_to_filter($filter, $method)
	{
		if (!static::$$filter)
			static::$$filter = $method;
		elseif ((array) static::$$filter === static::$$filter)
		{
			if (array_key_exists('except', static::$$filter) || array_key_exists('only', static::$$filter))
				static::$$filter = self::normalize_defs(static::$$filter);
			
			array_push(static::$$filter, $method);
		}
		else
			static::$$filter = array(static::$$filter, $method);
	}
	
	private final function invoke_filters($filter, $value=null)
	{	
		$filter_chain = array();
		
		$class = get_class($this);
		do 
		{
			$class_filters = $class::$$filter;
			
			if (!$class_filters)
				continue;
				
			if ((array) $class_filters !== $class_filters)
			{
				if (!isset($filter_chain[$class_filters]))
					$filter_chain[$class_filters] = null;
			}
			else
			{
				$class_mods = self::get_filter_mods($class_filters);
			
				foreach (array_reverse($class_filters) as $entry)
				{
					if ((array) $entry !== $entry)
					{
						if (!isset($filter_chain[$entry]))
							$filter_chain[$entry] = $class_mods;
					}
					else
					{
						$mods = self::get_filter_mods($entry);
					
						foreach (array_reverse($entry) as $e)
						{
							if (!isset($filter_chain[$e]))
								$filter_chain[$e] = $mods ?: $class_mods;
						}
					}
				}
			}
		} while (($class = get_parent_class($class)) !== __CLASS__);
		
		foreach (array_reverse($filter_chain) as $flt => $mods)
		{
			if (isset($mods['only']) && !in_array($this->action, $mods['only']))
				continue;
			elseif (isset($mods['except']) && in_array($this->action, $mods['except']))
				continue;
			elseif (isset($mods['exception']) && !($value && is_a($value, $mods['exception'])))
				continue;

			if ($this->$flt($value) === false)
				return false;
		}
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_markdown_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR . 'markdown.php';
	write($path, sprintf(<<< 'MD'
<?php
/**
 * Markdown Module 1.1 for Pragwork %s
 *
 * @copyright Copyright (c) 2004-2009 Michel Fortin (PHP Markdown),
 *			  Copyright (c) 2004-2006 John Gruber (Original Markdown),
 *			  %s (Module)
 * @license Licensed under the BSD License
 * @version %s
 * @package Markdown
 */

#
# Markdown  -  A text-to-HTML conversion tool for web writers
#
# PHP Markdown
# Copyright (c) 2004-2009 Michel Fortin  
# <http://michelf.com/projects/php-markdown/>
#
# Original Markdown
# Copyright (c) 2004-2006 John Gruber  
# <http://daringfireball.net/projects/markdown/>
#
# Code updates to PHP 5.3.3 and Pragwork standards 
# by (c) 2010-2011 Szymon Wrozynski
#


MD
		, PRAGWORK_VERSION, AUTHOR, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'MD'
namespace 
{

define( 'MARKDOWN_VERSION',  "1.0.1n" ); # Sat 10 Oct 2009


#
# Global default settings:
#

# Change to ">" for HTML output
@define( 'MARKDOWN_EMPTY_ELEMENT_SUFFIX',  " />");

# Define the width of a tab for code blocks.
@define( 'MARKDOWN_TAB_WIDTH',     4 );


/**
 * Standard Function Interface.
 * Initialize the parser and return the result of its transform method.
 */
function markdown($text) 
{
	static $parser;
	if (!isset($parser))
		$parser = new Markdown\MarkdownParser;
	return $parser->transform($text);
}

}

namespace Markdown
{
	
/**
 * Markdown Parser Class
 *
 */
class MarkdownParser 
{

	# Regex to match balanced [brackets].
	# Needed to insert a maximum bracked depth while converting to PHP.
	protected $nested_brackets_depth = 6;
	protected $nested_brackets_re;
	
	protected $nested_url_parenthesis_depth = 4;
	protected $nested_url_parenthesis_re;

	# Table of hash values for escaped characters:
	protected $escape_chars = '\`*_{}[]()>#+-.!';
	protected $escape_chars_re;

	# Change to ">" for HTML output.
	protected $empty_element_suffix = MARKDOWN_EMPTY_ELEMENT_SUFFIX;
	protected $tab_width = MARKDOWN_TAB_WIDTH;
	
	# Change to `true` to disallow markup or entities.
	protected $no_markup = false;
	protected $no_entities = false;
	
	# Predefined urls and titles for reference links and images.
	protected $predef_urls = array();
	protected $predef_titles = array();


	public function __construct() {
	#
	# Constructor function. Initialize appropriate member variables.
	#
		$this->_initDetab();
		$this->prepareItalicsAndBold();
	
		$this->nested_brackets_re = 
			str_repeat('(?>[^\[\]]+|\[', $this->nested_brackets_depth).
			str_repeat('\])*', $this->nested_brackets_depth);
	
		$this->nested_url_parenthesis_re = 
			str_repeat('(?>[^()\s]+|\(', $this->nested_url_parenthesis_depth).
			str_repeat('(?>\)))*', $this->nested_url_parenthesis_depth);
		
		$this->escape_chars_re = '['.preg_quote($this->escape_chars).']';
		
		# Sort document, block, and span gamut in ascendent priority order.
		asort($this->document_gamut);
		asort($this->block_gamut);
		asort($this->span_gamut);
	}


	# Internal hashes used during transformation.
	protected $urls = array();
	protected $titles = array();
	protected $html_hashes = array();
	
	# Status flag to avoid invalid nesting.
	protected $in_anchor = false;
	
	
	protected function setup() {
	#
	# Called before the transformation process starts to setup parser 
	# states.
	#
		# Clear global hashes.
		$this->urls = $this->predef_urls;
		$this->titles = $this->predef_titles;
		$this->html_hashes = array();
		
		$in_anchor = false;
	}
	
	protected function teardown() {
	#
	# Called after the transformation process to clear any variable 
	# which may be taking up memory unnecessarly.
	#
		$this->urls = array();
		$this->titles = array();
		$this->html_hashes = array();
	}

	
	/**
	 * Main function. Performs some preprocessing on the input text
	 * and pass it through the document gamut.
	 */
	public function transform($text) 
	{

		$this->setup();
	
		# Remove UTF-8 BOM and marker character in input, if present.
		$text = preg_replace('{^\xEF\xBB\xBF|\x1A}', '', $text);

		# Standardize line endings:
		#   DOS to Unix and Mac to Unix
		$text = preg_replace('{\r\n?}', "\n", $text);

		# Make sure $text ends with a couple of newlines:
		$text .= "\n\n";

		# Convert all tabs to spaces.
		$text = $this->detab($text);

		# Turn block-level HTML blocks into hash entries
		$text = $this->hashHTMLBlocks($text);

		# Strip any lines consisting only of spaces and tabs.
		# This makes subsequent regexen easier to write, because we can
		# match consecutive blank lines with /\n+/ instead of something
		# contorted like /[ ]*\n+/ .
		$text = preg_replace('/^[ ]+$/m', '', $text);

		# Run document gamut methods.
		foreach ($this->document_gamut as $method => $priority) {
			$text = $this->$method($text);
		}
		
		$this->teardown();

		return $text . "\n";
	}
	
	protected $document_gamut = array(
		# Strip link definitions, store in hashes.
		"stripLinkDefinitions" => 20,
		
		"runBasicBlockGamut"   => 30,
		);


	protected function stripLinkDefinitions($text) {
	#
	# Strips link definitions from text, stores the URLs and titles in
	# hash references.
	#
		$less_than_tab = $this->tab_width - 1;

		# Link defs are in the form: ^[id]: url "optional title"
		$text = preg_replace_callback('{
							^[ ]{0,'.$less_than_tab.'}\[(.+)\][ ]?:	# id = $1
							  [ ]*
							  \n?				# maybe *one* newline
							  [ ]*
							(?:
							  <(.+?)>			# url = $2
							|
							  (\S+?)			# url = $3
							)
							  [ ]*
							  \n?				# maybe one newline
							  [ ]*
							(?:
								(?<=\s)			# lookbehind for whitespace
								["(]
								(.*?)			# title = $4
								[")]
								[ ]*
							)?	# title is optional
							(?:\n+|\Z)
			}xm',
			array(&$this, '_stripLinkDefinitions_callback'),
			$text);
		return $text;
	}
	protected function _stripLinkDefinitions_callback($matches) {
		$link_id = strtolower($matches[1]);
		$url = $matches[2] == '' ? $matches[3] : $matches[2];
		$this->urls[$link_id] = $url;
		$this->titles[$link_id] =& $matches[4];
		return ''; # String that will replace the block
	}


	protected function hashHTMLBlocks($text) {
		if ($this->no_markup)  return $text;

		$less_than_tab = $this->tab_width - 1;

		# Hashify HTML blocks:
		# We only want to do this for block-level HTML tags, such as headers,
		# lists, and tables. That's because we still want to wrap <p>s around
		# "paragraphs" that are wrapped in non-block-level tags, such as anchors,
		# phrase emphasis, and spans. The list of tags we're looking for is
		# hard-coded:
		#
		# *  List "a" is made of tags which can be both inline or block-level.
		#    These will be treated block-level when the start tag is alone on 
		#    its line, otherwise they're not matched here and will be taken as 
		#    inline later.
		# *  List "b" is made of tags which are always block-level;
		#
		$block_tags_a_re = 'ins|del';
		$block_tags_b_re = 'p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|address|'.
						   'script|noscript|form|fieldset|iframe|math';

		# Regular expression for the content of a block tag.
		$nested_tags_level = 4;
		$attr = '
			(?>				# optional tag attributes
			  \s			# starts with whitespace
			  (?>
				[^>"/]+		# text outside quotes
			  |
				/+(?!>)		# slash not followed by ">"
			  |
				"[^"]*"		# text inside double quotes (tolerate ">")
			  |
				\'[^\']*\'	# text inside single quotes (tolerate ">")
			  )*
			)?	
			';
		$content =
			str_repeat('
				(?>
				  [^<]+			# content without tag
				|
				  <\2			# nested opening tag
					'.$attr.'	# attributes
					(?>
					  />
					|
					  >', $nested_tags_level).	# end of opening tag
					  '.*?'.					# last level nested tag content
			str_repeat('
					  </\2\s*>	# closing nested tag
					)
				  |				
					<(?!/\2\s*>	# other tags with a different name
				  )
				)*',
				$nested_tags_level);
		$content2 = str_replace('\2', '\3', $content);

		# First, look for nested blocks, e.g.:
		# 	<div>
		# 		<div>
		# 		tags for inner block must be indented.
		# 		</div>
		# 	</div>
		#
		# The outermost tags must start at the left margin for this to match, and
		# the inner nested divs must be indented.
		# We need to do this before the next, more liberal match, because the next
		# match will start at the first `<div>` and stop at the first `</div>`.
		$text = preg_replace_callback('{(?>
			(?>
				(?<=\n\n)		# Starting after a blank line
				|				# or
				\A\n?			# the beginning of the doc
			)
			(						# save in $1

			  # Match from `\n<tag>` to `</tag>\n`, handling nested tags 
			  # in between.
					
						[ ]{0,'.$less_than_tab.'}
						<('.$block_tags_b_re.')# start tag = $2
						'.$attr.'>			# attributes followed by > and \n
						'.$content.'		# content, support nesting
						</\2>				# the matching end tag
						[ ]*				# trailing spaces/tabs
						(?=\n+|\Z)	# followed by a newline or end of document

			| # Special version for tags of group a.

						[ ]{0,'.$less_than_tab.'}
						<('.$block_tags_a_re.')# start tag = $3
						'.$attr.'>[ ]*\n	# attributes followed by >
						'.$content2.'		# content, support nesting
						</\3>				# the matching end tag
						[ ]*				# trailing spaces/tabs
						(?=\n+|\Z)	# followed by a newline or end of document
					
			| # Special case just for <hr />. It was easier to make a special 
			  # case than to make the other regex more complicated.
			
						[ ]{0,'.$less_than_tab.'}
						<(hr)				# start tag = $2
						'.$attr.'			# attributes
						/?>					# the matching end tag
						[ ]*
						(?=\n{2,}|\Z)		# followed by a blank line or end of document
			
			| # Special case for standalone HTML comments:
			
					[ ]{0,'.$less_than_tab.'}
					(?s:
						<!-- .*? -->
					)
					[ ]*
					(?=\n{2,}|\Z)		# followed by a blank line or end of document
			
			| # PHP and ASP-style processor instructions (<? and <%)
			
					[ ]{0,'.$less_than_tab.'}
					(?s:
						<([?%])			# $2
						.*?
						\2>
					)
					[ ]*
					(?=\n{2,}|\Z)		# followed by a blank line or end of document
					
			)
			)}Sxmi',
			array(&$this, '_hashHTMLBlocks_callback'),
			$text);

		return $text;
	}
	protected function _hashHTMLBlocks_callback($matches) {
		$text = $matches[1];
		$key  = $this->hashBlock($text);
		return "\n\n$key\n\n";
	}
	
	
	protected function hashPart($text, $boundary = 'X') {
	#
	# Called whenever a tag must be hashed when a function insert an atomic 
	# element in the text stream. Passing $text to through this function gives
	# a unique text-token which will be reverted back when calling unhash.
	#
	# The $boundary argument specify what character should be used to surround
	# the token. By convension, "B" is used for block elements that needs not
	# to be wrapped into paragraph tags at the end, ":" is used for elements
	# that are word separators and "X" is used in the general case.
	#
		# Swap back any tag hash found in $text so we do not have to `unhash`
		# multiple times at the end.
		$text = $this->unhash($text);
		
		# Then hash the block.
		static $i = 0;
		$key = "$boundary\x1A" . ++$i . $boundary;
		$this->html_hashes[$key] = $text;
		return $key; # String that will replace the tag.
	}


	protected function hashBlock($text) {
	#
	# Shortcut function for hashPart with block-level boundaries.
	#
		return $this->hashPart($text, 'B');
	}


	protected $block_gamut = array(
	#
	# These are all the transformations that form block-level
	# tags like paragraphs, headers, and list items.
	#
		"doHeaders"         => 10,
		"doHorizontalRules" => 20,
		
		"doLists"           => 40,
		"doCodeBlocks"      => 50,
		"doBlockQuotes"     => 60,
		);

	protected function runBlockGamut($text) {
	#
	# Run block gamut tranformations.
	#
		# We need to escape raw HTML in Markdown source before doing anything 
		# else. This need to be done for each block, and not only at the 
		# begining in the Markdown function since hashed blocks can be part of
		# list items and could have been indented. Indented blocks would have 
		# been seen as a code block in a previous pass of hashHTMLBlocks.
		$text = $this->hashHTMLBlocks($text);
		
		return $this->runBasicBlockGamut($text);
	}
	
	protected function runBasicBlockGamut($text) {
	#
	# Run block gamut tranformations, without hashing HTML blocks. This is 
	# useful when HTML blocks are known to be already hashed, like in the first
	# whole-document pass.
	#
		foreach ($this->block_gamut as $method => $priority) {
			$text = $this->$method($text);
		}
		
		# Finally form paragraph and restore hashed blocks.
		$text = $this->formParagraphs($text);

		return $text;
	}
	
	
	protected function doHorizontalRules($text) {
		# Do Horizontal Rules:
		return preg_replace(
			'{
				^[ ]{0,3}	# Leading space
				([-*_])		# $1: First marker
				(?>			# Repeated marker group
					[ ]{0,2}	# Zero, one, or two spaces.
					\1			# Marker character
				){2,}		# Group repeated at least twice
				[ ]*		# Tailing spaces
				$			# End of line.
			}mx',
			"\n".$this->hashBlock("<hr$this->empty_element_suffix")."\n", 
			$text);
	}


	protected $span_gamut = array(
	#
	# These are all the transformations that occur *within* block-level
	# tags like paragraphs, headers, and list items.
	#
		# Process character escapes, code spans, and inline HTML
		# in one shot.
		"parseSpan"           => -30,

		# Process anchor and image tags. Images must come first,
		# because ![foo][f] looks like an anchor.
		"doImages"            =>  10,
		"doAnchors"           =>  20,
		
		# Make links out of things like `<http://example.com/>`
		# Must come after doAnchors, because you can use < and >
		# delimiters in inline links like [this](<url>).
		"doAutoLinks"         =>  30,
		"encodeAmpsAndAngles" =>  40,

		"doItalicsAndBold"    =>  50,
		"doHardBreaks"        =>  60,
		);

	protected function runSpanGamut($text) {
	#
	# Run span gamut tranformations.
	#
		foreach ($this->span_gamut as $method => $priority) {
			$text = $this->$method($text);
		}

		return $text;
	}
	
	
	protected function doHardBreaks($text) {
		# Do hard breaks:
		return preg_replace_callback('/ {2,}\n/', 
			array(&$this, '_doHardBreaks_callback'), $text);
	}
	protected function _doHardBreaks_callback($matches) {
		return $this->hashPart("<br$this->empty_element_suffix\n");
	}


	protected function doAnchors($text) {
	#
	# Turn Markdown link shortcuts into XHTML <a> tags.
	#
		if ($this->in_anchor) return $text;
		$this->in_anchor = true;
		
		#
		# First, handle reference-style links: [link text] [id]
		#
		$text = preg_replace_callback('{
			(					# wrap whole match in $1
			  \[
				('.$this->nested_brackets_re.')	# link text = $2
			  \]

			  [ ]?				# one optional space
			  (?:\n[ ]*)?		# one optional newline followed by spaces

			  \[
				(.*?)		# id = $3
			  \]
			)
			}xs',
			array(&$this, '_doAnchors_reference_callback'), $text);

		#
		# Next, inline-style links: [link text](url "optional title")
		#
		$text = preg_replace_callback('{
			(				# wrap whole match in $1
			  \[
				('.$this->nested_brackets_re.')	# link text = $2
			  \]
			  \(			# literal paren
				[ \n]*
				(?:
					<(.+?)>	# href = $3
				|
					('.$this->nested_url_parenthesis_re.')	# href = $4
				)
				[ \n]*
				(			# $5
				  ([\'"])	# quote char = $6
				  (.*?)		# Title = $7
				  \6		# matching quote
				  [ \n]*	# ignore any spaces/tabs between closing quote and )
				)?			# title is optional
			  \)
			)
			}xs',
			array(&$this, '_doAnchors_inline_callback'), $text);

		#
		# Last, handle reference-style shortcuts: [link text]
		# These must come last in case you've also got [link text][1]
		# or [link text](/foo)
		#
		$text = preg_replace_callback('{
			(					# wrap whole match in $1
			  \[
				([^\[\]]+)		# link text = $2; can\'t contain [ or ]
			  \]
			)
			}xs',
			array(&$this, '_doAnchors_reference_callback'), $text);

		$this->in_anchor = false;
		return $text;
	}
	protected function _doAnchors_reference_callback($matches) {
		$whole_match =  $matches[1];
		$link_text   =  $matches[2];
		$link_id     =& $matches[3];

		if ($link_id == "") {
			# for shortcut links like [this][] or [this].
			$link_id = $link_text;
		}
		
		# lower-case and turn embedded newlines into spaces
		$link_id = strtolower($link_id);
		$link_id = preg_replace('{[ ]?\n}', ' ', $link_id);

		if (isset($this->urls[$link_id])) {
			$url = $this->urls[$link_id];
			$url = $this->encodeAttribute($url);
			
			$result = "<a href=\"$url\"";
			if ( isset( $this->titles[$link_id] ) ) {
				$title = $this->titles[$link_id];
				$title = $this->encodeAttribute($title);
				$result .=  " title=\"$title\"";
			}
		
			$link_text = $this->runSpanGamut($link_text);
			$result .= ">$link_text</a>";
			$result = $this->hashPart($result);
		}
		else {
			$result = $whole_match;
		}
		return $result;
	}
	protected function _doAnchors_inline_callback($matches) {
		$whole_match	=  $matches[1];
		$link_text		=  $this->runSpanGamut($matches[2]);
		$url			=  $matches[3] == '' ? $matches[4] : $matches[3];
		$title			=& $matches[7];

		$url = $this->encodeAttribute($url);

		$result = "<a href=\"$url\"";
		if (isset($title)) {
			$title = $this->encodeAttribute($title);
			$result .=  " title=\"$title\"";
		}
		
		$link_text = $this->runSpanGamut($link_text);
		$result .= ">$link_text</a>";

		return $this->hashPart($result);
	}


	protected function doImages($text) {
	#
	# Turn Markdown image shortcuts into <img> tags.
	#
		#
		# First, handle reference-style labeled images: ![alt text][id]
		#
		$text = preg_replace_callback('{
			(				# wrap whole match in $1
			  !\[
				('.$this->nested_brackets_re.')		# alt text = $2
			  \]

			  [ ]?				# one optional space
			  (?:\n[ ]*)?		# one optional newline followed by spaces

			  \[
				(.*?)		# id = $3
			  \]

			)
			}xs', 
			array(&$this, '_doImages_reference_callback'), $text);

		#
		# Next, handle inline images:  ![alt text](url "optional title")
		# Don't forget: encode * and _
		#
		$text = preg_replace_callback('{
			(				# wrap whole match in $1
			  !\[
				('.$this->nested_brackets_re.')		# alt text = $2
			  \]
			  \s?			# One optional whitespace character
			  \(			# literal paren
				[ \n]*
				(?:
					<(\S*)>	# src url = $3
				|
					('.$this->nested_url_parenthesis_re.')	# src url = $4
				)
				[ \n]*
				(			# $5
				  ([\'"])	# quote char = $6
				  (.*?)		# title = $7
				  \6		# matching quote
				  [ \n]*
				)?			# title is optional
			  \)
			)
			}xs',
			array(&$this, '_doImages_inline_callback'), $text);

		return $text;
	}
	protected function _doImages_reference_callback($matches) {
		$whole_match = $matches[1];
		$alt_text    = $matches[2];
		$link_id     = strtolower($matches[3]);

		if ($link_id == "") {
			$link_id = strtolower($alt_text); # for shortcut links like ![this][].
		}

		$alt_text = $this->encodeAttribute($alt_text);
		if (isset($this->urls[$link_id])) {
			$url = $this->encodeAttribute($this->urls[$link_id]);
			$result = "<img src=\"$url\" alt=\"$alt_text\"";
			if (isset($this->titles[$link_id])) {
				$title = $this->titles[$link_id];
				$title = $this->encodeAttribute($title);
				$result .=  " title=\"$title\"";
			}
			$result .= $this->empty_element_suffix;
			$result = $this->hashPart($result);
		}
		else {
			# If there's no such link ID, leave intact:
			$result = $whole_match;
		}

		return $result;
	}
	protected function _doImages_inline_callback($matches) {
		$whole_match	= $matches[1];
		$alt_text		= $matches[2];
		$url			= $matches[3] == '' ? $matches[4] : $matches[3];
		$title			=& $matches[7];

		$alt_text = $this->encodeAttribute($alt_text);
		$url = $this->encodeAttribute($url);
		$result = "<img src=\"$url\" alt=\"$alt_text\"";
		if (isset($title)) {
			$title = $this->encodeAttribute($title);
			$result .=  " title=\"$title\""; # $title already quoted
		}
		$result .= $this->empty_element_suffix;

		return $this->hashPart($result);
	}


	protected function doHeaders($text) {
		# Setext-style headers:
		#	  Header 1
		#	  ========
		#  
		#	  Header 2
		#	  --------
		#
		$text = preg_replace_callback('{ ^(.+?)[ ]*\n(=+|-+)[ ]*\n+ }mx',
			array(&$this, '_doHeaders_callback_setext'), $text);

		# atx-style headers:
		#	# Header 1
		#	## Header 2
		#	## Header 2 with closing hashes ##
		#	...
		#	###### Header 6
		#
		$text = preg_replace_callback('{
				^(\#{1,6})	# $1 = string of #\'s
				[ ]*
				(.+?)		# $2 = Header text
				[ ]*
				\#*			# optional closing #\'s (not counted)
				\n+
			}xm',
			array(&$this, '_doHeaders_callback_atx'), $text);

		return $text;
	}
	protected function _doHeaders_callback_setext($matches) {
		# Terrible hack to check we haven't found an empty list item.
		if ($matches[2] == '-' && preg_match('{^-(?: |$)}', $matches[1]))
			return $matches[0];
		
		$level = $matches[2]{0} == '=' ? 1 : 2;
		$block = "<h$level>".$this->runSpanGamut($matches[1])."</h$level>";
		return "\n" . $this->hashBlock($block) . "\n\n";
	}
	protected function _doHeaders_callback_atx($matches) {
		$level = strlen($matches[1]);
		$block = "<h$level>".$this->runSpanGamut($matches[2])."</h$level>";
		return "\n" . $this->hashBlock($block) . "\n\n";
	}


	protected function doLists($text) {
	#
	# Form HTML ordered (numbered) and unordered (bulleted) lists.
	#
		$less_than_tab = $this->tab_width - 1;

		# Re-usable patterns to match list item bullets and number markers:
		$marker_ul_re  = '[*+-]';
		$marker_ol_re  = '\d+[.]';
		$marker_any_re = "(?:$marker_ul_re|$marker_ol_re)";

		$markers_relist = array(
			$marker_ul_re => $marker_ol_re,
			$marker_ol_re => $marker_ul_re,
			);

		foreach ($markers_relist as $marker_re => $other_marker_re) {
			# Re-usable pattern to match any entirel ul or ol list:
			$whole_list_re = '
				(								# $1 = whole list
				  (								# $2
					([ ]{0,'.$less_than_tab.'})	# $3 = number of spaces
					('.$marker_re.')			# $4 = first list item marker
					[ ]+
				  )
				  (?s:.+?)
				  (								# $5
					  \z
					|
					  \n{2,}
					  (?=\S)
					  (?!						# Negative lookahead for another list item marker
						[ ]*
						'.$marker_re.'[ ]+
					  )
					|
					  (?=						# Lookahead for another kind of list
					    \n
						\3						# Must have the same indentation
						'.$other_marker_re.'[ ]+
					  )
				  )
				)
			'; // mx
			
			# We use a different prefix before nested lists than top-level lists.
			# See extended comment in _ProcessListItems().
		
			if ($this->list_level) {
				$text = preg_replace_callback('{
						^
						'.$whole_list_re.'
					}mx',
					array(&$this, '_doLists_callback'), $text);
			}
			else {
				$text = preg_replace_callback('{
						(?:(?<=\n)\n|\A\n?) # Must eat the newline
						'.$whole_list_re.'
					}mx',
					array(&$this, '_doLists_callback'), $text);
			}
		}

		return $text;
	}
	protected function _doLists_callback($matches) {
		# Re-usable patterns to match list item bullets and number markers:
		$marker_ul_re  = '[*+-]';
		$marker_ol_re  = '\d+[.]';
		$marker_any_re = "(?:$marker_ul_re|$marker_ol_re)";
		
		$list = $matches[1];
		$list_type = preg_match("/$marker_ul_re/", $matches[4]) ? "ul" : "ol";
		
		$marker_any_re = ( $list_type == "ul" ? $marker_ul_re : $marker_ol_re );
		
		$list .= "\n";
		$result = $this->processListItems($list, $marker_any_re);
		
		$result = $this->hashBlock("<$list_type>\n" . $result . "</$list_type>");
		return "\n". $result ."\n\n";
	}

	protected $list_level = 0;

	protected function processListItems($list_str, $marker_any_re) {
	#
	#	Process the contents of a single ordered or unordered list, splitting it
	#	into individual list items.
	#
		# The $this->list_level global keeps track of when we're inside a list.
		# Each time we enter a list, we increment it; when we leave a list,
		# we decrement. If it's zero, we're not in a list anymore.
		#
		# We do this because when we're not inside a list, we want to treat
		# something like this:
		#
		#		I recommend upgrading to version
		#		8. Oops, now this line is treated
		#		as a sub-list.
		#
		# As a single paragraph, despite the fact that the second line starts
		# with a digit-period-space sequence.
		#
		# Whereas when we're inside a list (or sub-list), that line will be
		# treated as the start of a sub-list. What a kludge, huh? This is
		# an aspect of Markdown's syntax that's hard to parse perfectly
		# without resorting to mind-reading. Perhaps the solution is to
		# change the syntax rules such that sub-lists must start with a
		# starting cardinal number; e.g. "1." or "a.".
		
		$this->list_level++;

		# trim trailing blank lines:
		$list_str = preg_replace("/\n{2,}\\z/", "\n", $list_str);

		$list_str = preg_replace_callback('{
			(\n)?							# leading line = $1
			(^[ ]*)							# leading whitespace = $2
			('.$marker_any_re.'				# list marker and space = $3
				(?:[ ]+|(?=\n))	# space only required if item is not empty
			)
			((?s:.*?))						# list item text   = $4
			(?:(\n+(?=\n))|\n)				# tailing blank line = $5
			(?= \n* (\z | \2 ('.$marker_any_re.') (?:[ ]+|(?=\n))))
			}xm',
			array(&$this, '_processListItems_callback'), $list_str);

		$this->list_level--;
		return $list_str;
	}
	protected function _processListItems_callback($matches) {
		$item = $matches[4];
		$leading_line =& $matches[1];
		$leading_space =& $matches[2];
		$marker_space = $matches[3];
		$tailing_blank_line =& $matches[5];

		if ($leading_line || $tailing_blank_line || 
			preg_match('/\n{2,}/', $item))
		{
			# Replace marker with the appropriate whitespace indentation
			$item = $leading_space . str_repeat(' ', strlen($marker_space)) . $item;
			$item = $this->runBlockGamut($this->outdent($item)."\n");
		}
		else {
			# Recursion for sub-lists:
			$item = $this->doLists($this->outdent($item));
			$item = preg_replace('/\n+$/', '', $item);
			$item = $this->runSpanGamut($item);
		}

		return "<li>" . $item . "</li>\n";
	}


	protected function doCodeBlocks($text) {
	#
	#	Process Markdown `<pre><code>` blocks.
	#
		$text = preg_replace_callback('{
				(?:\n\n|\A\n?)
				(	            # $1 = the code block -- one or more lines, starting with a space/tab
				  (?>
					[ ]{'.$this->tab_width.'}  # Lines must start with a tab or a tab-width of spaces
					.*\n+
				  )+
				)
				((?=^[ ]{0,'.$this->tab_width.'}\S)|\Z)	# Lookahead for non-space at line-start, or end of doc
			}xm',
			array(&$this, '_doCodeBlocks_callback'), $text);

		return $text;
	}
	protected function _doCodeBlocks_callback($matches) {
		$codeblock = $matches[1];

		$codeblock = $this->outdent($codeblock);
		$codeblock = htmlspecialchars($codeblock, ENT_NOQUOTES);

		# trim leading newlines and trailing newlines
		$codeblock = preg_replace('/\A\n+|\n+\z/', '', $codeblock);

		$codeblock = "<pre><code>$codeblock\n</code></pre>";
		return "\n\n".$this->hashBlock($codeblock)."\n\n";
	}


	protected function makeCodeSpan($code) {
	#
	# Create a code span markup for $code. Called from handleSpanToken.
	#
		$code = htmlspecialchars(trim($code), ENT_NOQUOTES);
		return $this->hashPart("<code>$code</code>");
	}


	protected $em_relist = array(
		''  => '(?:(?<!\*)\*(?!\*)|(?<!_)_(?!_))(?=\S|$)(?![.,:;]\s)',
		'*' => '(?<=\S|^)(?<!\*)\*(?!\*)',
		'_' => '(?<=\S|^)(?<!_)_(?!_)',
		);
	protected $strong_relist = array(
		''   => '(?:(?<!\*)\*\*(?!\*)|(?<!_)__(?!_))(?=\S|$)(?![.,:;]\s)',
		'**' => '(?<=\S|^)(?<!\*)\*\*(?!\*)',
		'__' => '(?<=\S|^)(?<!_)__(?!_)',
		);
	protected $em_strong_relist = array(
		''    => '(?:(?<!\*)\*\*\*(?!\*)|(?<!_)___(?!_))(?=\S|$)(?![.,:;]\s)',
		'***' => '(?<=\S|^)(?<!\*)\*\*\*(?!\*)',
		'___' => '(?<=\S|^)(?<!_)___(?!_)',
		);
	protected $em_strong_prepared_relist;
	
	protected function prepareItalicsAndBold() {
	#
	# Prepare regular expressions for searching emphasis tokens in any
	# context.
	#
		foreach ($this->em_relist as $em => $em_re) {
			foreach ($this->strong_relist as $strong => $strong_re) {
				# Construct list of allowed token expressions.
				$token_relist = array();
				if (isset($this->em_strong_relist["$em$strong"])) {
					$token_relist[] = $this->em_strong_relist["$em$strong"];
				}
				$token_relist[] = $em_re;
				$token_relist[] = $strong_re;
				
				# Construct master expression from list.
				$token_re = '{('. implode('|', $token_relist) .')}';
				$this->em_strong_prepared_relist["$em$strong"] = $token_re;
			}
		}
	}
	
	protected function doItalicsAndBold($text) {
		$token_stack = array('');
		$text_stack = array('');
		$em = '';
		$strong = '';
		$tree_char_em = false;
		
		while (1) {
			#
			# Get prepared regular expression for seraching emphasis tokens
			# in current context.
			#
			$token_re = $this->em_strong_prepared_relist["$em$strong"];
			
			#
			# Each loop iteration search for the next emphasis token. 
			# Each token is then passed to handleSpanToken.
			#
			$parts = preg_split($token_re, $text, 2, PREG_SPLIT_DELIM_CAPTURE);
			$text_stack[0] .= $parts[0];
			$token =& $parts[1];
			$text =& $parts[2];
			
			if (empty($token)) {
				# Reached end of text span: empty stack without emitting.
				# any more emphasis.
				while ($token_stack[0]) {
					$text_stack[1] .= array_shift($token_stack);
					$text_stack[0] .= array_shift($text_stack);
				}
				break;
			}
			
			$token_len = strlen($token);
			if ($tree_char_em) {
				# Reached closing marker while inside a three-char emphasis.
				if ($token_len == 3) {
					# Three-char closing marker, close em and strong.
					array_shift($token_stack);
					$span = array_shift($text_stack);
					$span = $this->runSpanGamut($span);
					$span = "<strong><em>$span</em></strong>";
					$text_stack[0] .= $this->hashPart($span);
					$em = '';
					$strong = '';
				} else {
					# Other closing marker: close one em or strong and
					# change current token state to match the other
					$token_stack[0] = str_repeat($token{0}, 3-$token_len);
					$tag = $token_len == 2 ? "strong" : "em";
					$span = $text_stack[0];
					$span = $this->runSpanGamut($span);
					$span = "<$tag>$span</$tag>";
					$text_stack[0] = $this->hashPart($span);
					$$tag = ''; # $$tag stands for $em or $strong
				}
				$tree_char_em = false;
			} else if ($token_len == 3) {
				if ($em) {
					# Reached closing marker for both em and strong.
					# Closing strong marker:
					for ($i = 0; $i < 2; ++$i) {
						$shifted_token = array_shift($token_stack);
						$tag = strlen($shifted_token) == 2 ? "strong" : "em";
						$span = array_shift($text_stack);
						$span = $this->runSpanGamut($span);
						$span = "<$tag>$span</$tag>";
						$text_stack[0] .= $this->hashPart($span);
						$$tag = ''; # $$tag stands for $em or $strong
					}
				} else {
					# Reached opening three-char emphasis marker. Push on token 
					# stack; will be handled by the special condition above.
					$em = $token{0};
					$strong = "$em$em";
					array_unshift($token_stack, $token);
					array_unshift($text_stack, '');
					$tree_char_em = true;
				}
			} else if ($token_len == 2) {
				if ($strong) {
					# Unwind any dangling emphasis marker:
					if (strlen($token_stack[0]) == 1) {
						$text_stack[1] .= array_shift($token_stack);
						$text_stack[0] .= array_shift($text_stack);
					}
					# Closing strong marker:
					array_shift($token_stack);
					$span = array_shift($text_stack);
					$span = $this->runSpanGamut($span);
					$span = "<strong>$span</strong>";
					$text_stack[0] .= $this->hashPart($span);
					$strong = '';
				} else {
					array_unshift($token_stack, $token);
					array_unshift($text_stack, '');
					$strong = $token;
				}
			} else {
				# Here $token_len == 1
				if ($em) {
					if (strlen($token_stack[0]) == 1) {
						# Closing emphasis marker:
						array_shift($token_stack);
						$span = array_shift($text_stack);
						$span = $this->runSpanGamut($span);
						$span = "<em>$span</em>";
						$text_stack[0] .= $this->hashPart($span);
						$em = '';
					} else {
						$text_stack[0] .= $token;
					}
				} else {
					array_unshift($token_stack, $token);
					array_unshift($text_stack, '');
					$em = $token;
				}
			}
		}
		return $text_stack[0];
	}


	protected function doBlockQuotes($text) {
		$text = preg_replace_callback('/
			  (								# Wrap whole match in $1
				(?>
				  ^[ ]*>[ ]?			# ">" at the start of a line
					.+\n					# rest of the first line
				  (.+\n)*					# subsequent consecutive lines
				  \n*						# blanks
				)+
			  )
			/xm',
			array(&$this, '_doBlockQuotes_callback'), $text);

		return $text;
	}
	protected function _doBlockQuotes_callback($matches) {
		$bq = $matches[1];
		# trim one level of quoting - trim whitespace-only lines
		$bq = preg_replace('/^[ ]*>[ ]?|^[ ]+$/m', '', $bq);
		$bq = $this->runBlockGamut($bq);		# recurse

		$bq = preg_replace('/^/m', "  ", $bq);
		# These leading spaces cause problem with <pre> content, 
		# so we need to fix that:
		$bq = preg_replace_callback('{(\s*<pre>.+?</pre>)}sx', 
			array(&$this, '_doBlockQuotes_callback2'), $bq);

		return "\n". $this->hashBlock("<blockquote>\n$bq\n</blockquote>")."\n\n";
	}
	protected function _doBlockQuotes_callback2($matches) {
		$pre = $matches[1];
		$pre = preg_replace('/^  /m', '', $pre);
		return $pre;
	}


	protected function formParagraphs($text) {
	#
	#	Params:
	#		$text - string to process with html <p> tags
	#
		# Strip leading and trailing lines:
		$text = preg_replace('/\A\n+|\n+\z/', '', $text);

		$grafs = preg_split('/\n{2,}/', $text, -1, PREG_SPLIT_NO_EMPTY);

		#
		# Wrap <p> tags and unhashify HTML blocks
		#
		foreach ($grafs as $key => $value) {
			if (!preg_match('/^B\x1A[0-9]+B$/', $value)) {
				# Is a paragraph.
				$value = $this->runSpanGamut($value);
				$value = preg_replace('/^([ ]*)/', "<p>", $value);
				$value .= "</p>";
				$grafs[$key] = $this->unhash($value);
			}
			else {
				# Is a block.
				# Modify elements of @grafs in-place...
				$graf = $value;
				$block = $this->html_hashes[$graf];
				$graf = $block;
//				if (preg_match('{
//					\A
//					(							# $1 = <div> tag
//					  <div  \s+
//					  [^>]*
//					  \b
//					  markdown\s*=\s*  ([\'"])	#	$2 = attr quote char
//					  1
//					  \2
//					  [^>]*
//					  >
//					)
//					(							# $3 = contents
//					.*
//					)
//					(</div>)					# $4 = closing tag
//					\z
//					}xs', $block, $matches))
//				{
//					list(, $div_open, , $div_content, $div_close) = $matches;
//
//					# We can't call Markdown(), because that resets the hash;
//					# that initialization code should be pulled into its own sub, though.
//					$div_content = $this->hashHTMLBlocks($div_content);
//					
//					# Run document gamut methods on the content.
//					foreach ($this->document_gamut as $method => $priority) {
//						$div_content = $this->$method($div_content);
//					}
//
//					$div_open = preg_replace(
//						'{\smarkdown\s*=\s*([\'"]).+?\1}', '', $div_open);
//
//					$graf = $div_open . "\n" . $div_content . "\n" . $div_close;
//				}
				$grafs[$key] = $graf;
			}
		}

		return implode("\n\n", $grafs);
	}


	protected function encodeAttribute($text) {
	#
	# Encode text for a double-quoted HTML attribute. This function
	# is *not* suitable for attributes enclosed in single quotes.
	#
		$text = $this->encodeAmpsAndAngles($text);
		$text = str_replace('"', '&quot;', $text);
		return $text;
	}
	
	
	protected function encodeAmpsAndAngles($text) {
	#
	# Smart processing for ampersands and angle brackets that need to 
	# be encoded. Valid character entities are left alone unless the
	# no-entities mode is set.
	#
		if ($this->no_entities) {
			$text = str_replace('&', '&amp;', $text);
		} else {
			# Ampersand-encoding based entirely on Nat Irons's Amputator
			# MT plugin: <http://bumppo.net/projects/amputator/>
			$text = preg_replace('/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/', 
								'&amp;', $text);;
		}
		# Encode remaining <'s
		$text = str_replace('<', '&lt;', $text);

		return $text;
	}


	protected function doAutoLinks($text) {
		$text = preg_replace_callback('{<((https?|ftp|dict):[^\'">\s]+)>}i', 
			array(&$this, '_doAutoLinks_url_callback'), $text);

		# Email addresses: <address@domain.foo>
		$text = preg_replace_callback('{
			<
			(?:mailto:)?
			(
				(?:
					[-!#$%&\'*+/=?^_`.{|}~\w\x80-\xFF]+
				|
					".*?"
				)
				\@
				(?:
					[-a-z0-9\x80-\xFF]+(\.[-a-z0-9\x80-\xFF]+)*\.[a-z]+
				|
					\[[\d.a-fA-F:]+\]	# IPv4 & IPv6
				)
			)
			>
			}xi',
			array(&$this, '_doAutoLinks_email_callback'), $text);

		return $text;
	}
	protected function _doAutoLinks_url_callback($matches) {
		$url = $this->encodeAttribute($matches[1]);
		$link = "<a href=\"$url\">$url</a>";
		return $this->hashPart($link);
	}
	protected function _doAutoLinks_email_callback($matches) {
		$address = $matches[1];
		$link = $this->encodeEmailAddress($address);
		return $this->hashPart($link);
	}


	protected function encodeEmailAddress($addr) {
	#
	#	Input: an email address, e.g. "foo@example.com"
	#
	#	Output: the email address as a mailto link, with each character
	#		of the address encoded as either a decimal or hex entity, in
	#		the hopes of foiling most address harvesting spam bots. E.g.:
	#
	#	  <p><a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#58;&#x66;o&#111;
	#        &#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;
	#        &#x6d;">&#x66;o&#111;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#x6c;
	#        &#101;&#46;&#x63;&#111;&#x6d;</a></p>
	#
	#	Based by a filter by Matthew Wickline, posted to BBEdit-Talk.
	#   With some optimizations by Milian Wolff.
	#
		$addr = "mailto:" . $addr;
		$chars = preg_split('/(?<!^)(?!$)/', $addr);
		$seed = (int)abs(crc32($addr) / strlen($addr)); # Deterministic seed.
		
		foreach ($chars as $key => $char) {
			$ord = ord($char);
			# Ignore non-ascii chars.
			if ($ord < 128) {
				$r = ($seed * (1 + $key)) % 100; # Pseudo-random function.
				# roughly 10% raw, 45% hex, 45% dec
				# '@' *must* be encoded. I insist.
				if ($r > 90 && $char != '@') /* do nothing */;
				else if ($r < 45) $chars[$key] = '&#x'.dechex($ord).';';
				else              $chars[$key] = '&#'.$ord.';';
			}
		}
		
		$addr = implode('', $chars);
		$text = implode('', array_slice($chars, 7)); # text without `mailto:`
		$addr = "<a href=\"$addr\">$text</a>";

		return $addr;
	}


	protected function parseSpan($str) {
	#
	# Take the string $str and parse it into tokens, hashing embeded HTML,
	# escaped characters and handling code spans.
	#
		$output = '';
		
		$span_re = '{
				(
					\\\\'.$this->escape_chars_re.'
				|
					(?<![`\\\\])
					`+						# code span marker
			'.( $this->no_markup ? '' : '
				|
					<!--    .*?     -->		# comment
				|
					<\?.*?\?> | <%.*?%>		# processing instruction
				|
					<[/!$]?[-a-zA-Z0-9:_]+	# regular tags
					(?>
						\s
						(?>[^"\'>]+|"[^"]*"|\'[^\']*\')*
					)?
					>
			').'
				)
				}xs';

		while (1) {
			#
			# Each loop iteration seach for either the next tag, the next 
			# openning code span marker, or the next escaped character. 
			# Each token is then passed to handleSpanToken.
			#
			$parts = preg_split($span_re, $str, 2, PREG_SPLIT_DELIM_CAPTURE);
			
			# Create token from text preceding tag.
			if ($parts[0] != "") {
				$output .= $parts[0];
			}
			
			# Check if we reach the end.
			if (isset($parts[1])) {
				$output .= $this->handleSpanToken($parts[1], $parts[2]);
				$str = $parts[2];
			}
			else {
				break;
			}
		}
		
		return $output;
	}
	
	
	protected function handleSpanToken($token, &$str) {
	#
	# Handle $token provided by parseSpan by determining its nature and 
	# returning the corresponding value that should replace it.
	#
		switch ($token{0}) {
			case "\\":
				return $this->hashPart("&#". ord($token{1}). ";");
			case "`":
				# Search for end marker in remaining text.
				if (preg_match('/^(.*?[^`])'.preg_quote($token).'(?!`)(.*)$/sm', 
					$str, $matches))
				{
					$str = $matches[2];
					$codespan = $this->makeCodeSpan($matches[1]);
					return $this->hashPart($codespan);
				}
				return $token; // return as text since no ending marker found.
			default:
				return $this->hashPart($token);
		}
	}


	protected function outdent($text) {
	#
	# Remove one level of line-leading tabs or spaces
	#
		return preg_replace('/^(\t|[ ]{1,'.$this->tab_width.'})/m', '', $text);
	}


	# String length function for detab. `_initDetab` will create a function to 
	# hanlde UTF-8 if the default function does not exist.
	protected $utf8_strlen = 'mb_strlen';
	
	protected function detab($text) {
	#
	# Replace tabs with the appropriate amount of space.
	#
		# For each line we separate the line in blocks delemited by
		# tab characters. Then we reconstruct every line by adding the 
		# appropriate number of space between each blocks.
		
		$text = preg_replace_callback('/^.*\t.*$/m',
			array(&$this, '_detab_callback'), $text);

		return $text;
	}
	protected function _detab_callback($matches) {
		$line = $matches[0];
		$strlen = $this->utf8_strlen; # strlen function for UTF-8.
		
		# Split in blocks.
		$blocks = explode("\t", $line);
		# Add each blocks to the line.
		$line = $blocks[0];
		unset($blocks[0]); # Do not add first block twice.
		foreach ($blocks as $block) {
			# Calculate amount of space, insert spaces, insert block.
			$amount = $this->tab_width - 
				$strlen($line, 'UTF-8') % $this->tab_width;
			$line .= str_repeat(" ", $amount) . $block;
		}
		return $line;
	}
	protected function _initDetab() {
	#
	# Check for the availability of the function in the `utf8_strlen` property
	# (initially `mb_strlen`). If the function is not available, create a 
	# function that will loosely count the number of UTF-8 characters with a
	# regular expression.
	#
		if (function_exists($this->utf8_strlen)) return;
		$this->utf8_strlen = create_function('$text', 'return preg_match_all(
			"/[\\\\x00-\\\\xBF]|[\\\\xC0-\\\\xFF][\\\\x80-\\\\xBF]*/", 
			$text, $m);');
	}


	protected function unhash($text) {
	#
	# Swap back in all the tags hashed by _HashHTMLBlocks.
	#
		return preg_replace_callback('/(.)\x1A[0-9]+\1/', 
			array(&$this, '_unhash_callback'), $text);
	}
	protected function _unhash_callback($matches) {
		return $this->html_hashes[$matches[0]];
	}

}

}

/*

PHP Markdown
============

Description
-----------

This is a PHP translation of the original Markdown formatter written in
Perl by John Gruber.

Markdown is a text-to-HTML filter; it translates an easy-to-read /
easy-to-write structured text format into HTML. Markdown's text format
is most similar to that of plain text email, and supports features such
as headers, *emphasis*, code blocks, blockquotes, and links.

Markdown's syntax is designed not as a generic markup language, but
specifically to serve as a front-end to (X)HTML. You can use span-level
HTML tags anywhere in a Markdown document, and you can use block level
HTML tags (like <div> and <table> as well).

For more information about Markdown's syntax, see:

<http://daringfireball.net/projects/markdown/>


Bugs
----

To file bug reports please send email to:

<michel.fortin@michelf.com>

Please include with your report: (1) the example input; (2) the output you
expected; (3) the output Markdown actually produced.


Version History
--------------- 

See the readme file for detailed release notes for this version.


Copyright and License
---------------------

PHP Markdown
Copyright (c) 2004-2009 Michel Fortin  
<http://michelf.com/>  
All rights reserved.

Based on Markdown
Copyright (c) 2003-2006 John Gruber   
<http://daringfireball.net/>   
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*	Redistributions of source code must retain the above copyright notice,
	this list of conditions and the following disclaimer.

*	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

*	Neither the name "Markdown" nor the names of its contributors may
	be used to endorse or promote products derived from this software
	without specific prior written permission.

This software is provided by the copyright holders and contributors "as
is" and any express or implied warranties, including, but not limited
to, the implied warranties of merchantability and fitness for a
particular purpose are disclaimed. In no event shall the copyright owner
or contributors be liable for any direct, indirect, incidental, special,
exemplary, or consequential damages (including, but not limited to,
procurement of substitute goods or services; loss of use, data, or
profits; or business interruption) however caused and on any theory of
liability, whether in contract, strict liability, or tort (including
negligence or otherwise) arising in any way out of the use of this
software, even if advised of the possibility of such damage.
*/
?>
MD
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_image_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR . 'image.php';
	write($path, sprintf(<<< 'IMG'
<?php
/**
 * Image Module 1.1 for Pragwork %s
 *
 * @copyright %s
 * @license %s
 * @version %s
 * @package Image
 */


IMG
		, PRAGWORK_VERSION, AUTHOR, LICENSE, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'IMG'
namespace Image;

/**
 * Utility class for handling images.
 *
 * @author Szymon Wrozynski
 * @package Image 
 */
class Image
{
	/**
	 * Sends the image from the given path and with the given name optionally. 
	 * It is a final action. The request processing will stop after.
	 *
	 * @param string $path Image file path
	 * @param string $name Optional file name
	 * @return bool False if the image cannot be sent
	 * @throws {@link \Application\StopException} In order to stop execution
	 */
	public static function render($path, $name=null)
	{	 
		if (is_file($path))
		{
			$info = getimagesize($path);
			$size = filesize($path);
			
			$response = \Application\Response::instance();
			
			$response->content_type = $info['mime'];
			$response->add_header('Content-Disposition: inline; filename="' 
				. (($name === null) ? basename($path) : $name) .'"');
			$response->add_header('Content-Length: ' . $size);
			
			readfile($path);
			throw new \Application\StopException;
		}

		return false;
	}

	/**
	 * Creates a thumbnail image from the given image path. 
	 * The thumbnail file is stored under the $thumb. Allowed image formats
	 * are: PNG, GIF, and JPG.
	 *
	 * @param string $file Image file path (source)
	 * @param string $thumbnail Image thumbnail path (target)
	 * @param int $max_width Max thumbnail width (in pixels)
	 * @param int $max_height Max thumbnail height (in pixels)
	 * @param int $jpg_quality Quality of the thumbnail if the file is a JPG one (default: 95)
	 */
	public static function save_thumbnail($file, $thumbnail, $max_width=100,
		$max_height=100, $jpg_quality=95)
	{
		$info = getimagesize($file);

		if (($info[0] <= $max_width) && ($info[1] <= $max_height))
		{
			$w = $info[0];
			$h = $info[1];
		}
		else
		{
			$scale = ($info[0] > $info[1]) ? $info[0] / $max_width : $info[1] / $max_height;

			$w = floor($info[0] / $scale);
			$h = floor($info[1] / $scale);
		}

		$thumb = imagecreatetruecolor($w, $h);
		$image_type = self::get_type($info['mime']);

		if (!$image_type)
			throw new \ErrorException('Incorrect image type: ' . $info['mime']);
		elseif ($image_type === 'PNG')
		{
			imagecopyresampled($thumb, imagecreatefrompng($file), 0, 0, 0, 0, $w, $h, $info[0], $info[1]);
			imagepng($thumb, $thumbnail);
		}
		elseif ($image_type === 'GIF')
		{
			imagecopyresampled($thumb, imagecreatefromgif($file), 0, 0, 0, 0, $w, $h, $info[0], $info[1]);
			imagegif($thumb, $thumbnail);
		}
		elseif ($image_type === 'JPG')
		{
			imagecopyresampled($thumb, imagecreatefromjpeg($file), 0, 0, 0, 0, $w, $h, $info[0], $info[1]);
			imagejpeg($thumb, $thumbnail, $jpg_quality);
		}

		imagedestroy($thumb);
	}

	/**
	 * Returns the string ('PNG', 'GIF', or 'JPG') with image type based on the
	 * MIME information or false if no image was found. Recognized image formats
	 * are: PNG, GIF, and JPG.
	 *
	 * @param string $mime MIME information
	 * @return mixed String ('PNG', 'GIF', or 'JPG'), or false
	 */
	public static function get_type($mime)
	{
		if ($mime)
		{
			if (stripos($mime, 'png', 6) !== false)
				return 'PNG';
			elseif (stripos($mime, 'gif', 6) !== false)
				return 'GIF';
			elseif (stripos($mime, 'jp', 6) !== false)
				return 'JPG';
		}
		return false;
	}
}
?>
IMG
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_activerecord_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR;
	write($path . 'activerecord.php', sprintf(<<< 'AR'
<?php
/**
 * ActiveRecord Module 1.1 for Pragwork %s
 *
 * @copyright Kien La, Jacques Fuentes (PHP ActiveRecord Library), 
 *			  Szymon Wrozynski (the module and additions)
 * @license %s
 * @version %s
 * @package Activerecord
 */


AR
		, PRAGWORK_VERSION, LICENSE, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'AR'
/*
Copyright (c) 2009

AUTHORS:
Kien La
Jacques Fuentes

Modifications for Pragwork: Szymon Wrozynski
TablelessModel: Szymon Wrozynski
Some bug fixes: Szymon Wrozynski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

namespace ActiveRecord;
/*
 * Thanks to http://www.eval.ca/articles/php-pluralize (MIT license)
 *	http://dev.rubyonrails.org/browser/trunk/activesupport/lib/active_support/inflections.rb (MIT license)
 *			 http://www.fortunecity.com/bally/durrus/153/gramch13.html
 *			 http://www2.gsu.edu/~wwwesl/egw/crump.htm
 *
 * Changes (12/17/07)
 *	 Major changes
 *	 --
 *	 Fixed irregular noun algorithm to use regular expressions just like the original Ruby source.
 *		 (this allows for things like fireman -> firemen
 *	 Fixed the order of the singular array, which was backwards.
 *
 *	 Minor changes
 *	 --
 *	 Removed incorrect pluralization rule for /([^aeiouy]|qu)ies$/ => $1y
 *	 Expanded on the list of exceptions for *o -> *oes, and removed rule for buffalo -> buffaloes
 *	 Removed dangerous singularization rule for /([^f])ves$/ => $1fe
 *	 Added more specific rules for singularizing lives, wives, knives, sheaves, loaves, and leaves and thieves
 *	 Added exception to /(us)es$/ => $1 rule for houses => house and blouses => blouse
 *	 Added excpetions for feet, geese and teeth
 *	 Added rule for deer -> deer
 *
 * Changes:
 *	 Removed rule for virus -> viri
 *	 Added rule for potato -> potatoes
 *	 Added rule for *us -> *uses
 */
function classify($class_name, $singularize=false)
{
	if ($singularize)
		$class_name = Utils::singularize($class_name);

	$class_name = Inflector::instance()->camelize($class_name);
	return ucfirst($class_name);
}

// http://snippets.dzone.com/posts/show/4660
function array_flatten(array $array)
{
	$i = 0;

	while ($i < count($array))
	{
		if (is_array($array[$i]))
			array_splice($array,$i,1,$array[$i]);
		else
			++$i;
	}	
	return $array;
}

/**
 * Somewhat naive way to determine if an array is a hash.
 */
function is_hash(&$array)
{
	if (!is_array($array))
		return false;

	$keys = array_keys($array);
	return @is_string($keys[0]) ? true : false;
}

/**
 * Strips a class name of any namespaces and namespace operator.
 *
 * @param string $class
 * @return string stripped class name
 * @access public
 */
function denamespace($class_name)
{
	if (is_object($class_name))
		$class_name = get_class($class_name);

	if (has_namespace($class_name))
	{
		$parts = explode('\\', $class_name);
		return end($parts);
	}
	return $class_name;
}

/**
 * Adds the 'Models' namespace to the given class name if there is no namespace 
 * yet.
 *
 * $param string $class_name
 * return string Class name prepended with the 'Models' namespace
 */
function add_namespace($class_name)
{
	return (strpos($class_name, '\\') === false)
		? 'Models\\' . $class_name
		: $class_name;
}

function get_namespaces($class_name)
{
	if (has_namespace($class_name))
		return explode('\\', $class_name);
	return null;
}

function has_namespace($class_name)
{
	if (strpos($class_name, '\\') !== false)
		return true;
	return false;
}

/**
 * Returns true if all values in $haystack === $needle
 * @param $needle
 * @param $haystack
 * @return unknown_type
 */
function all($needle, array $haystack)
{
	foreach ($haystack as $value)
	{
		if ($value !== $needle)
			return false;
	}
	return true;
}

function collect(&$enumerable, $name_or_closure)
{
	$ret = array();

	foreach ($enumerable as $value)
	{
		if (is_string($name_or_closure))
			$ret[] = is_array($value) ? $value[$name_or_closure] : $value->$name_or_closure;
		elseif ($name_or_closure instanceof Closure)
			$ret[] = $name_or_closure($value);
	}
	return $ret;
}

function get_public_properties($obj)
{
	return get_object_vars($obj);
}

spl_autoload_register(function($class)
{
	if (strpos($class, 'ActiveRecord\\') === 0)
		require MODULES . str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
});

require CONFIG . 'activerecord.php';
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	
	$path .= 'ActiveRecord';
	
	if (is_dir($path))
		rmtree($path);
	
	mkdir($path, 0755);
	
	$path .= DIRECTORY_SEPARATOR;
	
	write($path . 'CallBack.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;

/**
 * Callbacks allow the programmer to hook into the life cycle of a {@link Model}.
 * 
 * You can control the state of your object by declaring certain methods to be
 * called before or after methods are invoked on your object inside of ActiveRecord.
 * 
 * Valid callbacks are:
 * <ul>
 * <li><b>after_construct:</b> called after a model has been constructed</li>
 * <li><b>before_save:</b> called before a model is saved</li>
 * <li><b>after_save:</b> called after a model is saved</li>
 * <li><b>before_create:</b> called before a NEW model is to be inserted into the database</li>
 * <li><b>after_create:</b> called after a NEW model has been inserted into the database</li>
 * <li><b>before_update:</b> called before an existing model has been saved</li>
 * <li><b>after_update:</b> called after an existing model has been saved</li>
 * <li><b>before_validation:</b> called before running validators</li>
 * <li><b>after_validation:</b> called after running validators</li>
 * <li><b>before_validation_on_create:</b> called before validation on a NEW model being inserted</li>
 * <li><b>after_validation_on_create:</b> called after validation on a NEW model being inserted</li>
 * <li><b>before_validation_on_update:</b> see above except for an existing model being saved</li>
 * <li><b>after_validation_on_update:</b> ...</li>
 * <li><b>before_destroy:</b> called after a model has been deleted</li>
 * <li><b>after_destroy:</b> called after a model has been deleted</li>
 * </ul>
 * 
 * This class isn't meant to be used directly. Callbacks are defined on your model like the example below:
 * 
 * <code>
 * class Person extends ActiveRecord\Model 
 * {
 *     static $before_save = array('make_name_uppercase');
 *	   static $after_save = array('do_happy_dance');
 *	 
 *	   public function make_name_uppercase() 
 *     {
 *	       $this->name = strtoupper($this->name);
 *	   }
 * 
 *	   public function do_happy_dance() 
 *     {
 *	       happy_dance();
 *	   }
 * }
 * </code>
 *
 * Available options for callbacks:
 *
 * <ul>
 * <li><b>prepend:</b> puts the callback at the top of the callback chain instead of the bottom</li>
 * </ul>
 *
 * @package ActiveRecord
 * @link http://www.phpactiverecord.org/guides/callbacks
 */
class CallBack
{
	/**
	 * List of available callbacks.
	 *
	 * @var array
	 */
	static protected $VALID_CALLBACKS = array(
		'after_construct',
		'before_save',
		'after_save',
		'before_create',
		'after_create',
		'before_update',
		'after_update',
		'before_validation',
		'after_validation',
		'before_validation_on_create',
		'after_validation_on_create',
		'before_validation_on_update',
		'after_validation_on_update',
		'before_destroy',
		'after_destroy'
	);

	/**
	 * Container for reflection class of given model
	 * 
	 * @var object
	 */
	private $klass;
	
	/**
	 * List of public methods of the given model
	 * @var array
	 */
	private $publicMethods;

	/**
	 * Holds data for registered callbacks.
	 *
	 * @var array
	 */
	private $registry = array();

	/**
	 * Creates a CallBack.
	 *
	 * @param string $model_class_name The name of a {@link Model} class
	 * @return CallBack
	 */
	public function __construct($model_class_name)
	{
		$this->klass = Reflections::instance()->get($model_class_name);

		foreach (static::$VALID_CALLBACKS as $name)
		{
			// look for explicitly defined static callback
			if (($definition = $this->klass->getStaticPropertyValue($name,null)))
			{
				if ((array) $definition !== $definition)
					$definition = array($definition);

				foreach ($definition as $method_name)
					$this->register($name,$method_name);
			}

			// implicit callbacks that don't need to have a static definition
			// simply define a method named the same as something in $VALID_CALLBACKS
			// and the callback is auto-registered
			elseif ($this->klass->hasMethod($name))
				$this->register($name,$name);
		}
	}

	/**
	 * Returns all the callbacks registered for a callback type.
	 *
	 * @param $name string Name of a callback (see {@link VALID_CALLBACKS $VALID_CALLBACKS})
	 * @return array array of callbacks or null if invalid callback name.
	 */
	public function get_callbacks($name)
	{
		return isset($this->registry[$name]) ? $this->registry[$name] : null;
	}

	/**
	 * Invokes a callback.
	 *
	 * @internal This is the only piece of the CallBack class that carries its own logic for the
	 * model object. For (after|before)_(create|update) callbacks, it will merge with
	 * a generic 'save' callback which is called first for the lease amount of precision.
	 *
	 * @param string $model Model to invoke the callback on.
	 * @param string $name Name of the callback to invoke
	 * @param boolean $must_exist Set to true to raise an exception if the callback does not exist.
	 * @return mixed null if $name was not a valid callback type or false if a method was invoked
	 * that was for a before_* callback and that method returned false. If this happens, execution
	 * of any other callbacks after the offending callback will not occur.
	 */
	public function invoke($model, $name, $must_exist=true)
	{
		if ($must_exist && !array_key_exists($name, $this->registry))
			throw new ActiveRecordException("No callbacks were defined for: $name on " . get_class($model));

		// if it doesn't exist it might be a /(after|before)_(create|update)/ so we still need to run the save
		// callback
		if (!array_key_exists($name, $this->registry))
			$registry = array();
		else
			$registry = $this->registry[$name];

		$first = substr($name,0,6);

		// starts with /(after|before)_(create|update)/
		if (($first == 'after_' || $first == 'before') && (($second = substr($name,7,5)) == 'creat' || $second == 'updat' || $second == 'reate' || $second == 'pdate'))
		{
			$temporal_save = str_replace(array('create', 'update'), 'save', $name);

			if (!isset($this->registry[$temporal_save]))
				$this->registry[$temporal_save] = array();

			$registry = array_merge($this->registry[$temporal_save], $registry ? $registry : array());
		}

		if ($registry)
		{
			foreach ($registry as $method)
			{
				$ret = ($method instanceof \Closure ? $method($model) : $model->$method());

				if (false === $ret && $first === 'before')
					return false;
			}
		}
		return true;
	}

	/**
	 * Register a new callback.
	 *
	 * The option array can contain the following parameters:
	 * <ul>
	 * <li><b>prepend:</b> Add this callback at the beginning of the existing callbacks (true) or at the end (false, default)</li>
	 * </ul>
	 *
	 * @param string $name Name of callback type (see {@link VALID_CALLBACKS $VALID_CALLBACKS})
	 * @param mixed $closure_or_method_name Either a closure or the name of a method on the {@link Model}
	 * @param array $options Options array
	 * @return void
	 * @throws ActiveRecordException if invalid callback type or callback method was not found
	 */
	public function register($name, $closure_or_method_name=null, 
		$options=array())
	{
		$options = array_merge(array('prepend' => false), $options);

		if (!$closure_or_method_name)
			$closure_or_method_name = $name;

		if (!in_array($name,self::$VALID_CALLBACKS))
			throw new ActiveRecordException("Invalid callback: $name");

		if (!($closure_or_method_name instanceof \Closure))
		{
			if (!isset($this->publicMethods))
				$this->publicMethods=get_class_methods($this->klass->getName());

			if (!in_array($closure_or_method_name, $this->publicMethods))
			{
				if ($this->klass->hasMethod($closure_or_method_name))
				{
					// Method is private or protected
					throw new ActiveRecordException(
				"Callback methods need to be public (or anonymous closures). " 
				."Please change the visibility of " . $this->klass->getName() 
				. "->" . $closure_or_method_name . "()");
				}
				else
				{
					// i'm a dirty ruby programmer
					throw new ActiveRecordException(
						"Unknown method for callback: $name" 
						. (is_string($closure_or_method_name) 
							? ": #$closure_or_method_name" 
							: ""
						)
					);
				}
			}
		}

		if (!isset($this->registry[$name]))
			$this->registry[$name] = array();

		if ($options['prepend'])
			array_unshift($this->registry[$name], $closure_or_method_name);
		else
			$this->registry[$name][] = $closure_or_method_name;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Column.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;

/**
 * Class for a table column.
 *
 * @package ActiveRecord
 */
class Column
{
	// types for $type
	const STRING	= 1;
	const INTEGER	= 2;
	const DECIMAL	= 3;
	const DATETIME	= 4;
	const DATE		= 5;
	const TIME		= 6;

	/**
	 * Map a type to an column type.
	 * @static
	 * @var array
	 */
	static $TYPE_MAPPING = array(
		'datetime'	=> self::DATETIME,
		'timestamp' => self::DATETIME,
		'date'		=> self::DATE,
		'time'		=> self::TIME,

		'int'		=> self::INTEGER,
		'tinyint'	=> self::INTEGER,
		'smallint'	=> self::INTEGER,
		'mediumint' => self::INTEGER,
		'bigint'	=> self::INTEGER,

		'float'		=> self::DECIMAL,
		'double'	=> self::DECIMAL,
		'numeric'	=> self::DECIMAL,
		'decimal'	=> self::DECIMAL,
		'dec'		=> self::DECIMAL);

	/**
	 * The true name of this column.
	 * @var string
	 */
	public $name;

	/**
	 * The inflected name of this columns .. hyphens/spaces will be => _.
	 * @var string
	 */
	public $inflected_name;

	/**
	 * The type of this column: STRING, INTEGER, ...
	 * @var integer
	 */
	public $type;

	/**
	 * The raw database specific type.
	 * @var string
	 */
	public $raw_type;

	/**
	 * The maximum length of this column.
	 * @var int
	 */
	public $length;

	/**
	 * True if this column allows null.
	 * @var boolean
	 */
	public $nullable;

	/**
	 * True if this column is a primary key.
	 * @var boolean
	 */
	public $pk;

	/**
	 * The default value of the column.
	 * @var mixed
	 */
	public $default;

	/**
	 * True if this column is set to auto_increment.
	 * @var boolean
	 */
	public $auto_increment;

	/**
	 * Name of the sequence to use for this column if any.
	 * @var boolean
	 */
	public $sequence;

	/**
	 * Casts a value to the column's type.
	 *
	 * @param mixed $value The value to cast
	 * @param Connection $connection The Connection this column belongs to
	 * @return mixed type-casted value
	 */
	public function cast($value, $connection)
	{
		if ($value === null)
			return null;

		switch ($this->type)
		{
			case self::STRING:	return (string)$value;
			case self::INTEGER: return (int)$value;
			case self::DECIMAL: return (double)$value;
			case self::DATETIME:
			case self::DATE:
				if (!$value)
					return null;

				if ($value instanceof DateTime)
					return $value;
					
				if ($value instanceof \DateTime)
					return new DateTime($value->format('Y-m-d H:i:s T'));

				return $connection->string_to_datetime($value);
		}
		return $value;
	}

	/**
	 * Sets the $type member variable.
	 * @return mixed
	 */
	public function map_raw_type()
	{
		if ($this->raw_type == 'integer')
			$this->raw_type = 'int';

		if (array_key_exists($this->raw_type,self::$TYPE_MAPPING))
			$this->type = self::$TYPE_MAPPING[$this->raw_type];
		else
			$this->type = self::STRING;

		return $this->type;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Configuration.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Manages configuration options for ActiveRecord.
 *
 * <code>
 * ActiveRecord\Configuration::initialize(function($cfg) {
 *	 $cfg->connections = array(
 *	   'development' => 'mysql://user:pass@development.com/awesome_development',
 *	   'production' => 'mysql://user:pass@production.com/awesome_production'
 *   );
 * });
 * </code>
 *
 * @package ActiveRecord
 */
class Configuration extends \Application\ModuleConfiguration
{
	protected static $instance;
	
	protected static $defaults = array(
		'connection' => null,
		'logging' => false,
		'logger' => null
	);
	
	/**
	 * Returns a connection string if found otherwise null.
	 *
	 * @param string $environment Name of the environment
	 * @return string connection info for specified environment
	 */
	public function connection_for($environment)
	{
		if (isset($this->env_vars[$environment]['connection']))
			return $this->env_vars[$environment]['connection'];
	}
	
	/**
	 * Sets the url for the cache server to enable query caching.
	 *
	 * Only table schema queries are cached at the moment. A general query cache
	 * will follow.
	 *
	 * Example:
	 *
	 * <code>
	 * $config->set_cache("memcached://localhost");
	 * $config->set_cache("memcached://localhost",array("expire" => 60));
	 * </code>
	 *
	 * @param string $url Url to your cache server.
	 * @param array $options Array of options
	 */
	public function set_cache($url, $options=array())
	{
		Cache::initialize($url, $options);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Connection.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * The base class for database connection adapters.
 *
 * @package ActiveRecord
 */
abstract class Connection
{
	/**
	 * The \PDO connection object.
	 * @var mixed
	 */
	public $connection;

	/**
	 * The last query run.
	 * @var string
	 */
	public $last_query;

	/**
	 * Switch for logging.
	 *
	 * @var bool
	 */
	 private $logging = false;

	/**
	 * Contains a Logger object that must impelement a log() method.
	 *
	 * @var object
	 */
	private $logger;
	
	/**
	 * The name of the protocol that is used.
	 * @var string
	 */
	public $protocol;

	/**
	 * Default \PDO options to set for each connection.
	 * @var array
	 */
	static $PDO_OPTIONS = array(
		\PDO::ATTR_CASE => \PDO::CASE_LOWER,
		\PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION,
		\PDO::ATTR_ORACLE_NULLS => \PDO::NULL_NATURAL,
		\PDO::ATTR_STRINGIFY_FETCHES => false
	);

	/**
	 * The quote character for stuff like column and field names.
	 * @var string
	 */
	static $QUOTE_CHARACTER = '`';

	/**
	 * Default port.
	 * @var int
	 */
	static $DEFAULT_PORT = 0;

	/**
	 * Retrieve a database connection.
	 *
	 * @param string $connection_string_or_connection_name A database connection string (ex. mysql://user:pass@host[:port]/dbname)
	 *	 Everything after the protocol:// part is specific to the connection adapter.
	 *	 OR
	 *	 A connection name that is set in ActiveRecord\Configuration
	 *	 If null it will use the default connection specified by ActiveRecord\Configuration::$default_connection
	 * @return Connection
	 * @see parse_connection_url
	 */
	public static function instance($connection_string_or_connection_name=null)
	{
		$config = Configuration::instance();

		if (strpos($connection_string_or_connection_name, '://') === false)
		{
			$connection_string = $connection_string_or_connection_name 
				? $config->connection_for($connection_string_or_connection_name) 
				: $config->connection;
		}
		else
			$connection_string = $connection_string_or_connection_name;

		if (!$connection_string)
			throw new DatabaseException("Empty connection string");

		$info = static::parse_connection_url($connection_string);
		$fqclass = static::load_adapter_class($info->protocol);

		try {
			$connection = new $fqclass($info);
			$connection->protocol = $info->protocol;
			$connection->logging = $config->logging;
			$connection->logger = $connection->logging ? $config->logger : null;
			if (isset($info->charset))
				$connection->set_encoding($info->charset);
		} catch (\PDOException $e) {
			throw new DatabaseException($e);
		}
		return $connection;
	}

	/**
	 * Loads the specified class for an adapter.
	 *
	 * @param string $adapter Name of the adapter.
	 * @return string The full name of the class including namespace.
	 */
	private static function load_adapter_class($adapter)
	{
		$class = ucwords($adapter) . 'Adapter';
		$fqclass = 'ActiveRecord\\' . $class;
		return $fqclass;
	}

	/**
	 * Use this for any adapters that can take connection info in the form below
	 * to set the adapters connection info.
	 *
	 * <code>
	 * protocol://username:password@host[:port]/dbname
	 * protocol://urlencoded%20username:urlencoded%20password@host[:port]/dbname?decode=true
	 * protocol://username:password@unix(/some/file/path)/dbname
	 * </code>
	 *
	 * Sqlite has a special syntax, as it does not need a database name 
	 * or user authentication:
	 *
	 * <code>
	 * sqlite://file.db
	 * sqlite://../relative/path/to/file.db
	 * sqlite://unix(/absolute/path/to/file.db)
	 * sqlite://windows(c:/absolute/path/to/file.db)
	 * </code>
	 *
	 * @param string $connection_url A connection URL
	 * @return object the parsed URL as an object.
	 */
	public static function parse_connection_url($connection_url)
	{
		$url = @parse_url($connection_url);

		if (!isset($url['host']))
			throw new DatabaseException(
				'Database host must be specified in the connection string.If you want to specify absolute filenames, use e.g. sqlite://unix(/path/to/file).'
			);

		$info = new \stdClass();
		$info->protocol = $url['scheme'];
		$info->host = $url['host'];
		$info->db = isset($url['path']) ? substr($url['path'],1) : null;
		$info->user = isset($url['user']) ? $url['user'] : null;
		$info->pass = isset($url['pass']) ? $url['pass'] : null;
		
		$allow_blank_db = ($info->protocol == 'sqlite');
		if ($info->host === 'unix(')
		{
			$socket_database = $info->host . '/' . $info->db;
			
			$unix_regex = $allow_blank_db
				? '/^unix\((.+)\)\/?().*$/'
				: '/^unix\((.+)\)\/(.+)$/';
			
			if (preg_match_all($unix_regex, $socket_database, $matches) > 0)
			{
				$info->host = $matches[1][0];
				$info->db = $matches[2][0];
			}
		}
		elseif (substr($info->host,0,8) === 'windows(')
		{
			$info->host = urldecode(substr($info->host,8) . '/' 
				. substr($info->db, 0, -1));
			$info->db = null;
		}
		
		if ($allow_blank_db && $info->db)
			$info->host .= '/' . $info->db;

		if (isset($url['port']))
			$info->port = $url['port'];

		if (strpos($connection_url,'decode=true') !== false)
		{
			if ($info->user)
			$info->user = urldecode($info->user);

			if ($info->pass)
				$info->pass = urldecode($info->pass);
		}
		
		if (isset($url['query']))
		{
			foreach (explode('/&/', $url['query']) as $pair)
			{
				list($name, $value) = explode('=', $pair);

				if ($name == 'charset')
					$info->charset = $value;
			}
		}

		return $info;
	}

	/**
	 * Class Connection is a singleton. Access it via instance().
	 *
	 * @param array $info Array containing URL parts
	 * @return Connection
	 */
	protected function __construct($info)
	{
		try
		{
			// unix sockets start with a /
			if ($info->host[0] != '/')
			{
				$host = "host=$info->host";

				if (isset($info->port))
					$host .= ";port=$info->port";
			}
			else
				$host = "unix_socket=$info->host";

			$this->connection = new \PDO("$info->protocol:$host;dbname=$info->db",$info->user,$info->pass,static::$PDO_OPTIONS);
		} catch (\PDOException $e) {
			throw new DatabaseException($e);
		}
	}

	/**
	 * Retrieves column meta data for the specified table.
	 *
	 * @param string $table Name of a table
	 * @return array An array of {@link Column} objects.
	 */
	public function columns($table)
	{
		$columns = array();
		$sth = $this->query_column_info($table);

		while (($row = $sth->fetch()))
		{
			$c = $this->create_column($row);
			$columns[$c->name] = $c;
		}
		return $columns;
	}

	/**
	 * Escapes quotes in a string.
	 *
	 * @param string $string The string to be quoted.
	 * @return string The string with any quotes in it properly escaped.
	 */
	public function escape($string)
	{
		return $this->connection->quote($string);
	}

	/**
	 * Retrieve the insert id of the last model saved.
	 *
	 * @param string $sequence Optional name of a sequence to use
	 * @return int
	 */
	public function insert_id($sequence=null)
	{
		return $this->connection->lastInsertId($sequence);
	}

	/**
	 * Execute a raw SQL query on the database.
	 *
	 * @param string $sql Raw SQL string to execute.
	 * @param array &$values Optional array of bind values
	 * @return mixed A result set object
	 */
	public function query($sql, &$values=array())
	{
		if ($this->logging)
			$this->logger->log($sql);

		$this->last_query = $sql;

		try {
			if (!($sth = $this->connection->prepare($sql)))
				throw new DatabaseException($this);
		} catch (\PDOException $e) {
			throw new DatabaseException($this);
		}

		$sth->setFetchMode(\PDO::FETCH_ASSOC);

		try {
			if (!$sth->execute($values))
				throw new DatabaseException($this);
		} catch (\PDOException $e) {
			throw new DatabaseException($sth);
		}
		return $sth;
	}

	/**
	 * Execute a query that returns maximum of one row with one field and return it.
	 *
	 * @param string $sql Raw SQL string to execute.
	 * @param array &$values Optional array of values to bind to the query.
	 * @return string
	 */
	public function query_and_fetch_one($sql, &$values=array())
	{
		$sth = $this->query($sql,$values);
		$row = $sth->fetch(\PDO::FETCH_NUM);
		return $row[0];
	}

	/**
	 * Execute a raw SQL query and fetch the results.
	 *
	 * @param string $sql Raw SQL string to execute.
	 * @param \Closure $handler \Closure that will be passed the fetched results.
	 */
	public function query_and_fetch($sql, \Closure $handler)
	{
		$sth = $this->query($sql);

		while (($row = $sth->fetch(\PDO::FETCH_ASSOC)))
			$handler($row);
	}

	/**
	 * Returns all tables for the current database.
	 *
	 * @return array Array containing table names.
	 */
	public function tables()
	{
		$tables = array();
		$sth = $this->query_for_tables();

		while (($row = $sth->fetch(\PDO::FETCH_NUM)))
			$tables[] = $row[0];

		return $tables;
	}

	/**
	 * Starts a transaction.
	 */
	public function transaction()
	{
		if (!$this->connection->beginTransaction())
			throw new DatabaseException($this);
	}

	/**
	 * Commits the current transaction.
	 */
	public function commit()
	{
		if (!$this->connection->commit())
			throw new DatabaseException($this);
	}

	/**
	 * Rollback a transaction.
	 */
	public function rollback()
	{
		if (!$this->connection->rollback())
			throw new DatabaseException($this);
	}

	/**
	 * Tells you if this adapter supports sequences or not.
	 *
	 * @return boolean
	 */
	function supports_sequences() 
	{ 
		return false; 
	}

	/**
	 * Return a default sequence name for the specified table.
	 *
	 * @param string $table Name of a table
	 * @param string $column_name Name of column sequence is for
	 * @return string sequence name or null if not supported.
	 */
	public function get_sequence_name($table, $column_name)
	{
		return "{$table}_seq";
	}

	/**
	 * Return SQL for getting the next value in a sequence.
	 *
	 * @param string $sequence_name Name of the sequence
	 * @return string
	 */
	public function next_sequence_value($sequence_name) 
	{ 
		return null; 
	}

	/**
	 * Quote a name like table names and field names.
	 *
	 * @param string $string String to quote.
	 * @return string
	 */
	public function quote_name($string)
	{
		return $string[0] === static::$QUOTE_CHARACTER || $string[strlen($string)-1] === static::$QUOTE_CHARACTER ?
			$string : static::$QUOTE_CHARACTER . $string . static::$QUOTE_CHARACTER;
	}
	
	/**
	 * Return a date time formatted into the database's date format.
	 *
	 * @param DateTime $datetime The DateTime object
	 * @return string
	 */
	public function date_to_string($datetime)
	{
		return $datetime->format('Y-m-d');
	}

	/**
	 * Return a date time formatted into the database's datetime format.
	 *
	 * @param DateTime $datetime The DateTime object
	 * @return string
	 */
	public function datetime_to_string($datetime)
	{
		return $datetime->format('Y-m-d H:i:s T');
	}

	/**
	 * Converts a string representation of a datetime into a DateTime object.
	 *
	 * @param string $string A datetime in the form accepted by date_create()
	 * @return DateTime
	 */
	public function string_to_datetime($string)
	{
		$date = date_create($string);
		$errors = \DateTime::getLastErrors();

		if ($errors['warning_count'] > 0 || $errors['error_count'] > 0)
			return null;

		return new DateTime($date->format('Y-m-d H:i:s T'));
	}

	/**
	 * Adds a limit clause to the SQL query.
	 *
	 * @param string $sql The SQL statement.
	 * @param int $offset Row offset to start at.
	 * @param int $limit Maximum number of rows to return.
	 * @return string The SQL query that will limit results to specified parameters
	 */
	abstract function limit($sql, $offset, $limit);

	/**
	 * Query for column meta info and return statement handle.
	 *
	 * @param string $table Name of a table
	 * @return \PDOStatement
	 */
	abstract public function query_column_info($table);

	/**
	 * Query for all tables in the current database. The result must only
	 * contain one column which has the name of the table.
	 *
	 * @return \PDOStatement
	 */
	abstract function query_for_tables();
	
	/**
	 * Executes query to specify the character set for this connection.
	 */
	abstract function set_encoding($charset);
	
	/*
	 * Returns an array mapping of native database types
	 */
	abstract public function native_database_types();
	
	/**
	 * Specifies whether or not adapter can use LIMIT/ORDER clauses with DELETE & UPDATE operations
	 *
	 * @internal
	 * @returns boolean (FALSE by default)
	 */
	public function accepts_limit_and_order_for_update_and_delete() 
	{ 
		return false; 
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'DateTime.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * An extension of PHP's DateTime class to provide dirty flagging and easier formatting options.
 *
 * All date and datetime fields from your database will be created as instances of this class.
 *
 * Example of formatting and changing the default format:
 *
 * <code>
 * $now = new ActiveRecord\DateTime('2010-01-02 03:04:05');
 * ActiveRecord\DateTime::$DEFAULT_FORMAT = 'short';
 *
 * echo $now->format(); # 02 Jan 03:04
 * echo $now->format('atom'); # 2010-01-02T03:04:05-05:00
 * echo $now->format('Y-m-d'); # 2010-01-02
 *
 * # __toString() uses the default formatter
 * echo (string)$now; # 02 Jan 03:04
 * </code>
 *
 * You can also add your own pre-defined friendly formatters:
 *
 * <code>
 * ActiveRecord\DateTime::$FORMATS['awesome_format'] = 'H:i:s m/d/Y';
 * echo $now->format('awesome_format') # 03:04:05 01/02/2010
 * </code>
 *
 * @package ActiveRecord
 * @see http://php.net/manual/en/class.datetime.php
 */
class DateTime extends \DateTime
{
	/**
	 * Default format used for format() and __toString()
	 */
	public static $DEFAULT_FORMAT = 'rfc2822';

	/**
	 * Pre-defined format strings.
	 */
	public static $FORMATS = array(
		'db' => 'Y-m-d H:i:s',
		'number' => 'YmdHis',
		'time' => 'H:i',
		'short' => 'd M H:i',
		'long' => 'F d, Y H:i',
		'atom' => \DateTime::ATOM,
		'cookie' => \DateTime::COOKIE,
		'iso8601' => \DateTime::ISO8601,
		'rfc822' => \DateTime::RFC822,
		'rfc850' => \DateTime::RFC850,
		'rfc1036' => \DateTime::RFC1036,
		'rfc1123' => \DateTime::RFC1123,
		'rfc2822' => \DateTime::RFC2822,
		'rfc3339' => \DateTime::RFC3339,
		'rss' => \DateTime::RSS,
		'w3c' => \DateTime::W3C
	);

	private $model;
	private $attribute_name;

	public function attribute_of($model, $attribute_name)
	{
		$this->model = $model;
		$this->attribute_name = $attribute_name;
	}

	/**
	 * Formats the DateTime to the specified format.
	 *
	 * <code>
	 * $datetime->format(); # uses the format defined in DateTime::$DEFAULT_FORMAT
	 * $datetime->format('short'); # d M H:i
	 * $datetime->format('Y-m-d'); # Y-m-d
	 * </code>
	 *
	 * @see FORMATS
	 * @see get_format
	 * @param string $format A format string accepted by get_format()
	 * @return string formatted date and time string
	 */
	public function format($format=null)
	{
		return parent::format(self::get_format($format));
	}

	/**
	 * Returns the format string.
	 *
	 * If $format is a pre-defined format in $FORMATS it will return that otherwise
	 * it will assume $format is a format string itself.
	 *
	 * @see FORMATS
	 * @param string $format A pre-defined string format or a raw format string
	 * @return string a format string
	 */
	public static function get_format($format=null)
	{
		// use default format if no format specified
		if (!$format)
			$format = self::$DEFAULT_FORMAT;

		// format is a friendly
		if (array_key_exists($format, self::$FORMATS))
			return self::$FORMATS[$format];

		// raw format
		return $format;
	}

	public function __toString()
	{
		return $this->format();
	}

	private function flag_dirty()
	{
		if ($this->model)
			$this->model->flag_dirty($this->attribute_name);
	}

	public function setDate($year, $month, $day)
	{
		$this->flag_dirty();
		call_user_func_array(array($this,'parent::setDate'),func_get_args());
	}

	public function setISODate($year, $week , $day=null)
	{
		$this->flag_dirty();
		call_user_func_array(array($this,'parent::setISODate'),func_get_args());
	}

	public function setTime($hour, $minute, $second=null)
	{
		$this->flag_dirty();
		call_user_func_array(array($this,'parent::setTime'),func_get_args());
	}

	public function setTimestamp($unixtimestamp)
	{
		$this->flag_dirty();
		call_user_func_array(array($this,'parent::setTimestamp'),
			func_get_args());
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ConnectionManager.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Singleton to manage any and all database connections.
 *
 * @package ActiveRecord
 */
class ConnectionManager extends Singleton
{
	/**
	 * Array of {@link Connection} objects.
	 * @var array
	 */
	static private $connections = array();

	/**
	 * If $name is null then the default connection will be returned.
	 *
	 * @see Configuration
	 * @param string $name Optional name of a connection
	 * @return Connection
	 */
	public static function get_connection($name=null)
	{
		$config = Configuration::instance();
		$name = $name ?: $config->environment;

		if (!isset(self::$connections[$name]) || !self::$connections[$name]->connection)
			self::$connections[$name] = Connection::instance($config->connection_for($name));

		return self::$connections[$name];
	}
	
	/**
	 * Drops the connection from the connection manager. Does not actually close it since there
	 * is no close method in \PDO.
	 *
	 * @param string $name Name of the connection to forget about
	 */
	public static function drop_connection($name=null)
	{
		if (isset(self::$connections[$name]))
			unset(self::$connections[$name]);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ActiveRecordException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Generic base exception for all ActiveRecord specific errors.
 *
 * @package ActiveRecord
 */
class ActiveRecordException extends \Exception {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'RecordNotFound.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown when a record cannot be found.
 *
 * @package ActiveRecord
 */
class RecordNotFound extends ActiveRecordException {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'DatabaseException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown when there was an error performing a database operation.
 *
 * The error will be specific to whatever database you are running.
 *
 * @package ActiveRecord
 */
class DatabaseException extends ActiveRecordException
{
	public function __construct($adapter_or_string_or_mystery)
	{
		if ($adapter_or_string_or_mystery instanceof Connection)
		{
			parent::__construct(
				join(", ",$adapter_or_string_or_mystery->connection->errorInfo()),
				intval($adapter_or_string_or_mystery->connection->errorCode()));
		}
		elseif ($adapter_or_string_or_mystery instanceof \PDOStatement)
		{
			parent::__construct(
				join(", ",$adapter_or_string_or_mystery->errorInfo()),
				intval($adapter_or_string_or_mystery->errorCode()));
		}
		else
			parent::__construct($adapter_or_string_or_mystery);
	}
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ModelException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown by {@link Model}.
 *
 * @package ActiveRecord
 */
class ModelException extends ActiveRecordException {};
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ExpressionsException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown by {@link Expressions}.
 *
 * @package ActiveRecord
 */
class ExpressionsException extends ActiveRecordException {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'UndefinedPropertyException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown when attempting to access an invalid property on a {@link Model}.
 *
 * @package ActiveRecord
 */
class UndefinedPropertyException extends ModelException
{
	/**
	 * Sets the exception message to show the undefined property's name.
	 *
	 * @param str $property_name name of undefined property
	 * @return void
	 */
	public function __construct($class_name, $property_name)
	{
		if (is_array($property_name))
		{
			$this->message = implode("\r\n", $property_name);
			return;
		}

		$this->message = "Undefined property: {$class_name}->{$property_name} in {$this->file} on line {$this->line}";
		parent::__construct();
	}
};
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ReadOnlyException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown when attempting to perform a write operation on a {@link Model} that is in read-only mode.
 *
 * @package ActiveRecord
 */
class ReadOnlyException extends ModelException
{
	/**
	 * Sets the exception message to show the undefined property's name.
	 *
	 * @param str $class_name name of the model that is read only
	 * @param str $method_name name of method which attempted to modify the model
	 * @return void
	 */
	public function __construct($class_name, $method_name)
	{
		$this->message = "{$class_name}::{$method_name}() cannot be invoked because this model is set to read only";
		parent::__construct();
	}
};
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ValidationsArgumentError.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown for validations exceptions.
 *
 * @package ActiveRecord
 */
class ValidationsArgumentError extends ActiveRecordException {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'RelationshipException.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown for relationship exceptions.
 *
 * @package ActiveRecord
 */
class RelationshipException extends ActiveRecordException {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'HasManyThroughAssociationException.php',
		_strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Thrown for has many thru exceptions.
 *
 * @package ActiveRecord
 */
class HasManyThroughAssociationException extends RelationshipException {};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Expressions.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Templating like class for building SQL statements.
 *
 * Examples:
 * 'name = :name AND author = :author'
 * 'id = IN(:ids)'
 * 'id IN(:subselect)'
 * 
 * @package ActiveRecord
 */
class Expressions
{
	const ParameterMarker = '?';

	private $expressions;
	private $values = array();
	private $connection;

	public function __construct($connection, $expressions=null /* [, $values ... ] */)
	{
		$values = null;
		$this->connection = $connection;

		if (is_array($expressions))
		{
			$glue = func_num_args() > 2 ? func_get_arg(2) : ' AND ';
			list($expressions,$values) = $this->build_sql_from_hash($expressions,$glue);
		}

		if ($expressions != '')
		{
			if (!$values)
				$values = array_slice(func_get_args(),2);

			$this->values = $values;
			$this->expressions = $expressions;
		}
	}

	/**
	 * Bind a value to the specific one based index. There must be a bind marker
	 * for each value bound or to_s() will throw an exception.
	 */
	public function bind($parameter_number, $value)
	{
		if ($parameter_number <= 0)
			throw new ExpressionsException("Invalid parameter index: $parameter_number");

		$this->values[$parameter_number-1] = $value;
	}

	public function bind_values($values)
	{
		$this->values = $values;
	}

	/**
	 * Returns all the values currently bound.
	 */
	public function values()
	{
		return $this->values;
	}

	/**
	 * Returns the connection object.
	 */
	public function get_connection()
	{
		return $this->connection;
	}

	/**
	 * Sets the connection object. It is highly recommended to set this so we can
	 * use the adapter's native escaping mechanism.
	 *
	 * @param string $connection a Connection instance
	 */
	public function set_connection($connection)
	{
		$this->connection = $connection;
	}

	public function to_s($substitute=false, &$options=null)
	{
		if (!$options) $options = array();
		
		$values = array_key_exists('values',$options) ? $options['values'] : $this->values;

		$ret = "";
		$replace = array();
		$num_values = count($values);
		$len = strlen($this->expressions);
		$quotes = 0;

		for ($i=0,$n=strlen($this->expressions),$j=0; $i<$n; ++$i)
		{
			$ch = $this->expressions[$i];

			if ($ch == self::ParameterMarker)
			{
				if ($quotes % 2 == 0)
				{
					if ($j > $num_values-1)
						throw new ExpressionsException("No bound parameter for index $j");

					$ch = $this->substitute($values,$substitute,$i,$j++);
				}
			}
			elseif ($ch == '\'' && $i > 0 && $this->expressions[$i-1] != '\\')
				++$quotes;

			$ret .= $ch;
		}
		return $ret;
	}

	private function build_sql_from_hash(&$hash, $glue)
	{
		$sql = $g = "";

		foreach ($hash as $name => $value)
		{
			if ($this->connection)
				$name = $this->connection->quote_name($name);

			if (is_array($value))
				$sql .= "$g$name IN(?)";
			else
				$sql .= "$g$name=?";

			$g = $glue;
		}
		return array($sql,array_values($hash));
	}

	private function substitute(&$values, $substitute, $pos, $parameter_index)
	{
		$value = $values[$parameter_index];

		if (is_array($value))
		{
			if ($substitute)
			{
				$ret = '';

				for ($i=0,$n=count($value); $i<$n; ++$i)
					$ret .= ($i > 0 ? ',' : '') . $this->stringify_value($value[$i]);

				return $ret;
			}
			return join(',',array_fill(0,count($value),self::ParameterMarker));
		}

		if ($substitute)
			return $this->stringify_value($value);

		return $this->expressions[$pos];
	}

	private function stringify_value($value)
	{
		if (is_null($value))
			return "NULL";

		return is_string($value) ? $this->quote_string($value) : $value;
	}

	private function quote_string($value)
	{
		if ($this->connection)
			return $this->connection->escape($value);

		return "'" . str_replace("'","''",$value) . "'";
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Inflector.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * @package ActiveRecord
 */
abstract class Inflector
{
	/**
	 * Get an instance of the {@link Inflector} class.
	 *
	 * @return object
	 */
	public static function instance()
	{
		return new StandardInflector();
	}

	/**
	 * Turn a string into its camelized version.
	 *
	 * @param string $s string to convert
	 * @return string
	 */
	public function camelize($s)
	{
		$s = preg_replace('/[_-]+/','_',trim($s));
		$s = str_replace(' ', '_', $s);

		$camelized = '';

		for ($i=0,$n=strlen($s); $i<$n; ++$i)
		{
			if ($s[$i] == '_' && $i+1 < $n)
				$camelized .= strtoupper($s[++$i]);
			else
				$camelized .= $s[$i];
		}

		$camelized = trim($camelized,' _');

		if (strlen($camelized) > 0)
			$camelized[0] = strtolower($camelized[0]);

		return $camelized;
	}

	/**
	 * Determines if a string contains all uppercase characters.
	 *
	 * @param string $s string to check
	 * @return bool
	 */
	public static function is_upper($s)
	{
		return (strtoupper($s) === $s);
	}

	/**
	 * Determines if a string contains all lowercase characters.
	 *
	 * @param string $s string to check
	 * @return bool
	 */
	public static function is_lower($s)
	{
		return (strtolower($s) === $s);
	}

	/**
	 * Convert a camelized string to a lowercase, underscored string.
	 *
	 * @param string $s string to convert
	 * @return string
	 */
	public function uncamelize($s)
	{
		$normalized = '';

		for ($i=0,$n=strlen($s); $i<$n; ++$i)
		{
			if (ctype_alpha($s[$i]) && self::is_upper($s[$i]))
				$normalized .= '_' . strtolower($s[$i]);
			else
				$normalized .= $s[$i];
		}
		return trim($normalized,' _');
	}
	
	public function keyify($class_name)
	{
		return strtolower(
			$this->underscorify(denamespace($class_name))
		) . '_id';
	}

	/**
	 * Convert a string with space into a underscored equivalent.
	 *
	 * @param string $s string to convert
	 * @return string
	 */
	public function underscorify($s)
	{
		return preg_replace(array('/[_\- ]+/','/([a-z])([A-Z])/'),array('_','\\1_\\2'),trim($s));
	}

	abstract function variablize($s);
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'StandardInflector.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * @package ActiveRecord
 */
class StandardInflector extends Inflector
{
	public function tableize($s) 
	{ 
		return Utils::pluralize(strtolower($this->underscorify($s))); 
	}
	
	public function variablize($s) 
	{ 
		return str_replace(
			array('-',' '),
			array('_','_'),
			$this->uncamelize(trim($s))
		);	   
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Model.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * The base class for your models.
 *
 * Defining an ActiveRecord model for a table called people and orders:
 *
 * <code>
 * CREATE TABLE people(
 *	 id int primary key auto_increment,
 *	 parent_id int,
 *	 first_name varchar(50),
 *	 last_name varchar(50)
 * );
 *
 * CREATE TABLE orders(
 *	 id int primary key auto_increment,
 *	 person_id int not null,
 *	 cost decimal(10,2),
 *	 total decimal(10,2)
 * );
 * </code>
 *
 * <code>
 * class Person extends ActiveRecord\Model {
 *	 static $belongs_to = array(
 *	   array('parent', 'foreign_key' => 'parent_id', 'class_name' => 'Person')
 *	 );
 *
 *	 static $has_many = array(
 *	   array('children', 'foreign_key' => 'parent_id', 'class_name' => 'Person'),
 *	   array('orders')
 *	 );
 *
 *	 static $validates_length_of = array(
 *	   array('first_name', 'within' => array(1,50)),
 *	   array('last_name', 'within' => array(1,50))
 *	 );
 * }
 *
 * class Order extends ActiveRecord\Model {
 *	 static $belongs_to = array(
 *	   array('person')
 *	 );
 *
 *	 static $validates_numericality_of = array(
 *	   array('cost', 'greater_than' => 0),
 *	   array('total', 'greater_than' => 0)
 *	 );
 *
 *	 static $before_save = array('calculate_total_with_tax');
 *
 *	 public function calculate_total_with_tax() {
 *	   $this->total = $this->cost * 0.045;
 *	 }
 * }
 * </code>
 *
 * For a more in-depth look at defining models, relationships, callbacks and many other things
 * please consult our {@link http://www.phpactiverecord.org/guides Guides}.
 *
 * @package ActiveRecord
 * @see BelongsTo
 * @see CallBack
 * @see HasMany
 * @see HasAndBelongsToMany
 * @see Serialization
 * @see Validations
 */
class Model
{
	/**
	 * An instance of {@link Errors} and will be instantiated once a write method is called.
	 *
	 * @var Errors
	 */
	public $errors;

	/**
	 * Contains model values as column_name => value
	 *
	 * @var array
	 */
	private $attributes = array();

	/**
	 * Flag whether or not this model's attributes have been modified since it will either be null or an array of column_names that have been modified
	 *
	 * @var array
	 */
	private $__dirty = null;

	/**
	 * Flag that determines of this model can have a writer method invoked such as: save/update/insert/delete
	 *
	 * @var boolean
	 */
	private $__readonly = false;

	/**
	 * Array of relationship objects as model_attribute_name => relationship
	 *
	 * @var array
	 */
	private $__relationships = array();

	/**
	 * Flag that determines if a call to save() should issue an insert or an update sql statement
	 *
	 * @var boolean
	 */
	private $__new_record = true;

	/**
	 * Set to the name of the connection this {@link Model} should use.
	 *
	 * @var string
	 */
	static $connection;

	/**
	 * Set to the name of the database this Model's table is in.
	 *
	 * @var string
	 */
	static $db;

	/**
	 * Set this to explicitly specify the model's table name if different from inferred name.
	 *
	 * If your table doesn't follow our table name convention you can set this to the
	 * name of your table to explicitly tell ActiveRecord what your table is called.
	 *
	 * @var string
	 */
	static $table_name;

	/**
	 * Set this to override the default primary key name if different from default name of "id".
	 *
	 * @var string
	 */
	static $primary_key;

	/**
	 * Set this to explicitly specify the sequence name for the table.
	 *
	 * @var string
	 */
	static $sequence;

	/**
	 * Allows you to create aliases for attributes.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $alias_attribute = array(
	 *	   'the_first_name' => 'first_name',
	 *	   'the_last_name' => 'last_name');
	 * }
	 *
	 * $person = Person::first();
	 * $person->the_first_name = 'Tito';
	 * echo $person->the_first_name;
	 * </code>
	 *
	 * @var array
	 */
	static $alias_attribute = array();

	/**
	 * Whitelist of attributes that are checked from mass-assignment calls such as constructing a model or using update_attributes.
	 *
	 * This is the opposite of {@link attr_protected $attr_protected}.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $attr_accessible = array('first_name','last_name');
	 * }
	 *
	 * $person = new Person(array(
	 *	 'first_name' => 'Tito',
	 *	 'last_name' => 'the Grief',
	 *	 'id' => 11111));
	 *
	 * echo $person->id; # => null
	 * </code>
	 *
	 * @var array
	 */
	static $attr_accessible = array();

	/**
	 * Blacklist of attributes that cannot be mass-assigned.
	 *
	 * This is the opposite of {@link attr_accessible $attr_accessible} and the format
	 * for defining these are exactly the same.
	 * Notice: The attribute 'id' never can be mass-assigned. This change is 
	 * added here for Pragwork as a security improvement. (SW)
	 *
	 * @var array
	 */
	static $attr_protected = array();

	/**
	 * Delegates calls to a relationship.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $belongs_to = array(array('venue'),array('host'));
	 *	 static $delegate = array(
	 *	   array('name', 'state', 'to' => 'venue'),
	 *	   array('name', 'to' => 'host', 'prefix' => 'woot'));
	 * }
	 * </code>
	 *
	 * Can then do:
	 *
	 * <code>
	 * $person->state	  # same as calling $person->venue->state
	 * $person->name	  # same as calling $person->venue->name
	 * $person->woot_name # same as calling $person->host->name
	 * </code>
	 *
	 * @var array
	 */
	static $delegate = array();

	
	/**
	 * Constructs a model.
	 *
	 * When a user instantiates a new object (e.g.: it was not ActiveRecord that instantiated via a find)
	 * then @var $attributes will be mapped according to the schema's defaults. Otherwise, the given
	 * $attributes will be mapped via set_attributes_via_mass_assignment.
	 *
	 * <code>
	 * new Person(array('first_name' => 'Tito', 'last_name' => 'the Grief'));
	 * </code>
	 *
	 * @param array $attributes Hash containing names and values to mass assign to the model
	 * @param boolean $guard_attributes Set to true to guard attributes
	 * @param boolean $instantiating_via_find Set to true if this model is being created from a find call
	 * @param boolean $new_record Set to true if this should be considered a new record
	 * @return Model
	 */
	public function __construct($attributes=array(), $guard_attributes=true,
		$instantiating_via_find=false, $new_record=true)
	{
		$this->__new_record = $new_record;
		
		// initialize attributes applying defaults
		if (!$instantiating_via_find)
		{
			foreach (static::table()->columns as $name => $meta)
				$this->attributes[$meta->inflected_name] = $meta->default;
		}

		$this->set_attributes_via_mass_assignment($attributes,	
			$guard_attributes);

		// since all attribute assignment now goes thru assign_attributes() we want to reset
		// dirty if instantiating via find since nothing is really dirty when doing that
		if ($instantiating_via_find)
			$this->__dirty = array();

		$this->invoke_callback('after_construct',false);
	}

	/**
	 * Magic method which delegates to read_attribute(). This handles firing off getter methods,
	 * as they are not checked/invoked inside of read_attribute(). This circumvents the problem with
	 * a getter being accessed with the same name as an actual attribute.
	 *
	 * You can also define customer getter methods for the model.
	 *
	 * EXAMPLE:
	 *
	 * <code>
	 * class User extends ActiveRecord\Model {
	 *
	 * # define custom getter methods. Note you must
	 * # prepend get_ to your method name:
	 * function get_middle_initial() {
	 * return $this->middle_name{0};
	 * }
	 * }
	 *
	 * $user = new User();
	 * echo $user->middle_name; # will call $user->get_middle_name()
	 * </code>
	 *
	 * If you define a custom getter with the same name as an attribute then you
	 * will need to use read_attribute() to get the attribute's value.
	 * This is necessary due to the way __get() works.
	 *
	 * For example, assume 'name' is a field on the table and we're defining a
	 * custom getter for 'name':
	 *
	 * <code>
	 * class User extends ActiveRecord\Model {
	 *
	 * # INCORRECT way to do it
	 * # function get_name() {
	 * # return strtoupper($this->name);
	 * # }
	 * 
	 * function get_name() {
	 * return strtoupper($this->read_attribute('name'));
	 * }
	 * }
	 *
	 * $user = new User();
	 * $user->name = 'bob';
	 * echo $user->name; # => BOB
	 * </code>
	 *
	 *
	 * @see read_attribute()
	 * @param string $name Name of an attribute
	 * @return mixed The value of the attribute
	 */
	public function &__get($name)
	{
		// check for getter
		if (method_exists($this, "get_$name"))
		{
			$name = "get_$name";
			$value = $this->$name();
			return $value;
		}

		return $this->read_attribute($name);
	}

	/**
	 * Determines if an attribute exists for this {@link Model}.
	 *
	 * @param string $attribute_name
	 * @return boolean
	 */
	public function __isset($attribute_name)
	{
		return array_key_exists($attribute_name,$this->attributes) || array_key_exists($attribute_name,static::$alias_attribute);
	}

	/**
	 * Magic allows un-defined attributes to set via $attributes.
	 *
	 * You can also define customer setter methods for the model.
	 *
	 * EXAMPLE:
	 *
	 * <code>
	 * class User extends ActiveRecord\Model 
	 * {
	 *
	 *     # define custom setter methods. Note you must
	 *     # prepend set_ to your method name:
	 *     function set_password($plaintext) 
	 *     {
	 *         $this->encrypted_password = md5($plaintext);
	 *     }
	 * }
	 *
	 * $user = new User();
	 * $user->password = 'plaintext'; # will call $user->set_password('plaintext')
	 * </code>
	 *
	 * If you define a custom setter with the same name as an attribute then you
	 * will need to use assign_attribute() to assign the value to the attribute.
	 * This is necessary due to the way __set() works.
	 *
	 * For example, assume 'name' is a field on the table and we're defining a
	 * custom setter for 'name':
	 *
	 * <code>
	 * class User extends ActiveRecord\Model 
	 * {
	 *
	 *     # INCORRECT way to do it
	 *     # function set_name($name) {
	 *     # $this->name = strtoupper($name);
	 *     # }
	 *
	 *     function set_name($name) 
	 *     {
	 *         $this->assign_attribute('name',strtoupper($name));
	 *     }
	 * }
	 *
	 * $user = new User();
	 * $user->name = 'bob';
	 * echo $user->name; # => BOB
	 * </code>
	 *
	 * @throws {@link UndefinedPropertyException} if $name does not exist
	 * @param string $name Name of attribute, relationship or other to set
	 * @param mixed $value The value
	 * @return mixed The value
	 */
	public function __set($name, $value)
	{
		if (array_key_exists($name, static::$alias_attribute))
			$name = static::$alias_attribute[$name];
		elseif (method_exists($this,"set_$name"))
		{
			$name = "set_$name";
			return $this->$name($value);
		}

		if (array_key_exists($name,$this->attributes))
			return $this->assign_attribute($name,$value);

		if ($name == 'id')
			return $this->assign_attribute($this->get_primary_key(true),$value);

		foreach (static::$delegate as &$item)
		{
			if (($delegated_name = $this->is_delegated($name,$item)))
				return $this->$item['to']->$delegated_name = $value;
		}

		throw new UndefinedPropertyException(get_called_class(),$name);
	}
	
	public function __wakeup()
	{
		// make sure the models Table instance gets initialized when waking up
		static::table();
	}

	/**
	 * Assign a value to an attribute.
	 *
	 * @param string $name Name of the attribute
	 * @param mixed $value Value of the attribute
	 * @return mixed the attribute value
	 */
	public function assign_attribute($name, $value)
	{
		$table = static::table();

		if (array_key_exists($name,$table->columns) && !is_object($value))
			$value = $table->columns[$name]->cast($value,static::connection());

		// convert php's \DateTime to ours
		if ($value instanceof \DateTime)
			$value = new DateTime($value->format('Y-m-d H:i:s T'));

		// make sure DateTime values know what model they belong to so
		// dirty stuff works when calling set methods on the DateTime object
		if ($value instanceof DateTime)
			$value->attribute_of($this,$name);
		
		$this->attributes[$name] = $value;
		$this->flag_dirty($name);
		return $value;
	}

	/**
	 * Retrieves an attribute's value or a relationship object based on the name passed. If the attribute
	 * accessed is 'id' then it will return the model's primary key no matter what the actual attribute name is
	 * for the primary key.
	 *
	 * @param string $name Name of an attribute
	 * @return mixed The value of the attribute
	 * @throws {@link UndefinedPropertyException} if name could not be resolved to an attribute, relationship, ...
	 */
	public function &read_attribute($name)
	{
		// check for aliased attribute
		if (array_key_exists($name, static::$alias_attribute))
			$name = static::$alias_attribute[$name];

		// check for attribute
		if (array_key_exists($name,$this->attributes))
			return $this->attributes[$name];

		// check relationships if no attribute
		if (array_key_exists($name,$this->__relationships))
			return $this->__relationships[$name];

		$table = static::table();

		// this may be first access to the relationship so check Table
		if (($relationship = $table->get_relationship($name)))
		{
			$this->__relationships[$name] = $relationship->load($this);
			return $this->__relationships[$name];
		}

		if ($name == 'id')
		{
			$pk = $this->get_primary_key(true);
			if (isset($this->attributes[$pk]))
				return $this->attributes[$pk];
		}

		$value = null;
		
		foreach (static::$delegate as &$item)
		{
			if ($delegated_name = $this->is_delegated($name, $item))
			{
				$to = $item['to'];
				
				if ($this->$to)
					$value =& $this->$to->__get($delegated_name);
				
				return $value;
			}
		}

		throw new UndefinedPropertyException(get_called_class(),$name);
	}
	
	/**
	 * Flags an attribute as dirty.
	 *
	 * @param string $name Attribute name
	 */
	public function flag_dirty($name)
	{
		if (!$this->__dirty)
			$this->__dirty = array();

		$this->__dirty[$name] = true;
	}

	/**
	 * Returns hash of attributes that have been modified since loading the model.
	 *
	 * @return mixed null if no dirty attributes otherwise returns array of dirty attributes.
	 */
	public function dirty_attributes()
	{
		if (!$this->__dirty)
			return null;

		$dirty = array_intersect_key($this->attributes,$this->__dirty);
		return !empty($dirty) ? $dirty : null;
	}
	
	/**
	 * Check if a particular attribute has been modified since loading the model.
	 * @param string $attribute Name of the attribute
	 * @return bool True if it has been modified.
	 */
	public function attribute_is_dirty($attribute)
	{
		return $this->__dirty && $this->__dirty[$attribute] 
			&& array_key_exists($attribute, $this->attributes);
	}

	/**
	 * Returns a copy of the model's attributes hash.
	 *
	 * @return array A copy of the model's attribute data
	 */
	public function attributes()
	{
		return $this->attributes;
	}

	/**
	 * Retrieve the primary key name.
	 *
	 * @param boolean Set to true to return the first value in the pk array only
	 * @return string The primary key for the model
	 */
	public function get_primary_key($first=false)
	{
		$pk = static::table()->pk;
		return $first ? $pk[0] : $pk;
	}
	
	/**
	 * Returns the actual attribute name if $name is aliased.
	 *
	 * @param string $name An attribute name
	 * @return string
	 */
	public function get_real_attribute_name($name)
	{
		if (array_key_exists($name,$this->attributes))
			return $name;

		if (array_key_exists($name,static::$alias_attribute))
			return static::$alias_attribute[$name];

		return null;
	}

	/**
	 * Returns array of validator data for this Model.
	 *
	 * Will return an array looking like:
	 *
	 * <code>
	 * array(
	 *	 'name' => array(
	 *	   array('validator' => 'validates_presence_of'),
	 *	   array('validator' => 'validates_inclusion_of', 'in' => array('Bob','Joe','John')),
	 *	 'password' => array(
	 *	   array('validator' => 'validates_length_of', 'minimum' => 6))
	 *	 )
	 * );
	 * </code>
	 *
	 * @return array An array containing validator data for this model.
	 */
	public function get_validation_rules()
	{
		$validator = new Validations($this);
		return $validator->rules();
	}

	/**
	 * Returns an associative array containing values for all the attributes in 
	 * $attributes.
	 *
	 * @param array $attributes Array containing attribute names
	 * @return array A hash containing <code>$name => $value</code>
	 */
	public function get_values_for($attributes)
	{
		$ret = array();

		foreach ($attributes as $name)
		{
			if (array_key_exists($name,$this->attributes))
				$ret[$name] = $this->attributes[$name];
		}
		return $ret;
	}

	/**
	 * Retrieves the name of the table for this Model.
	 *
	 * @return string
	 */
	public static function table_name()
	{
		return static::table()->table;
	}

	/**
	 * Returns the attribute name on the delegated relationship if $name is
	 * delegated or null if not delegated.
	 *
	 * @param string $name Name of an attribute
	 * @param array $delegate An array containing delegate data
	 * @return delegated attribute name or null
	 */
	private function is_delegated($name, &$delegate)
	{
		if ($delegate['prefix'] != '')
			$name = substr($name,strlen($delegate['prefix'])+1);

		if (is_array($delegate) && in_array($name,$delegate['delegate']))
			return $name;

		return null;
	}

	/**
	 * Determine if the model is in read-only mode.
	 *
	 * @return boolean
	 */
	public function is_readonly()
	{
		return $this->__readonly;
	}

	/**
	 * Determine if the model is a new record.
	 *
	 * @return boolean
	 */
	public function is_new_record()
	{
		return $this->__new_record;
	}

	/**
	 * Throws an exception if this model is set to readonly.
	 *
	 * @throws ActiveRecord\ReadOnlyException
	 * @param string $method_name Name of method that was invoked on model for exception message
	 */
	private function verify_not_readonly($method_name)
	{
		if ($this->is_readonly())
			throw new ReadOnlyException(get_class($this), $method_name);
	}

	/**
	 * Flag model as readonly.
	 *
	 * @param boolean $readonly Set to true to put the model into readonly mode
	 */
	public function readonly($readonly=true)
	{
		$this->__readonly = $readonly;
	}

	/**
	 * Retrieve the connection for this model.
	 *
	 * @return Connection
	 */
	public static function connection()
	{
		return static::table()->conn;
	}
	
	/**
	 * Re-establishes the database connection with a new connection.
	 *
	 * @return Connection
	 */
	public static function reestablish_connection()
	{
		return static::table()->reestablish_connection();
	}

	/**
	 * Returns the {@link Table} object for this model.
	 *
	 * Be sure to call in static scoping: static::table()
	 *
	 * @return Table
	 */
	public static function table()
	{
		return Table::load(get_called_class());
	}

	/**
	 * Creates a model and saves it to the database.
	 *
	 * @param array $attributes Array of the models attributes
	 * @param boolean $validate True if the validators should be run
	 * @return Model
	 */
	public static function create($attributes, $validate=true)
	{
		$class_name = get_called_class();
		$model = new $class_name($attributes);
		$model->save($validate);
		return $model;
	}

	/**
	 * Save the model to the database.
	 *
	 * This function will automatically determine if an INSERT or UPDATE needs to occur.
	 * If a validation or a callback for this model returns false, then the model will
	 * not be saved and this will return false.
	 *
	 * If saving an existing model only data that has changed will be saved.
	 *
	 * @param boolean $validate Set to true or false depending on if you want the validators to run or not
	 * @return boolean True if the model was saved to the database otherwise false
	 */
	public function save($validate=true)
	{
		$this->verify_not_readonly('save');
		return $this->is_new_record() ? $this->insert($validate) : $this->update($validate);
	}

	/**
	 * Issue an INSERT sql statement for this model's attribute.
	 *
	 * @see save
	 * @param boolean $validate Set to true or false depending on if you want the validators to run or not
	 * @return boolean True if the model was saved to the database otherwise false
	 */
	private function insert($validate=true)
	{
		$this->verify_not_readonly('insert');

		if ($validate && !$this->_validate() 
			|| !$this->invoke_callback('before_create',false))
			return false;

		$table = static::table();

		if (!($attributes = $this->dirty_attributes()))
			$attributes = $this->attributes;

		$pk = $this->get_primary_key(true);
		$use_sequence = false;

		if ($table->sequence && !isset($attributes[$pk]))
		{
			if (($conn = static::connection()) instanceof OciAdapter)
			{
				// terrible oracle makes us select the nextval first
				$attributes[$pk] = $conn->get_next_sequence_value($table->sequence);
				$table->insert($attributes);
				$this->attributes[$pk] = $attributes[$pk];
			}
			else
			{
				// unset pk that was set to null
				if (array_key_exists($pk,$attributes))
					unset($attributes[$pk]);

				$table->insert($attributes,$pk,$table->sequence);
				$use_sequence = true;
			}
		}
		else
			$table->insert($attributes);

		// if we've got an autoincrementing/sequenced pk set it
		// don't need this check until the day comes that we decide to support composite pks
		// if (count($pk) == 1)
		{
			$column = $table->get_column_by_inflected_name($pk);

			if ($column->auto_increment || $use_sequence)
				$this->attributes[$pk] =
					static::connection()->insert_id($table->sequence);
		}

		$this->invoke_callback('after_create',false);
		$this->__new_record = false;
		return true;
	}

	/**
	 * Issue an UPDATE sql statement for this model's dirty attributes.
	 *
	 * @see save
	 * @param boolean $validate Set to true or false depending on if you want the validators to run or not
	 * @return boolean True if the model was saved to the database otherwise false
	 */
	private function update($validate=true)
	{
		$this->verify_not_readonly('update');

		if ($validate && !$this->_validate())
			return false;

		if ($this->is_dirty())
		{
			$pk = $this->values_for_pk();

			if (empty($pk))
				throw new ActiveRecordException("Cannot update, no primary key defined for: " . get_called_class());

			if (!$this->invoke_callback('before_update',false))
				return false;
			$dirty = $this->dirty_attributes();
			static::table()->update($dirty,$pk);
			$this->invoke_callback('after_update',false);
		}

		return true;
	}
	
	/**
	 * Deletes records matching conditions in $options
	 *
	 * Does not instantiate models and therefore does not invoke callbacks
	 *
	 * Delete all using a hash:
	 *
	 * <code>
	 * YourModel::delete_all(array('conditions' => array('name' => 'Tito')));
	 * </code>
	 *
	 * Delete all using an array:
	 *
	 * <code>
	 * YourModel::delete_all(array('conditions' => array('name = ?', 'Tito')));
	 * </code>
	 *
	 * Delete all using a string:
	 *
	 * <code>
	 * YourModel::delete_all(array('conditions' => 'name = "Tito"));
	 * </code>
	 *
	 * An options array takes the following parameters:
	 *
	 * <ul>
	 * <li><b>conditions:</b> Conditions using a string/hash/array</li>
	 * <li><b>limit:</b> Limit number of records to delete (MySQL & Sqlite only)</li>
	 * <li><b>order:</b> A SQL fragment for ordering such as: 'name asc', 'id desc, name asc' (MySQL & Sqlite only)</li>
	 * </ul>
	 *
	 * @params array $options
	 * return integer Number of rows affected
	 */
	public static function delete_all($options=array())
	{
		$table = static::table();
		$conn = static::connection();
		$sql = new SQLBuilder($conn, $table->get_fully_qualified_table_name());

		$conditions = is_array($options) ? $options['conditions'] : $options;

		if (is_array($conditions) && !is_hash($conditions))
			call_user_func_array(array($sql, 'delete'), $conditions);
		else
			$sql->delete($conditions);

		if (isset($options['limit']))
			$sql->limit($options['limit']);

		if (isset($options['order']))
			$sql->order($options['order']);

		$values = $sql->bind_values();
		$ret = $conn->query(($table->last_sql = $sql->to_s()), $values);
		return $ret->rowCount();
	}

	/**
	 * Updates records using set in $options
	 *
	 * Does not instantiate models and therefore does not invoke callbacks
	 *
	 * Update all using a hash:
	 *
	 * <code>
	 * YourModel::update_all(array('set' => array('name' => "Bob")));
	 * </code>
	 *
	 * Update all using a string:
	 *
	 * <code>
	 * YourModel::update_all(array('set' => 'name = "Bob"'));
	 * </code>
	 *
	 * An options array takes the following parameters:
	 *
	 * <ul>
	 * <li><b>set:</b> String/hash of field names and their values to be updated with
	 * <li><b>conditions:</b> Conditions using a string/hash/array</li>
	 * <li><b>limit:</b> Limit number of records to update (MySQL & Sqlite only)</li>
	 * <li><b>order:</b> A SQL fragment for ordering such as: 'name asc', 'id desc, name asc' (MySQL & Sqlite only)</li>
	 * </ul>
	 *
	 * @params array $options
	 * return integer Number of rows affected
	 */
	public static function update_all($options=array())
	{
		$table = static::table();
		$conn = static::connection();
		$sql = new SQLBuilder($conn, $table->get_fully_qualified_table_name());

		$sql->update($options['set']);

		if (isset($options['conditions']) 
			&& ($conditions = $options['conditions']))
		{
			if (is_array($conditions) && !is_hash($conditions))
				call_user_func_array(array($sql, 'where'), $conditions);
			else
				$sql->where($conditions);
		}

		if (isset($options['limit']))
			$sql->limit($options['limit']);

		if (isset($options['order']))
			$sql->order($options['order']);

		$values = $sql->bind_values();
			$ret = $conn->query(($table->last_sql = $sql->to_s()), $values);
		
		return $ret->rowCount();
	}

	/**
	 * Deletes this model from the database and returns true if successful.
	 *
	 * @return boolean
	 */
	public function delete()
	{
		$this->verify_not_readonly('delete');

		$pk = $this->values_for_pk();

		if (empty($pk))
			throw new ActiveRecordException("Cannot delete, no primary key defined for: " . get_called_class());

		if (!$this->invoke_callback('before_destroy',false))
			return false;
		static::table()->delete($pk);
		$this->invoke_callback('after_destroy',false);

		return true;
	}

	/**
	 * Helper that creates an array of values for the primary key(s).
	 *
	 * @return array An array in the form array(key_name => value, ...)
	 */
	public function values_for_pk()
	{
		return $this->values_for(static::table()->pk);
	}

	/**
	 * Helper to return a hash of values for the specified attributes.
	 *
	 * @param array $attribute_names Array of attribute names
	 * @return array An array in the form array(name => value, ...)
	 */
	public function values_for($attribute_names)
	{
		$filter = array();

		foreach ($attribute_names as $name)
			$filter[$name] = $this->$name;

		return $filter;
	}

	/**
	 * Validates the model.
	 *
	 * @return boolean True if passed validators otherwise false
	 */
	private function _validate()
	{
		$validator = new Validations($this);
		$validation_on = 'validation_on_' . ($this->is_new_record() ? 'create' : 'update');

		foreach (array('before_validation', "before_$validation_on") as $callback)
		{
			if ($this->invoke_callback($callback,false) === false)
				return false;
		}

		// need to store reference b4 validating so that custom validators have access to add errors
		$this->errors = $validator->get_record();
		$validator->validate();

		foreach (array('after_validation', "after_$validation_on") as $callback)
			$this->invoke_callback($callback,false);

		if (!$this->errors->is_empty())
			return false;

		return true;
	}

	/**
	 * Returns true if the model has been modified.
	 *
	 * @return boolean true if modified
	 */
	public function is_dirty()
	{
		return empty($this->__dirty) ? false : true;
	}

	/**
	 * Run validations on model and returns whether or not model passed validation.
	 *
	 * @see is_invalid
	 * @return boolean
	 */
	public function is_valid()
	{
		return $this->_validate();
	}

	/**
	 * Runs validations and returns true if invalid.
	 *
	 * @see is_valid
	 * @return boolean
	 */
	public function is_invalid()
	{
		return !$this->_validate();
	}

	/**
	 * Updates a model's timestamps.
	 */
	public function set_timestamps()
	{
		$now = date('Y-m-d H:i:s');

		if (isset($this->updated_at))
			$this->updated_at = $now;

		if (isset($this->created_at) && $this->is_new_record())
			$this->created_at = $now;
	}

	/**
	 * Mass update the model with an array of attribute data and saves to the database.
	 *
	 * @param mixed $attributes An attribute data array in the form array(name => value, ...) or an Application\Parameters object
	 * @return boolean True if successfully updated and saved otherwise false
	 */
	public function update_attributes($attributes)
	{
		$this->set_attributes($attributes);
		return $this->save();
	}

	/**
	 * Updates a single attribute and saves the record without going through the normal validation procedure.
	 *
	 * @param string $name Name of attribute
	 * @param mixed $value Value of the attribute
	 * @return boolean True if successful otherwise false
	 */
	public function update_attribute($name, $value)
	{
		$this->__set($name, $value);
		return $this->update(false);
	}

	/**
	 * Mass update the model with data from an attributes hash.
	 *
	 * Unlike update_attributes() this method only updates the model's data
	 * but DOES NOT save it to the database.
	 *
	 * @see update_attributes
	 * @param mixed $attributes An array containing data to update in the form array(name => value, ...) or an Application\Parameters object
	 */
	public function set_attributes($attributes)
	{
		$this->set_attributes_via_mass_assignment($attributes, true);
	}

	/**
	 * Passing $guard_attributes as true will throw an exception if an attribute does not exist.
	 *
	 * @throws ActiveRecord\UndefinedPropertyException
	 * @param mixed $attributes An array in the form array(name => value, ...)
	 *	   or the 'Application\Parameters' instance
	 * @param boolean $guard_attributes Flag of whether or not attributes should be guarded
	 */
	private function set_attributes_via_mass_assignment(&$attributes, $guard_attributes)
	{
		//access uninflected columns since that is what we would have in result set
		$table = static::table();
		$exceptions = array();
		$use_attr_accessible = !empty(static::$attr_accessible);
		$use_attr_protected = !empty(static::$attr_protected);
		$connection = static::connection();
		
		foreach ($attributes as $name => $value)
		{	
			// is a normal field on the table
			if (array_key_exists($name,$table->columns))
			{
				$value = $table->columns[$name]->cast($value,$connection);
				$name = $table->columns[$name]->inflected_name;
			}

			if ($guard_attributes)
			{
				if ($name === 'id')
					continue;
				
				if ($use_attr_accessible)
				{
					if (is_array(static::$attr_accessible))
					{
						if (!in_array($name, static::$attr_accessible))
							continue;
					}
					elseif ($name !== static::$attr_accessible)
						continue;
				}
				
				if ($use_attr_protected)
				{
					if (is_array(static::$attr_protected))
					{
						if (in_array($name,static::$attr_protected))
							continue;
					}
					elseif ($name === static::$attr_protected)
						continue;
				}

				// set valid table data
				try 
				{
					$this->$name = $value;
				} 
				catch (UndefinedPropertyException $e) 
				{
					$exceptions[] = $e->getMessage();
				}
			}
			else
			{
				// ignore OciAdapter's limit() stuff
				if ($name == 'ar_rnum__')
					continue;

				// set arbitrary data
				$this->assign_attribute($name,$value);
			}
		}

		if (!empty($exceptions))
			throw new UndefinedPropertyException(get_called_class(),$exceptions);
	}

	/**
	 * Add a model to the given named ($name) relationship.
	 *
	 * @internal This should <strong>only</strong> be used by eager load
	 * @param Model $model
	 * @param $name of relationship for this table
	 * @return void
	 */
	public function set_relationship_from_eager_load(Model $model=null, $name)
	{
		$table = static::table();

		if (($rel = $table->get_relationship($name)))
		{
			if ($rel->is_poly())
			{
				// if the related model is null and it is a poly then we should have an empty array
				if (is_null($model))
					return $this->__relationships[$name] = array();
				else
					return $this->__relationships[$name][] = $model;
			}
			else
				return $this->__relationships[$name] = $model;
		}

		throw new RelationshipException("Relationship named $name has not been declared for class: {$table->class->getName()}");
	}

	/**
	 * Reloads the attributes and relationships of this object from the database.
	 *
	 * @return Model
	 */
	public function reload()
	{
		$this->__relationships = array();
		$pk = array_values($this->get_values_for($this->get_primary_key()));
		
		$this->set_attributes_via_mass_assignment($this->find($pk)->attributes,
			false);
		$this->reset_dirty();

		return $this;
	}

	public function __clone()
	{
		$this->__relationships = array();
		$this->reset_dirty();
		return $this;
	}

	/**
	 * Resets the dirty array.
	 *
	 * @see dirty_attributes
	 */
	public function reset_dirty()
	{
		$this->__dirty = null;
	}

	/**
	 * A list of valid finder options.
	 *
	 * @var array
	 */
	static $VALID_OPTIONS = array('conditions', 'limit', 'offset', 'order', 'select', 'joins', 'include', 'readonly', 'group', 'from', 'having');

	/**
	 * Enables the use of dynamic finders.
	 *
	 * Dynamic finders are just an easy way to do queries quickly without having to
	 * specify an options array with conditions in it.
	 *
	 * <code>
	 * SomeModel::find_by_first_name('Tito');
	 * SomeModel::find_by_first_name_and_last_name('Tito','the Grief');
	 * SomeModel::find_by_first_name_or_last_name('Tito','the Grief');
	 * SomeModel::find_all_by_last_name('Smith');
	 * SomeModel::count_by_name('Bob')
	 * SomeModel::count_by_name_or_state('Bob','VA')
	 * SomeModel::count_by_name_and_state('Bob','VA')
	 * </code>
	 *
	 * You can also create the model if the find call returned no results:
	 *
	 * <code>
	 * Person::find_or_create_by_name('Tito');
	 *
	 * # would be the equivalent of
	 * if (!Person::find_by_name('Tito'))
	 *	 Person::create(array('Tito'));
	 * </code>
	 *
	 * Some other examples of find_or_create_by:
	 *
	 * <code>
	 * Person::find_or_create_by_name_and_id('Tito',1);
	 * Person::find_or_create_by_name_and_id(array('name' => 'Tito', 'id' => 1));
	 * </code>
	 *
	 * @param string $method Name of method
	 * @param mixed $args Method args
	 * @return Model
	 * @throws {@link ActiveRecordException} if invalid query
	 * @see find
	 */
	public static function __callStatic($method, $args)
	{
		$options = static::extract_and_validate_options($args);
		$create = false;

		if (substr($method,0,17) == 'find_or_create_by')
		{
			$attributes = substr($method,17);

			// can't take any finders with OR in it when doing a find_or_create_by
			if (strpos($attributes,'_or_') !== false)
				throw new ActiveRecordException("Cannot use OR'd attributes in find_or_create_by");

			$create = true;
			$method = 'find_by' . substr($method,17);
		}

		if (substr($method,0,7) === 'find_by')
		{
			$attributes = substr($method,8);
			$options['conditions'] = SQLBuilder::create_conditions_from_underscored_string(static::connection(),$attributes,$args,static::$alias_attribute);

			if (!($ret = static::find('first',$options)) && $create)
				return static::create(SQLBuilder::create_hash_from_underscored_string($attributes,$args,static::$alias_attribute));

			return $ret;
		}
		elseif (substr($method,0,11) === 'find_all_by')
		{
			$options['conditions'] = SQLBuilder::create_conditions_from_underscored_string(static::connection(),substr($method,12),$args,static::$alias_attribute);
			return static::find('all',$options);
		}
		elseif (substr($method,0,8) === 'count_by')
		{
			$options['conditions'] = SQLBuilder::create_conditions_from_underscored_string(static::connection(),substr($method,9),$args,static::$alias_attribute);
			return static::count($options);
		}

		throw new ActiveRecordException("Call to undefined method: $method");
	}

	/**
	 * Enables the use of build|create for associations.
	 *
	 * @param string $method Name of method
	 * @param mixed $args Method args
	 * @return mixed An instance of a given {@link AbstractRelationship}
	 */
	public function __call($method, $args)
	{
		//check for build|create_association methods
		if (preg_match('/(build|create)_/', $method))
		{
			if (!empty($args))
				$args = $args[0];

			$association_name = str_replace(array('build_', 'create_'), '', $method);
			$method = str_replace($association_name, 'association', $method);
			$table = static::table();
			
			 if (($association = $table->get_relationship($association_name)) 
				|| ($association = $table->get_relationship((
				$association_name = Utils::pluralize($association_name)))))
			{
				// access association to ensure that the relationship has been loaded
				// so that we do not double-up on records if we append a newly created
				$this->$association_name;
				return $association->$method($this, $args);
			}
		}

		throw new ActiveRecordException("Call to undefined method: $method");
	}

	/**
	 * Alias for self::find('all').
	 *
	 * @see find
	 * @return array array of records found
	 */
	public static function all(/* ... */)
	{
		return call_user_func_array('static::find',array_merge(array('all'),func_get_args()));
	}

	/**
	 * Get a count of qualifying records.
	 *
	 * <code>
	 * YourModel::count(array('conditions' => 'amount > 3.14159265'));
	 * </code>
	 *
	 * @see find
	 * @return int Number of records that matched the query
	 */
	public static function count(/* ... */)
	{
		$args = func_get_args();
		$options = static::extract_and_validate_options($args);
		$options['select'] = 'COUNT(*)';

		if (!empty($args))
		{
			if (is_hash($args[0]))
				$options['conditions'] = $args[0];
			else
				$options['conditions'] = call_user_func_array('static::pk_conditions',$args);
		}

		$table = static::table();
		$sql = $table->options_to_sql($options);
		$values = $sql->get_where_values();
		return static::connection()->query_and_fetch_one($sql->to_s(),$values);
	}

	/**
	 * Determine if a record exists.
	 *
	 * <code>
	 * SomeModel::exists(123);
	 * SomeModel::exists(array('conditions' => array('id=? and name=?', 123, 'Tito')));
	 * SomeModel::exists(array('id' => 123, 'name' => 'Tito'));
	 * </code>
	 *
	 * @see find
	 * @return boolean
	 */
	public static function exists(/* ... */)
	{
		return call_user_func_array('static::count',func_get_args()) > 0 ? true : false;
	}

	/**
	 * Alias for self::find('first').
	 *
	 * @see find
	 * @return Model The first matched record or null if not found
	 */
	public static function first(/* ... */)
	{
		return call_user_func_array('static::find',array_merge(array('first'),func_get_args()));
	}

	/**
	 * Alias for self::find('last')
	 *
	 * @see find
	 * @return Model The last matched record or null if not found
	 */
	public static function last(/* ... */)
	{
		return call_user_func_array('static::find',array_merge(array('last'),func_get_args()));
	}

	/**
	 * Find records in the database.
	 *
	 * Finding by the primary key:
	 *
	 * <code>
	 * # queries for the model with id=123
	 * YourModel::find(123);
	 *
	 * # queries for model with id in(1,2,3)
	 * YourModel::find(1,2,3);
	 *
	 * # finding by pk accepts an options array
	 * YourModel::find(123,array('order' => 'name desc'));
	 * </code>
	 *
	 * Finding by using a conditions array:
	 *
	 * <code>
	 * YourModel::find('first', array('conditions' => array('name=?','Tito'),
	 *	 'order' => 'name asc'))
	 * YourModel::find('all', array('conditions' => 'amount > 3.14159265'));
	 * YourModel::find('all', array('conditions' => array('id in(?)', array(1,2,3))));
	 * </code>
	 *
	 * Finding by using a hash:
	 *
	 * <code>
	 * YourModel::find(array('name' => 'Tito', 'id' => 1));
	 * YourModel::find('first',array('name' => 'Tito', 'id' => 1));
	 * YourModel::find('all',array('name' => 'Tito', 'id' => 1));
	 * </code>
	 *
	 * An options array can take the following parameters:
	 *
	 * <ul>
	 * <li><b>select:</b> A SQL fragment for what fields to return such as: '*', 'people.*', 'first_name, last_name, id'</li>
	 * <li><b>joins:</b> A SQL join fragment such as: 'JOIN roles ON(roles.user_id=user.id)' or a named association on the model</li>
	 * <li><b>include:</b> TODO not implemented yet</li>
	 * <li><b>conditions:</b> A SQL fragment such as: 'id=1', array('id=1'), array('name=? and id=?','Tito',1), array('name IN(?)', array('Tito','Bob')),
	 * array('name' => 'Tito', 'id' => 1)</li>
	 * <li><b>limit:</b> Number of records to limit the query to</li>
	 * <li><b>offset:</b> The row offset to return results from for the query</li>
	 * <li><b>order:</b> A SQL fragment for order such as: 'name asc', 'name asc, id desc'</li>
	 * <li><b>readonly:</b> Return all the models in readonly mode</li>
	 * <li><b>group:</b> A SQL group by fragment</li>
	 * </ul>
	 *
	 * @throws {@link RecordNotFound} if no options are passed or finding by pk and no records matched
	 * @return mixed An array of records found if doing a find_all otherwise a
	 *	 single Model object or null if it wasn't found. NULL is only return when
	 *	 doing a first/last find. If doing an all find and no records matched this
	 *	 will return an empty array.
	 */
	public static function find(/* $type, $options */)
	{
		$class = get_called_class();

		if (func_num_args() <= 0)
			throw new RecordNotFound("Couldn't find $class without an ID");

		$args = func_get_args();
		$options = static::extract_and_validate_options($args);
		$num_args = count($args);
		$single = true;

		if ($num_args > 0 && ($args[0] === 'all' || $args[0] === 'first' || $args[0] === 'last'))
		{
			switch ($args[0])
			{
				case 'all':
					$single = false;
					break;

				case 'last':
					if (!array_key_exists('order',$options))
						$options['order'] = join(' DESC, ',static::table()->pk) . ' DESC';
					else
						$options['order'] = SQLBuilder::reverse_order($options['order']);

					// fall thru

				case 'first':
					$options['limit'] = 1;
					$options['offset'] = 0;
					break;
			}

			$args = array_slice($args,1);
			$num_args--;
		}
		//find by pk
		elseif (1 === count($args) && 1 == $num_args)
			$args = $args[0];

		// anything left in $args is a find by pk
		if ($num_args > 0 && !isset($options['conditions']))
			return static::find_by_pk($args, $options);

		$options['mapped_names'] = static::$alias_attribute;
		$list = static::table()->find($options);

		return $single ? (!empty($list) ? $list[0] : null) : $list;
	}

	/**
	 * Finder method which will find by a single or array of primary keys for this model.
	 *
	 * @see find
	 * @param array $values An array containing values for the pk
	 * @param array $options An options array
	 * @return Model
	 * @throws {@link RecordNotFound} if a record could not be found
	 */
	public static function find_by_pk($values, $options)
	{
		$options['conditions'] = static::pk_conditions($values);
		$list = static::table()->find($options);
		$results = count($list);

		if ($results != ($expected = count($values)))
		{
			$class = get_called_class();

			if ($expected == 1)
			{
				if (!is_array($values))
					$values = array($values);

				throw new RecordNotFound("Couldn't find $class with ID=" . join(',',$values));
			}

			$values = join(',',$values);
			throw new RecordNotFound("Couldn't find all $class with IDs ($values) (found $results, but was looking for $expected)");
		}
		return $expected == 1 ? $list[0] : $list;
	}

	/**
	 * Find using a raw SELECT query.
	 *
	 * <code>
	 * YourModel::find_by_sql("SELECT * FROM people WHERE name=?",array('Tito'));
	 * YourModel::find_by_sql("SELECT * FROM people WHERE name='Tito'");
	 * </code>
	 *
	 * @param string $sql The raw SELECT query
	 * @param array $values An array of values for any parameters that needs to be bound
	 * @return array An array of models
	 */
	public static function find_by_sql($sql, $values=null)
	{
		return static::table()->find_by_sql($sql, $values, true);
	}
	
	/**
	 * Helper method to run arbitrary queries against the model's database connection.
	 *
	 * @param string $sql SQL to execute
	 * @param array $values Bind values, if any, for the query
	 * @return object A \PDOStatement object
	 */
	public static function query($sql, $values=null)
	{
		return static::connection()->query($sql, $values);
	}

	/**
	 * Determines if the specified array is a valid ActiveRecord options array.
	 *
	 * @param array $array An options array
	 * @param bool $throw True to throw an exception if not valid
	 * @return boolean True if valid otherwise valse
	 * @throws {@link ActiveRecordException} if the array contained any invalid options
	 */
	public static function is_options_hash($array, $throw=true)
	{
		if (is_hash($array))
		{
			$keys = array_keys($array);
			$diff = array_diff($keys,self::$VALID_OPTIONS);

			if (!empty($diff) && $throw)
				throw new ActiveRecordException("Unknown key(s): " . join(', ',$diff));

			$intersect = array_intersect($keys,self::$VALID_OPTIONS);

			if (!empty($intersect))
				return true;
		}
		return false;
	}

	/**
	 * Returns a hash containing the names => values of the primary key.
	 *
	 * @internal This needs to eventually support composite keys.
	 * @param mixed $args Primary key value(s)
	 * @return array An array in the form array(name => value, ...)
	 */
	public static function pk_conditions($args)
	{
		$table = static::table();
		$ret = array($table->pk[0] => $args);
		return $ret;
	}

	/**
	 * Pulls out the options hash from $array if any.
	 *
	 * @internal DO NOT remove the reference on $array.
	 * @param array &$array An array
	 * @return array A valid options array
	 */
	public static function extract_and_validate_options(array &$array)
	{
		$options = array();

		if ($array)
		{
			$last = &$array[count($array)-1];

			try
			{
				if (self::is_options_hash($last))
				{
					array_pop($array);
					$options = $last;
				}
			}
			catch (ActiveRecordException $e)
			{
				if (!is_hash($last))
					throw $e;

				$options = array('conditions' => $last);
			}
		}
		return $options;
	}

	/**
	 * Returns a JSON representation of this model.
	 *
	 * @see Serialization
	 * @param array $options An array containing options for json serialization (see {@link Serialization} for valid options)
	 * @return string JSON representation of the model
	 */
	public function to_json(array $options=array())
	{
		return $this->serialize('Json', $options);
	}

	/**
	 * Returns an XML representation of this model.
	 *
	 * @see Serialization
	 * @param array $options An array containing options for xml serialization (see {@link Serialization} for valid options)
	 * @return string XML representation of the model
	 */
	public function to_xml(array $options=array())
	{
		return $this->serialize('Xml', $options);
	}
	
	/**
	 * Returns an CSV representation of this model.
	 * Can take optional delimiter and enclosure
	 * (defaults are , and double quotes)
	 *
	 * Ex:
	 *
	 * <code>
	 * ActiveRecord\CsvSerializer::$delimiter=';';
	 * ActiveRecord\CsvSerializer::$enclosure='';
	 * YourModel::find('first')->to_csv(array('only'=>array('name','level')));
	 * returns: Joe,2
	 *
	 * YourModel::find('first')->to_csv(array('only_header'=>true,'only'=>array('name','level')));
	 * returns: name,level
	 * </code>
	 *
	 * @see Serialization
	 * @param array $options An array containing options for csv serialization (see {@link Serialization} for valid options)
	 * @return string CSV representation of the model
	 */
	public function to_csv(array $options=array())
	{
		return $this->serialize('Csv', $options);
	}
	
	/**
	 * Returns an Array representation of this model.
	 *
	 * @see Serialization
	 * @param array $options An array containing options for json serialization (see {@link Serialization} for valid options)
	 * @return array Array representation of the model
	 */
	public function to_array(array $options=array())
	{
		return $this->serialize('Array', $options);
	}

	/**
	 * Creates a serializer based on pre-defined to_serializer()
	 *
	 * An options array can take the following parameters:
	 *
	 * <ul>
	 * <li><b>only:</b> a string or array of attributes to be included.</li>
	 * <li><b>excluded:</b> a string or array of attributes to be excluded.</li>
	 * <li><b>methods:</b> a string or array of methods to invoke. The method's name will be used as a key for the final attributes array
	 * along with the method's returned value</li>
	 * <li><b>include:</b> a string or array of associated models to include in the final serialized product.</li>
	 * </ul>
	 *
	 * @param string $type Either Xml, Json, Csv or Array
	 * @param array $options Options array for the serializer
	 * @return string Serialized representation of the model
	 */
	private function serialize($type, $options)
	{
		$class = "ActiveRecord\\{$type}Serializer";
		$serializer = new $class($this, $options);
		return $serializer->to_s();
	}

	/**
	 * Invokes the specified callback on this model.
	 *
	 * @param string $method_name Name of the call back to run.
	 * @param boolean $must_exist Set to true to raise an exception if the callback does not exist.
	 * @return boolean True if invoked or null if not
	 */
	private function invoke_callback($method_name, $must_exist=true)
	{
		return static::table()->callback->invoke($this,$method_name,$must_exist);
	}

	/**
	 * Executes a block of code inside a database transaction.
	 *
	 * <code>
	 * YourModel::transaction(function()
	 * {
	 *	 YourModel::create(array("name" => "blah"));
	 * });
	 * </code>
	 *
	 * If an exception is thrown inside the closure the transaction will
	 * automatically be rolled back. You can also return false from your
	 * closure to cause a rollback:
	 *
	 * <code>
	 * YourModel::transaction(function()
	 * {
	 *	 YourModel::create(array("name" => "blah"));
	 *	 throw new Exception("rollback!");
	 * });
	 *
	 * YourModel::transaction(function()
	 * {
	 *	 YourModel::create(array("name" => "blah"));
	 *	 return false; # rollback!
	 * });
	 * </code>
	 *
	 * @param \Closure $closure The closure to execute. To cause a rollback have your closure return false or throw an exception.
	 * @return boolean True if the transaction was committed, False if rolled back.
	 */
	public static function transaction($closure)
	{
		$connection = static::connection();

		try
		{
			$connection->transaction();

			if ($closure() === false)
			{
				$connection->rollback();
				return false;
			}
			else
				$connection->commit();
		}
		catch (\Exception $e)
		{
			$connection->rollback();
			throw $e;
		}
		return true;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Reflections.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Simple class that caches reflections of classes.
 *
 * @package ActiveRecord
 */
class Reflections extends Singleton
{
	/**
	 * Current reflections.
	 *
	 * @var array
	 */
	private $reflections = array();

	/**
	 * Instantiates a new \ReflectionClass for the given class.
	 *
	 * @param string $class Name of a class
	 * @return Reflections $this so you can chain calls like Reflections::instance()->add('class')->get()
	 */
	public function add($class=null)
	{
		$class = $this->get_class($class);
		
		if (!isset($this->reflections[$class]))
		{
			foreach (array('has_many', 'has_one', 'has_and_belongs_to_many', 
				'belongs_to') as $assoc_name)
			{
				if (isset($class::$$assoc_name))
					self::normalize_associations($class::$$assoc_name);
			}
			
			$this->reflections[$class] = new \ReflectionClass($class);
		}
			
		return $this;
	}
	
	private static function normalize_associations(&$definitions)
	{
		if ((array) $definitions !== $definitions)
			$definitions = array(array($definitions));
		else 
		{
			$options = array();

			foreach ($definitions as $key => $value)
			{
				if (is_string($key))
				{
					$options[$key] = $value;
					unset($definitions[$key]);
				}
				elseif ((array) $value !== $value)
					$definitions[$key] = array($value);
			}

			if ($options)
			{
				foreach ($definitions as &$entry)
					$entry += $options;
			}
		}
	}

	/**
	 * Destroys the cached \ReflectionClass.
	 *
	 * Put this here mainly for testing purposes.
	 * 
	 * @param string $class Name of a class.
	 * @return void
	 */
	public function destroy($class)
	{
		if (isset($this->reflections[$class]))
			$this->reflections[$class] = null;
	}
	
	/**
	 * Get a cached \ReflectionClass.
	 *
	 * @param string $class Optional name of a class
	 * @return mixed null or a \ReflectionClass instance
	 * @throws ActiveRecordException if class was not found
	 */
	public function get($class=null)
	{
		$class = $this->get_class($class);

		if (isset($this->reflections[$class]))
			return $this->reflections[$class];

		throw new ActiveRecordException("Class not found: $class");
	}

	/**
	 * Retrieve a class name to be reflected.
	 *
	 * @param mixed $mixed An object or name of a class
	 * @return string
	 */
	private function get_class($mixed=null)
	{
		if (is_object($mixed))
			return get_class($mixed);

		if (!is_null($mixed))
			return $mixed;

		return $this->get_called_class();
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'InterfaceRelationship.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Interface for a table relationship.
 *
 * @package ActiveRecord
 */
interface InterfaceRelationship
{
	public function __construct($options=array());
	public function build_association(Model $model, $attributes=array());
	public function create_association(Model $model, $attributes=array());
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'AbstractRelationship.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Abstract class that all relationships must extend from.
 *
 * @package ActiveRecord
 * @see http://www.phpactiverecord.org/guides/associations
 */
abstract class AbstractRelationship implements InterfaceRelationship
{
	/**
	 * Name to be used that will trigger call to the relationship.
	 *
	 * @var string
	 */
	public $attribute_name;

	/**
	 * Class name of the associated model.
	 *
	 * @var string
	 */
	public $class_name;

	/**
	 * Name of the foreign key.
	 *
	 * @var string
	 */
	public $foreign_key = array();

	/**
	 * Options of the relationship.
	 *
	 * @var array
	 */
	protected $options = array();

	/**
	 * Is the relationship single or multi.
	 *
	 * @var boolean
	 */
	protected $poly_relationship = false;

	/**
	 * List of valid options for relationships.
	 *
	 * @var array
	 */
	static protected $valid_association_options = array('class_name', 'class', 'foreign_key', 'conditions', 'select', 'readonly');

	/**
	 * Constructs a relationship.
	 *
	 * @param array $options Options for the relationship (see {@link valid_association_options})
	 * @return mixed
	 */
	public function __construct($options=array())
	{
		$this->attribute_name = $options[0];
		$this->options = $this->merge_association_options($options);

		$relationship = strtolower(denamespace(get_called_class()));

		if ($relationship === 'hasmany' || $relationship === 'hasandbelongstomany')
			$this->poly_relationship = true;

		if (isset($this->options['conditions']) && !is_array($this->options['conditions']))
			$this->options['conditions'] = array($this->options['conditions']);

		if (isset($this->options['class']))
			$this->set_class_name($this->options['class']);
		elseif (isset($this->options['class_name']))
			$this->set_class_name($this->options['class_name']);

		$this->attribute_name = strtolower(Inflector::instance()->variablize($this->attribute_name));

		if (!$this->foreign_key && isset($this->options['foreign_key']))
			$this->foreign_key = is_array($this->options['foreign_key']) ? $this->options['foreign_key'] : array($this->options['foreign_key']);
	}

	protected function get_table()
	{
		return Table::load($this->class_name);
	}

	/**
	 * What is this relationship's cardinality?
	 *
	 * @return bool
	 */
	public function is_poly()
	{
		return $this->poly_relationship;
	}

	/**
	 * Eagerly loads relationships for $models.
	 *
	 * This method takes an array of models, collects PK or FK (whichever is needed for relationship), then queries
	 * the related table by PK/FK and attaches the array of returned relationships to the appropriately named relationship on
	 * $models.
	 *
	 * @param Table $table
	 * @param $models array of model objects
	 * @param $attributes array of attributes from $models
	 * @param $includes array of eager load directives
	 * @param $query_keys -> key(s) to be queried for on included/related table
	 * @param $model_values_keys -> key(s)/value(s) to be used in query from model which is including
	 * @return void
	 */
	protected function query_and_attach_related_models_eagerly(Table $table, $models, $attributes, $includes=array(), $query_keys=array(), $model_values_keys=array())
	{
		$values = array();
		$options = $this->options;
		$inflector = Inflector::instance();
		$query_key = $query_keys[0];
		$model_values_key = $model_values_keys[0];

		foreach ($attributes as $column => $value)
			$values[] = $value[$inflector->variablize($model_values_key)];

		$values = array($values);
		$conditions = SQLBuilder::create_conditions_from_underscored_string(
			$table->conn,
			$query_key,
			$values
		);

		if (isset($options['conditions']) &&strlen($options['conditions'][0])>1)
			Utils::add_condition($options['conditions'], $conditions);
		else
			$options['conditions'] = $conditions;

		if (!empty($includes))
			$options['include'] = $includes;
		
		$options = $this->unset_non_finder_options($options);

		$class = $this->class_name;

		$related_models = $class::find('all', $options);
		$used_models = array();
		$model_values_key = $inflector->variablize($model_values_key);
		$query_key = $inflector->variablize($query_key);

		foreach ($models as $model)
		{
			$matches = 0;
			$key_to_match = $model->$model_values_key;

			foreach ($related_models as $related)
			{
				if ($related->$query_key == $key_to_match)
				{
					$hash = spl_object_hash($related);

					if (in_array($hash, $used_models))
						$model->set_relationship_from_eager_load(clone($related), $this->attribute_name);
					else
						$model->set_relationship_from_eager_load($related, $this->attribute_name);

					$used_models[] = $hash;
					$matches++;
				}
			}

			if (0 === $matches)
				$model->set_relationship_from_eager_load(null, $this->attribute_name);
		}
	}

	/**
	 * Creates a new instance of specified {@link Model} with the attributes pre-loaded.
	 *
	 * @param Model $model The model which holds this association
	 * @param array $attributes Hash containing attributes to initialize the model with
	 * @return Model
	 */
	public function build_association(Model $model, $attributes=array())
	{
		$class_name = $this->class_name;
		return new $class_name($attributes);
	}

	/**
	 * Creates a new instance of {@link Model} and invokes save.
	 *
	 * @param Model $model The model which holds this association
	 * @param array $attributes Hash containing attributes to initialize the model with
	 * @return Model
	 */
	public function create_association(Model $model, $attributes=array())
	{
		$class_name = $this->class_name;
		$new_record = $class_name::create($attributes);
		return $this->append_record_to_associate($model, $new_record);
	}

	protected function append_record_to_associate(Model $associate, Model $record)
	{
		$association =& $associate->{$this->attribute_name};

		if ($this->poly_relationship)
			$association[] = $record;
		else
			$association = $record;

		return $record;
	}

	protected function merge_association_options($options)
	{
		$available_options = array_merge(self::$valid_association_options,static::$valid_association_options);
		$valid_options = array_intersect_key(array_flip($available_options),$options);

		foreach ($valid_options as $option => $v)
			$valid_options[$option] = $options[$option];

		return $valid_options;
	}

	protected function unset_non_finder_options($options)
	{
		foreach (array_keys($options) as $option)
		{
			if (!in_array($option, Model::$VALID_OPTIONS))
				unset($options[$option]);
		}
		return $options;
	}

	/**
	 * Infers the $this->class_name based on $this->attribute_name.
	 *
	 * Will try to guess the appropriate class by singularizing and uppercasing $this->attribute_name.
	 *
	 * @return void
	 * @see attribute_name
	 */
	protected function set_inferred_class_name()
	{
		$this->set_class_name(classify($this->attribute_name));
	}

	protected function set_class_name($class_name)
	{
		$class_name = add_namespace($class_name);
		$reflection = Reflections::instance()->add($class_name)->get($class_name);

		if (!$reflection->isSubClassOf('ActiveRecord\\Model'))
			throw new RelationshipException("'$class_name' must extend from ActiveRecord\\Model");

		$this->class_name = $class_name;
	}

	protected function create_conditions_from_keys(Model $model, $condition_keys=array(), $value_keys=array())
	{
		$condition_string = implode('_and_', $condition_keys);
		$condition_values = array_values($model->get_values_for($value_keys));

		// return null if all the foreign key values are null so that we don't try to do a query like "id is null"
		if (all(null,$condition_values))
			return null;

		$conditions = SQLBuilder::create_conditions_from_underscored_string(Table::load(get_class($model))->conn,$condition_string,$condition_values);

		# DO NOT CHANGE THE NEXT TWO LINES. add_condition operates on a reference and will screw options array up
		if (isset($this->options['conditions']))
			$options_conditions = $this->options['conditions'];
		else
			$options_conditions = array();

		return Utils::add_condition($options_conditions, $conditions);
	}

	/**
	 * Creates INNER JOIN SQL for associations.
	 *
	 * @param Table $from_table the table used for the FROM SQL statement
	 * @param bool $using_through is this a THROUGH relationship?
	 * @param string $alias a table alias for when a table is being joined twice
	 * @return string SQL INNER JOIN fragment
	 */
	public function construct_inner_join_sql(Table $from_table, $using_through=false, $alias=null)
	{
		if ($using_through)
		{
			$join_table = $from_table;
			$join_table_name = $from_table->get_fully_qualified_table_name();
			$from_table_name = Table::load($this->class_name)->get_fully_qualified_table_name();
		}
		else
		{
			$join_table = Table::load($this->class_name);
			$join_table_name = $join_table->get_fully_qualified_table_name();
			$from_table_name = $from_table->get_fully_qualified_table_name();
		}

		// need to flip the logic when the key is on the other table
		if ($this instanceof HasMany || $this instanceof HasOne)
		{
			$this->set_keys($from_table->class->getName());

			if ($using_through)
			{
				$foreign_key = $this->primary_key[0];
				$join_primary_key = $this->foreign_key[0];
			}
			else
			{
				$join_primary_key = $this->foreign_key[0];
				$foreign_key = $this->primary_key[0];
			}
		}
		else
		{
			$foreign_key = $this->foreign_key[0];
			$join_primary_key = $this->primary_key[0];
		}

		if (!is_null($alias))
		{
			$aliased_join_table_name = $alias = $this->get_table()->conn->quote_name($alias);
			$alias .= ' ';
		}
		else
			$aliased_join_table_name = $join_table_name;

		return "INNER JOIN $join_table_name {$alias}ON($from_table_name.$foreign_key = $aliased_join_table_name.$join_primary_key)";
	}

	/**
	 * This will load the related model data.
	 *
	 * @param Model $model The model this relationship belongs to
	 */
	abstract function load(Model $model);
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'HasMany.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * One-to-many relationship.
 *
 * <code>
 * # Table: people
 * # Primary key: id
 * # Foreign key: school_id
 * class Person extends ActiveRecord\Model {}
 *
 * # Table: schools
 * # Primary key: id
 * class School extends ActiveRecord\Model {
 *	 static $has_many = array(
 *	   array('people')
 *	 );
 * });
 * </code>
 *
 * Example using options:
 *
 * <code>
 * class Payment extends ActiveRecord\Model {
 *	 static $belongs_to = array(
 *	   array('person'),
 *	   array('order')
 *	 );
 * }
 *
 * class Order extends ActiveRecord\Model {
 *	 static $has_many = array(
 *	   array('people',
 *			 'through'	  => 'payments',
 *			 'select'	  => 'people.*, payments.amount',
 *			 'conditions' => 'payments.amount < 200')
 *	   );
 * }
 * </code>
 *
 * @package ActiveRecord
 * @see http://www.phpactiverecord.org/guides/associations
 * @see valid_association_options
 */
class HasMany extends AbstractRelationship
{
	/**
	 * Valid options to use for a {@link HasMany} relationship.
	 *
	 * <ul>
	 * <li><b>limit/offset:</b> limit the number of records</li>
	 * <li><b>primary_key:</b> name of the primary_key of the association (defaults to "id")</li>
	 * <li><b>group:</b> GROUP BY clause</li>
	 * <li><b>order:</b> ORDER BY clause</li>
	 * <li><b>through:</b> name of a model</li>
	 * </ul>
	 *
	 * @var array
	 */
	static protected $valid_association_options = array('primary_key', 'order', 'group', 'having', 'limit', 'offset', 'through', 'source');

	protected $primary_key;

	private $has_one = false;
	private $through;

	/**
	 * Constructs a {@link HasMany} relationship.
	 *
	 * @param array $options Options for the association
	 * @return HasMany
	 */
	public function __construct($options=array())
	{
		parent::__construct($options);

		if (isset($this->options['through']))
		{
			$this->through = $this->options['through'];

			if (isset($this->options['source']))
				$this->set_class_name($this->options['source']);
		}

		if (!$this->primary_key && isset($this->options['primary_key']))
			$this->primary_key = is_array($this->options['primary_key']) ? $this->options['primary_key'] : array($this->options['primary_key']);

		if (!$this->class_name)
			$this->set_inferred_class_name();
	}

	protected function set_keys($model_class_name, $override=false)
	{
		//infer from class_name
		if (!$this->foreign_key || $override)
			$this->foreign_key =
				array(Inflector::instance()->keyify($model_class_name));

		if (!$this->primary_key || $override)
			$this->primary_key = Table::load($model_class_name)->pk;
	}

	public function load(Model $model)
	{
		$class_name = $this->class_name;
		$this->set_keys(get_class($model));

		// since through relationships depend on other relationships we can't do
		// this initiailization in the constructor since the other relationship
		// may not have been created yet and we only want this to run once
		if (!isset($this->initialized))
		{
			if ($this->through)
			{
				// verify through is a belongs_to or has_many for access of keys
				if (!($through_relationship = $this->get_table()->get_relationship($this->through)))
					throw new HasManyThroughAssociationException("Could not find the association $this->through in model " . get_class($model));

				if (!($through_relationship instanceof HasMany) && !($through_relationship instanceof BelongsTo))
					throw new HasManyThroughAssociationException('has_many through can only use a belongs_to or has_many association');

				// save old keys as we will be reseting them below for inner join convenience
				$pk = $this->primary_key;
				$fk = $this->foreign_key;

				$this->set_keys($this->get_table()->class->getName(), true);

				$through_table = Table::load(classify($this->through, true));
				$this->options['joins'] = $this->construct_inner_join_sql($through_table, true);

				// reset keys
				$this->primary_key = $pk;
				$this->foreign_key = $fk;
			}

			$this->initialized = true;
		}

		if (!($conditions = $this->create_conditions_from_keys($model, $this->foreign_key, $this->primary_key)))
			return null;

		$options = $this->unset_non_finder_options($this->options);
		$options['conditions'] = $conditions;
		return $class_name::find($this->poly_relationship ? 'all' : 'first',$options);
	}

	private function inject_foreign_key_for_new_association(Model $model, &$attributes)
	{
		$this->set_keys($model);
		$primary_key = Inflector::instance()->variablize($this->foreign_key[0]);

		if (!isset($attributes[$primary_key]))
			$attributes[$primary_key] = $model->id;

		return $attributes;
	}

	public function build_association(Model $model, $attributes=array())
	{
		$attributes = $this->inject_foreign_key_for_new_association($model, $attributes);
		return parent::build_association($model, $attributes);
	}

	public function create_association(Model $model, $attributes=array())
	{
		$attributes = $this->inject_foreign_key_for_new_association($model, $attributes);
		return parent::create_association($model, $attributes);
	}

	public function load_eagerly($models=array(), $attributes=array(), $includes, Table $table)
	{
		$this->set_keys($table->class->name);
		$this->query_and_attach_related_models_eagerly($table,$models,$attributes,$includes,$this->foreign_key, $table->pk);
	}
	
	protected function set_inferred_class_name()
	{
		$this->set_class_name(classify($this->attribute_name, true));
	}
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'HasOne.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * One-to-one relationship.
 *
 * <code>
 * # Table name: states
 * # Primary key: id
 * class State extends ActiveRecord\Model {}
 *
 * # Table name: people
 * # Foreign key: state_id
 * class Person extends ActiveRecord\Model {
 *	 static $has_one = array(array('state'));
 * }
 * </code>
 *
 * @package ActiveRecord
 * @see http://www.phpactiverecord.org/guides/associations
 */
class HasOne extends HasMany
{
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'HasAndBelongsToMany.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * @todo implement me
 * @package ActiveRecord
 * @see http://www.phpactiverecord.org/guides/associations
 */
class HasAndBelongsToMany extends AbstractRelationship
{
	public function __construct($options=array())
	{
		/* options =>
		 *	 join_table - name of the join table if not in lexical order
		 *	 foreign_key -
		 *	 association_foreign_key - default is {assoc_class}_id
		 *	 uniq - if true duplicate assoc objects will be ignored
		 *	 validate
		 */
	}

	public function load(Model $model)
	{

	}
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'BelongsTo.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Belongs to relationship.
 *
 * <code>
 * class School extends ActiveRecord\Model {}
 *
 * class Person extends ActiveRecord\Model {
 *	 static $belongs_to = array(
 *	   array('school')
 *	 );
 * }
 * </code>
 *
 * Example using options:
 *
 * <code>
 * class School extends ActiveRecord\Model {}
 *
 * class Person extends ActiveRecord\Model {
 *	 static $belongs_to = array(
 *	   array('school', 'primary_key' => 'school_id')
 *	 );
 * }
 * </code>
 *
 * @package ActiveRecord
 * @see valid_association_options
 * @see http://www.phpactiverecord.org/guides/associations
 */
class BelongsTo extends AbstractRelationship
{
	public function __construct($options=array())
	{
		parent::__construct($options);

		if (!$this->class_name)
			$this->set_inferred_class_name();

		//infer from class_name
		if (!$this->foreign_key)
			$this->foreign_key = 
				array(Inflector::instance()->keyify($this->class_name));

		$this->primary_key = array(Table::load($this->class_name)->pk[0]);
	}

	public function load(Model $model)
	{
		$keys = array();
		$inflector = Inflector::instance();

		foreach ($this->foreign_key as $key)
			$keys[] = $inflector->variablize($key);

		if (!($conditions = $this->create_conditions_from_keys($model, $this->primary_key, $keys)))
			return null;

		$options = $this->unset_non_finder_options($this->options);
		$options['conditions'] = $conditions;
		$class = $this->class_name;
		return $class::first($options);
	}

	public function load_eagerly($models=array(), $attributes, $includes, Table $table)
	{
		$this->query_and_attach_related_models_eagerly($table,$models,$attributes,$includes, $this->primary_key,$this->foreign_key);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Serialization.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Base class for Model serializers.
 *
 * All serializers support the following options:
 *
 * <ul>
 * <li><b>only:</b> a string or array of attributes to be included.</li>
 * <li><b>except:</b> a string or array of attributes to be excluded.</li>
 * <li><b>methods:</b> a string or array of methods to invoke. The method's name will be used as a key for the final attributes array
 * along with the method's returned value</li>
 * <li><b>include:</b> a string or array of associated models to include in the final serialized product.</li>
 * <li><b>only_method:</b> a method that's called and only the resulting array is serialized
 * <li><b>skip_instruct:</b> set to true to skip the <code><?xml ...?></code> declaration.</li>
 * </ul>
 *
 * Example usage:
 *
 * <code>
 * # include the attributes id and name
 * # run $model->encoded_description() and include its return value
 * # include the comments association
 * # include posts association with its own options (nested)
 * $model->to_json(array(
 *	 'only' => array('id','name', 'encoded_description'),
 *	 'methods' => array('encoded_description'),
 *	 'include' => array('comments', 'posts' => array('only' => 'id'))
 * ));
 *
 * # except the password field from being included
 * $model->to_xml(array('except' => 'password')));
 * </code>
 *
 * @package ActiveRecord
 * @link http://www.phpactiverecord.org/guides/utilities#topic-serialization
 */
abstract class Serialization
{
	protected $model;
	protected $options;
	protected $attributes;
	
	/**
	 * The default format to serialize DateTime objects to.
	 *
	 * @see DateTime
	 */
	public static $DATETIME_FORMAT = 'iso8601';
	
	/**
	 * Set this to true if the serializer needs to create a nested array keyed
	 * on the name of the included classes such as for xml serialization.
	 *
	 * Setting this to true will produce the following attributes array when
	 * the include option was used:
	 *
	 * <code>
	 * $user = array('id' => 1, 'name' => 'Tito',
	 *	 'permissions' => array(
	 *	   'permission' => array(
	 *		 array('id' => 100, 'name' => 'admin'),
	 *		 array('id' => 101, 'name' => 'normal')
	 *	   )
	 *	 )
	 * );
	 * </code>
	 *
	 * Setting to false will produce this:
	 *
	 * <code>
	 * $user = array('id' => 1, 'name' => 'Tito',
	 *	 'permissions' => array(
	 *	   array('id' => 100, 'name' => 'admin'),
	 *	   array('id' => 101, 'name' => 'normal')
	 *	 )
	 * );
	 * </code>
	 *
	 * @var boolean
	 */
	protected $includes_with_class_name_element = false;

	/**
	 * Constructs a {@link Serialization} object.
	 *
	 * @param Model $model The model to serialize
	 * @param array &$options Options for serialization
	 * @return Serialization
	 */
	public function __construct(Model $model, &$options)
	{
		$this->model = $model;
		$this->options = $options;
		$this->attributes = $model->attributes();
		$this->parse_options();
	}

	private function parse_options()
	{
		$this->check_only();
		$this->check_except();
		$this->check_methods();
		$this->check_include();
		$this->check_only_method(); 
	}

	private function check_only()
	{
		if (isset($this->options['only']))
		{
			$this->options_to_a('only');
			
			$exclude = array_diff(array_keys($this->attributes),$this->options['only']);
			$this->attributes = array_diff_key($this->attributes,array_flip($exclude));
		}
	}

	private function check_except()
	{
		if (isset($this->options['except']) && !isset($this->options['only']))
		{
			$this->options_to_a('except');
			$this->attributes = array_diff_key($this->attributes,array_flip($this->options['except']));
		}
	}

	private function check_methods()
	{
		if (isset($this->options['methods']))
		{
			$this->options_to_a('methods');

			foreach ($this->options['methods'] as $method)
			{
				if (method_exists($this->model, $method))
					$this->attributes[$method] = $this->model->$method();
			}
		}
	}
	
	private function check_only_method()
	{
		if (isset($this->options['only_method']))
		{
			$method = $this->options['only_method'];
			if (method_exists($this->model, $method))
				$this->attributes = $this->model->$method();
		}
	}

	private function check_include()
	{
		if (isset($this->options['include']))
		{
			$this->options_to_a('include');

			$serializer_class = get_class($this);

			foreach ($this->options['include'] as $association => $options)
			{
				if (!is_array($options))
				{
					$association = $options;
					$options = array();
				}

				try {
					$assoc = $this->model->$association;

					if (!is_array($assoc))
					{
						$serialized = new $serializer_class($assoc, $options);
						$this->attributes[$association] = $serialized->to_a();;
					}
					else
					{
						$includes = array();

						foreach ($assoc as $a)
						{
							$serialized = new $serializer_class($a, $options);

							if ($this->includes_with_class_name_element)
								$includes[strtolower(get_class($a))][] = $serialized->to_a();
							else
								$includes[] = $serialized->to_a();
						}

						$this->attributes[$association] = $includes;
					}

				} catch (UndefinedPropertyException $e) {
					;//move along
				}
			}
		}
	}

	final protected function options_to_a($key)
	{
		if (!is_array($this->options[$key]))
			$this->options[$key] = array($this->options[$key]);
	}

	/**
	 * Returns the attributes array.
	 * @return array
	 */
	final public function to_a()
	{
		foreach ($this->attributes as &$value)
		{
			if ($value instanceof \DateTime)
				$value = $value->format(self::$DATETIME_FORMAT);
		}
		return $this->attributes;
	}

	/**
	 * Returns the serialized object as a string.
	 * @see to_s
	 * @return string
	 */
	final public function __toString()
	{
		return $this->to_s();
	}

	/**
	 * Performs the serialization.
	 * @return string
	 */
	abstract public function to_s();
};
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'ArraySerializer.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Array serializer.
 *
 * @package ActiveRecord
 */
class ArraySerializer extends Serialization
{
	public static $include_root = false;

	public function to_s()
	{
		return self::$include_root 
			? array(strtolower(get_class($this->model)) => $this->to_a()) 
			: $this->to_a();
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'JsonSerializer.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * JSON serializer.
 *
 * @package ActiveRecord
 */
class JsonSerializer extends ArraySerializer
{
	public static $include_root = false;

	public function to_s()
	{
		parent::$include_root = self::$include_root;
		return json_encode(parent::to_s());
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'XmlSerializer.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * XML serializer.
 *
 * @package ActiveRecord
 */
class XmlSerializer extends Serialization
{
	private $writer;

	public function __construct(Model $model, &$options)
	{
		$this->includes_with_class_name_element = true;
		parent::__construct($model,$options);
	}

	public function to_s()
	{
		return $this->xml_encode();
	}

	private function xml_encode()
	{
		$this->writer = new \XmlWriter();
		$this->writer->openMemory();
		$this->writer->startDocument('1.0', 'UTF-8');
		$this->writer->startElement(strtolower(denamespace(($this->model))));
		$this->write($this->to_a());
		$this->writer->endElement();
		$this->writer->endDocument();
		$xml = $this->writer->outputMemory(true);

		if (@$this->options['skip_instruct'] == true)
			$xml = preg_replace('/<\?xml version.*?\?>/','',$xml);

		return $xml;
	}

	private function write($data, $tag=null)
	{
		foreach ($data as $attr => $value)
		{
			if ($tag != null)
				$attr = $tag;

			if (is_array($value) || is_object($value))
			{
				if (!is_int(key($value)))
				{
					$this->writer->startElement($attr);
					$this->write($value);
					$this->writer->endElement();
				}
				else
					$this->write($value, $attr);

				continue;
			}

			$this->writer->writeElement($attr, $value);
		}
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'CsvSerializer.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * CSV serializer.
 *
 * @package ActiveRecord
 */
class CsvSerializer extends Serialization
{
	public static $delimiter = ',';
	public static $enclosure = '"';

	public function to_s()
	{
		if (@$this->options['only_header'] == true) return $this->header();
		return $this->row();
	}

	private function header()
	{
		return $this->to_csv(array_keys($this->to_a()));
	}

	private function row()
	{
		return $this->to_csv($this->to_a());
	}

	private function to_csv($arr)
	{
		$outstream = fopen('php://temp', 'w');
		fputcsv($outstream, $arr, self::$delimiter, self::$enclosure);
		rewind($outstream);
		$buffer = trim(stream_get_contents($outstream));
		fclose($outstream);
		return $buffer;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Singleton.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * This implementation of the singleton pattern does not conform to the strong definition
 * given by the "Gang of Four." The __construct() method has not be privatized so that
 * a singleton pattern is capable of being achieved; however, multiple instantiations are also
 * possible. This allows the user more freedom with this pattern.
 *
 * @package ActiveRecord
 */
abstract class Singleton
{
	/**
	 * Array of cached singleton objects.
	 *
	 * @var array
	 */
	private static $instances = array();

	/**
	 * Static method for instantiating a singleton object.
	 *
	 * @return object
	 */
	final public static function instance()
	{
		$class_name = get_called_class();

		if (!isset(self::$instances[$class_name]))
			self::$instances[$class_name] = new $class_name;

		return self::$instances[$class_name];
	}

	/**
	 * Singleton objects should not be cloned.
	 *
	 * @return void
	 */
	final private function __clone() {}

	/**
	 * Similar to a get_called_class() for a child class to invoke.
	 *
	 * @return string
	 */
	final protected function get_called_class()
	{
		$backtrace = debug_backtrace();
		return get_class($backtrace[2]['object']);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'SQLBuilder.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Helper class for building sql statements progmatically.
 *
 * @package ActiveRecord
 */
class SQLBuilder
{
	private $connection;
	private $operation = 'SELECT';
	private $table;
	private $select = '*';
	private $joins;
	private $order;
	private $limit;
	private $offset;
	private $group;
	private $having;
	private $update;

	// for where
	private $where;
	private $where_values = array();

	// for insert/update
	private $data;
	private $sequence;

	/**
	 * Constructor.
	 *
	 * @param Connection $connection A database connection object
	 * @param string $table Name of a table
	 * @return SQLBuilder
	 * @throws ActiveRecordException if connection was invalid
	 */
	public function __construct($connection, $table)
	{
		if (!$connection)
			throw new ActiveRecordException('A valid database connection is required.');

		$this->connection	= $connection;
		$this->table		= $table;
	}

	/**
	 * Returns the SQL string.
	 *
	 * @return string
	 */
	public function __toString()
	{
		return $this->to_s();
	}

	/**
	 * Returns the SQL string.
	 *
	 * @see __toString
	 * @return string
	 */
	public function to_s()
	{
		$func = 'build_' . strtolower($this->operation);
		return $this->$func();
	}

	/**
	 * Returns the bind values.
	 *
	 * @return array
	 */
	public function bind_values()
	{
		$ret = array();

		if ($this->data)
			$ret = array_values($this->data);

		if ($this->get_where_values())
			$ret = array_merge($ret,$this->get_where_values());

		return array_flatten($ret);
	}

	public function get_where_values()
	{
		return $this->where_values;
	}

	public function where(/* (conditions, values) || (hash) */)
	{
		$this->apply_where_conditions(func_get_args());
		return $this;
	}

	public function order($order)
	{
		$this->order = $order;
		return $this;
	}

	public function group($group)
	{
		$this->group = $group;
		return $this;
	}

	public function having($having)
	{
		$this->having = $having;
		return $this;
	}

	public function limit($limit)
	{
		$this->limit = intval($limit);
		return $this;
	}

	public function offset($offset)
	{
		$this->offset = intval($offset);
		return $this;
	}

	public function select($select)
	{
		$this->operation = 'SELECT';
		$this->select = $select;
		return $this;
	}

	public function joins($joins)
	{
		$this->joins = $joins;
		return $this;
	}

	public function insert($hash, $pk=null, $sequence_name=null)
	{
		if (!is_hash($hash))
			throw new ActiveRecordException('Inserting requires a hash.');

		$this->operation = 'INSERT';
		$this->data = $hash;

		if ($pk && $sequence_name)
			$this->sequence = array($pk,$sequence_name);

		return $this;
	}

	public function update($mixed)
	{
		$this->operation = 'UPDATE';

		if (is_hash($mixed))
			$this->data = $mixed;
		elseif (is_string($mixed))
			$this->update = $mixed;
		else
			throw new ActiveRecordException('Updating requires a hash or string.');

		return $this;
	}

	public function delete()
	{
		$this->operation = 'DELETE';
		$this->apply_where_conditions(func_get_args());
		return $this;
	}

	/**
	 * Reverses an order clause.
	 */
	public static function reverse_order($order)
	{
		if (!trim($order))
			return $order;

		$parts = explode(',',$order);

		for ($i=0,$n=count($parts); $i<$n; ++$i)
		{
			$v = strtolower($parts[$i]);

			if (strpos($v,' asc') !== false)
				$parts[$i] = preg_replace('/asc/i','DESC',$parts[$i]);
			elseif (strpos($v,' desc') !== false)
				$parts[$i] = preg_replace('/desc/i','ASC',$parts[$i]);
			else
				$parts[$i] .= ' DESC';
		}
		return join(',',$parts);
	}

	/**
	 * Converts a string like "id_and_name_or_z" into a conditions value like array("id=? AND name=? OR z=?", values, ...).
	 *
	 * @param Connection $connection
	 * @param $name Underscored string
	 * @param $values Array of values for the field names. This is used
	 *	 to determine what kind of bind marker to use: =?, IN(?), IS NULL
	 * @param $map A hash of "mapped_column_name" => "real_column_name"
	 * @return A conditions array in the form array(sql_string, value1, value2,...)
	 */
	public static function create_conditions_from_underscored_string(Connection $connection, $name, &$values=array(), &$map=null)
	{
		if (!$name)
			return null;

		$parts = preg_split('/(_and_|_or_)/i',$name,-1,PREG_SPLIT_DELIM_CAPTURE);
		$num_values = count($values);
		$conditions = array('');

		for ($i=0,$j=0,$n=count($parts); $i<$n; $i+=2,++$j)
		{
			if ($i >= 2)
				$conditions[0] .= preg_replace(array('/_and_/i','/_or_/i'),array(' AND ',' OR '),$parts[$i-1]);

			if ($j < $num_values)
			{
				if (!is_null($values[$j]))
				{
					$bind = is_array($values[$j]) ? ' IN(?)' : '=?';
					$conditions[] = $values[$j];
				}
				else
					$bind = ' IS NULL';
			}
			else
				$bind = ' IS NULL';

			// map to correct name if $map was supplied
			$name = $map && isset($map[$parts[$i]]) ? $map[$parts[$i]] : $parts[$i];

			$conditions[0] .= $connection->quote_name($name) . $bind;
		}
		return $conditions;
	}

	/**
	 * Like create_conditions_from_underscored_string but returns a hash of name => value array instead.
	 *
	 * @param string $name A string containing attribute names connected with _and_ or _or_
	 * @param $args Array of values for each attribute in $name
	 * @param $map A hash of "mapped_column_name" => "real_column_name"
	 * @return array A hash of array(name => value, ...)
	 */
	public static function create_hash_from_underscored_string($name, &$values=array(), &$map=null)
	{
		$parts = preg_split('/(_and_|_or_)/i',$name);
		$hash = array();

		for ($i=0,$n=count($parts); $i<$n; ++$i)
		{
			// map to correct name if $map was supplied
			$name = $map && isset($map[$parts[$i]]) ? $map[$parts[$i]] : $parts[$i];
			$hash[$name] = $values[$i];
		}
		return $hash;
	}
	
	/**
	 * prepends table name to hash of field names to get around ambiguous fields when SQL builder
	 * has joins
	 *
	 * @param array $hash
	 * @return array $new
	 */
	private function prepend_table_name_to_fields($hash=array())
	{
		$new = array();
		$table = $this->connection->quote_name($this->table);

		foreach ($hash as $key => $value)
		{
			$k = $this->connection->quote_name($key);
			$new[$table.'.'.$k] = $value;
		}

		return $new;
	}
	
	private function apply_where_conditions($args)
	{
		$num_args = count($args);

		if ($num_args == 1 && is_hash($args[0]))
		{
			$hash = is_null($this->joins) 
				? $args[0] : $this->prepend_table_name_to_fields($args[0]);
			$e = new Expressions($this->connection,$hash);
			$this->where = $e->to_s();
			$this->where_values = array_flatten($e->values());
		}
		elseif ($num_args > 0)
		{
			// if the values has a nested array then we'll need to use Expressions to expand the bind marker for us
			$values = array_slice($args,1);

			foreach ($values as $name => &$value)
			{
				if (is_array($value))
				{
					$e = new Expressions($this->connection,$args[0]);
					$e->bind_values($values);
					$this->where = $e->to_s();
					$this->where_values = array_flatten($e->values());
					return;
				}
			}

			// no nested array so nothing special to do
			$this->where = $args[0];
			$this->where_values = &$values;
		}
	}

	private function build_delete()
	{
		$sql = "DELETE FROM $this->table";

		if ($this->where)
			$sql .= " WHERE $this->where";

		if ($this->connection->accepts_limit_and_order_for_update_and_delete())
		{
			if ($this->order)
				$sql .= " ORDER BY $this->order";

			if ($this->limit)
				$sql = $this->connection->limit($sql,null,$this->limit);
		}

		return $sql;
	}

	private function build_insert()
	{
		$keys = join(',',$this->quoted_key_names());

		if ($this->sequence)
		{
			$sql =
				"INSERT INTO $this->table($keys," 
				. $this->connection->quote_name($this->sequence[0]) 
				. ") VALUES(?," 
				. $this->connection->next_sequence_value($this->sequence[1]) 
				. ")";
		}
		else
			$sql = "INSERT INTO $this->table($keys) VALUES(?)";

		$e = new Expressions($this->connection,$sql,array_values($this->data));
		return $e->to_s();
	}

	private function build_select()
	{
		$sql = "SELECT $this->select FROM $this->table";

		if ($this->joins)
			$sql .= ' ' . $this->joins;

		if ($this->where)
			$sql .= " WHERE $this->where";

		if ($this->group)
			$sql .= " GROUP BY $this->group";

		if ($this->having)
			$sql .= " HAVING $this->having";

		if ($this->order)
			$sql .= " ORDER BY $this->order";

		if ($this->limit || $this->offset)
			$sql = $this->connection->limit($sql,$this->offset,$this->limit);

		return $sql;
	}

	private function build_update()
	{
		if (strlen($this->update) > 0)
			$set = $this->update;
		else
			$set = join('=?, ', $this->quoted_key_names()) . '=?';

		$sql = "UPDATE $this->table SET $set";

		if ($this->where)
			$sql .= " WHERE $this->where";

		if ($this->connection->accepts_limit_and_order_for_update_and_delete())
		{
			if ($this->order)
				$sql .= " ORDER BY $this->order";

			if ($this->limit)
				$sql = $this->connection->limit($sql,null,$this->limit);
		}

		return $sql;
	}

	private function quoted_key_names()
	{
		$keys = array();

		foreach ($this->data as $key => $value)
			$keys[] = $this->connection->quote_name($key);

		return $keys;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Table.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Manages reading and writing to a database table.
 *
 * This class manages a database table and is used by the Model class for
 * reading and writing to its database table. There is one instance of Table
 * for every table you have a model for.
 *
 * @package ActiveRecord
 */
class Table
{
	private static $cache = array();

	public $class;
	public $conn;
	public $pk;
	public $last_sql;

	// Name/value pairs of columns in this table
	public $columns = array();

	/**
	 * Name of the table.
	 */
	public $table;

	/**
	 * Name of the database (optional)
	 */
	public $db_name;

	/**
	 * Name of the sequence for this table (optional). Defaults to {$table}_seq
	 */
	public $sequence;

	/**
	 * A instance of CallBack for this model/table
	 * @static
	 * @var object ActiveRecord\CallBack
	 */
	public $callback;

	/**
	 * List of relationships for this table.
	 */
	private $relationships = array();

	public static function load($model_class_name)
	{
		$model_class_name = add_namespace($model_class_name);
		if (!isset(self::$cache[$model_class_name]))
		{
			/* do not place set_assoc in constructor..it will lead to infinite loop due to
			   relationships requesting the model's table, but the cache hasn't been set yet */
			self::$cache[$model_class_name] = new Table($model_class_name);
			self::$cache[$model_class_name]->set_associations();
		}

		return self::$cache[$model_class_name];
	}

	public static function clear_cache($model_class_name=null)
	{
		if ($model_class_name && array_key_exists($model_class_name,self::$cache))
			unset(self::$cache[$model_class_name]);
		else
			self::$cache = array();
	}

	public function __construct($class_name)
	{
		$this->class =
			Reflections::instance()->add($class_name)->get($class_name);

		$this->reestablish_connection(false);
		$this->set_table_name();
		$this->get_meta_data();
		$this->set_primary_key();
		$this->set_sequence_name();
		$this->set_delegates();

		$this->callback = new CallBack($class_name);
		$this->callback->register(
			'before_save', 
			function(Model $model) {   
				$model->set_timestamps(); 
			}, 
			array('prepend' => true)
		);
		$this->callback->register(
			'after_save', 
			function(Model $model) { 
				$model->reset_dirty(); 
			}, 
			array('prepend' => true)
		);
	}
	
	public function reestablish_connection($close=true)
	{
		// if connection name property is null the connection manager 
		// will use the default connection
		$connection = $this->class->getStaticPropertyValue('connection',null);

		if ($close)
		{
			ConnectionManager::drop_connection($connection);
			static::clear_cache();
		}

		return ($this->conn = ConnectionManager::get_connection($connection));
	}

	public function create_joins($joins)
	{
		if (!is_array($joins))
			return $joins;

		$self = $this->table;
		$ret = $space = '';

		$existing_tables = array();
		foreach ($joins as $value)
		{
			$ret .= $space;

			if (stripos($value,'JOIN ') === false)
			{
				if (array_key_exists($value, $this->relationships))
				{
					$rel = $this->get_relationship($value);

					// if there is more than 1 join for a given table we need to alias the table names
					if (array_key_exists($rel->class_name, $existing_tables))
					{
						$alias = $value;
						$existing_tables[$rel->class_name]++;
					}
					else
					{
						$existing_tables[$rel->class_name] = true;
						$alias = null;
					}

					$ret .= $rel->construct_inner_join_sql($this, false, $alias);
				}
				else
					throw new RelationshipException("Relationship named $value has not been declared for class: {$this->class->getName()}");
			}
			else
				$ret .= $value;

			$space = ' ';
		}
		return $ret;
	}

	public function options_to_sql($options)
	{
		$table = array_key_exists('from', $options) ? $options['from'] : $this->get_fully_qualified_table_name();
		$sql = new SQLBuilder($this->conn, $table);

		if (array_key_exists('joins',$options))
		{
			$sql->joins($this->create_joins($options['joins']));

			// by default, an inner join will not fetch the fields from the joined table
			if (!array_key_exists('select', $options))
				$options['select'] = $this->get_fully_qualified_table_name() . '.*';
		}

		if (array_key_exists('select',$options))
			$sql->select($options['select']);

		if (array_key_exists('conditions',$options))
		{
			if (!is_hash($options['conditions']))
			{
				if (is_string($options['conditions']))
					$options['conditions'] = array($options['conditions']);

				call_user_func_array(array($sql,'where'),$options['conditions']);
			}
			else
			{
				if (!empty($options['mapped_names']))
					$options['conditions'] = $this->map_names($options['conditions'],$options['mapped_names']);

				$sql->where($options['conditions']);
			}
		}

		if (array_key_exists('order',$options))
			$sql->order($options['order']);

		if (array_key_exists('limit',$options))
			$sql->limit($options['limit']);

		if (array_key_exists('offset',$options))
			$sql->offset($options['offset']);

		if (array_key_exists('group',$options))
			$sql->group($options['group']);

		if (array_key_exists('having',$options))
			$sql->having($options['having']);

		return $sql;
	}

	public function find($options)
	{
		$sql = $this->options_to_sql($options);
		$readonly = (array_key_exists('readonly',$options) && $options['readonly']) ? true : false;
		$eager_load = array_key_exists('include',$options) ? $options['include'] : null;

		return $this->find_by_sql($sql->to_s(),$sql->get_where_values(), $readonly, $eager_load);
	}

	public function find_by_sql($sql, $values=null, $readonly=false, $includes=null)
	{
		$this->last_sql = $sql;

		$collect_attrs_for_includes = is_null($includes) ? false : true;
		$list = $attrs = array();
		$sth = $this->conn->query($sql,$this->process_data($values));

		while (($row = $sth->fetch()))
		{
			$model = new $this->class->name($row,false,true,false);

			if ($readonly)
				$model->readonly();

			if ($collect_attrs_for_includes)
				$attrs[] = $model->attributes();

			$list[] = $model;
		}

		if ($collect_attrs_for_includes && !empty($list))
			$this->execute_eager_load($list, $attrs, $includes);

		return $list;
	}

	/**
	 * Executes an eager load of a given named relationship for this table.
	 *
	 * @param $models array found models for this table
	 * @param $attrs array of attrs from $models
	 * @param $includes array eager load directives
	 * @return void
	 */
	private function execute_eager_load($models=array(), $attrs=array(), $includes=array())
	{
		if (!is_array($includes))
			$includes = array($includes);

		foreach ($includes as $index => $name)
		{
			// nested include
			if (is_array($name))
			{
				$nested_includes = count($name) > 1 ? $name : $name[0];
				$name = $index;
			}
			else
				$nested_includes = array();

			$rel = $this->get_relationship($name, true);
			$rel->load_eagerly($models, $attrs, $nested_includes, $this);
		}
	}

	public function get_column_by_inflected_name($inflected_name)
	{
		foreach ($this->columns as $raw_name => $column)
		{
			if ($column->inflected_name == $inflected_name)
				return $column;
		}
		return null;
	}

	public function get_fully_qualified_table_name($quote_name=true)
	{
		$table = $quote_name ? $this->conn->quote_name($this->table) : $this->table;

		if ($this->db_name)
			$table = $this->conn->quote_name($this->db_name) . ".$table";

		return $table;
	}

	/**
	 * Retrieve a relationship object for this table. Strict as true will throw an error
	 * if the relationship name does not exist.
	 *
	 * @param $name string name of Relationship
	 * @param $strict bool
	 * @throws RelationshipException
	 * @return Relationship or null
	 */
	public function get_relationship($name, $strict=false)
	{
		if ($this->has_relationship($name))
			return $this->relationships[$name];

		if ($strict)
			throw new RelationshipException("Relationship named $name has not been declared for class: {$this->class->getName()}");

		return null;
	}

	/**
	 * Does a given relationship exist?
	 *
	 * @param $name string name of Relationship
	 * @return bool
	 */
	public function has_relationship($name)
	{
		return array_key_exists($name, $this->relationships);
	}

	public function insert(&$data, $pk=null, $sequence_name=null)
	{
		$data = $this->process_data($data);

		$sql = new SQLBuilder($this->conn,$this->get_fully_qualified_table_name());
		$sql->insert($data,$pk,$sequence_name);

		$values = array_values($data);
		return $this->conn->query(($this->last_sql = $sql->to_s()),$values);
	}

	public function update(&$data, $where)
	{
		$data = $this->process_data($data);

		$sql = new SQLBuilder($this->conn,$this->get_fully_qualified_table_name());
		$sql->update($data)->where($where);

		$values = $sql->bind_values();
		return $this->conn->query(($this->last_sql = $sql->to_s()),$values);
	}

	public function delete($data)
	{
		$data = $this->process_data($data);

		$sql = new SQLBuilder($this->conn,$this->get_fully_qualified_table_name());
		$sql->delete($data);

		$values = $sql->bind_values();
		return $this->conn->query(($this->last_sql = $sql->to_s()),$values);
	}

	/**
	 * Add a relationship.
	 *
	 * @param Relationship $relationship a Relationship object
	 */
	private function add_relationship($relationship)
	{
		$this->relationships[$relationship->attribute_name] = $relationship;
	}

	private function get_meta_data()
	{
		// as more adapters are added probably want to do this a better way
		// than using instanceof but gud enuff for now
		$quote_name = !($this->conn instanceof PgsqlAdapter);

		$table_name = $this->get_fully_qualified_table_name($quote_name);
		$conn = $this->conn;
		$this->columns = Cache::get("get_meta_data-$table_name", 
			function() use ($conn, $table_name) { 
				return $conn->columns($table_name); 
			}
		);
	}

	/**
	 * Replaces any aliases used in a hash based condition.
	 *
	 * @param $hash array A hash
	 * @param $map array Hash of used_name => real_name
	 * @return array Array with any aliases replaced with their read field name
	 */
	private function map_names(&$hash, &$map)
	{
		$ret = array();

		foreach ($hash as $name => &$value)
		{
			if (array_key_exists($name,$map))
				$name = $map[$name];

			$ret[$name] = $value;
		}
		return $ret;
	}

	private function &process_data($hash)
	{
		foreach ($hash as $name => &$value)
		{
			if ($value instanceof \DateTime)
			{
				if (isset($this->columns[$name]) 
					&& $this->columns[$name]->type == Column::DATE)
					$hash[$name] = $this->conn->date_to_string($value);
				else
					$hash[$name] = $this->conn->datetime_to_string($value);
			}
			else
				$hash[$name] = $value;
		}
		return $hash;
	}

	private function set_primary_key()
	{
		if (($pk = $this->class->getStaticPropertyValue('pk',null)) || ($pk = $this->class->getStaticPropertyValue('primary_key',null)))
			$this->pk = is_array($pk) ? $pk : array($pk);
		else
		{
			$this->pk = array();

			foreach ($this->columns as $c)
			{
				if ($c->pk)
					$this->pk[] = $c->inflected_name;
			}
		}
	}

	private function set_table_name()
	{
		if (($table = $this->class->getStaticPropertyValue('table',null)) || ($table = $this->class->getStaticPropertyValue('table_name',null)))
			$this->table = $table;
		else
		{
			// infer table name from the class name
			$this->table = Inflector::instance()->tableize($this->class->getName());

			// strip namespaces from the table name if any
			$parts = explode('\\',$this->table);
			$this->table = $parts[count($parts)-1];
		}

		if(($db = $this->class->getStaticPropertyValue('db',null)) || ($db = $this->class->getStaticPropertyValue('db_name',null)))
			$this->db_name = $db;
	}

	private function set_sequence_name()
	{
		if (!$this->conn->supports_sequences())
			return;

		if (!($this->sequence = $this->class->getStaticPropertyValue('sequence')))
			$this->sequence = $this->conn->get_sequence_name($this->table,$this->pk[0]);
	}

	private function set_associations()
	{
		foreach ($this->class->getStaticProperties() as $name => $definitions)
		{
			if (!$definitions || !is_array($definitions))
				continue;
			
			foreach ($definitions as $definition)
			{
				$relationship = null;
				
				switch ($name)
				{
					case 'has_many':
						$relationship = new HasMany($definition);
						break;

					case 'has_one':
						$relationship = new HasOne($definition);
						break;

					case 'belongs_to':
						$relationship = new BelongsTo($definition);
						break;

					case 'has_and_belongs_to_many':
						$relationship = new HasAndBelongsToMany($definition);
						break;
				}

				if ($relationship)
					$this->add_relationship($relationship);
			}
		}
	}

	/**
	 * Rebuild the delegates array into format that we can more easily work with in Model.
	 * Will end up consisting of array of:
	 *
	 * array('delegate' => array('field1','field2',...),
	 *		 'to'		=> 'delegate_to_relationship',
	 *		 'prefix'	=> 'prefix')
	 */
	private function set_delegates()
	{
		$delegates = $this->class->getStaticPropertyValue('delegate', array());
		$new = array();
		
		if (!array_key_exists('processed', $delegates))
		{
			// normalize
			if (!empty($delegates))
				$delegates = array($delegates);
				
			$delegates['processed'] = false;
		}
		
		if (!$delegates['processed'])
		{
			foreach ($delegates as &$delegate)
			{
				if (!is_array($delegate) || !isset($delegate['to']))
					continue;

				if (!isset($delegate['prefix']))
					$delegate['prefix'] = null;

				$new_delegate = array(
					'to'		=> $delegate['to'],
					'prefix'	=> $delegate['prefix'],
					'delegate'	=> array());

				foreach ($delegate as $name => $value)
				{
					if (is_numeric($name))
						$new_delegate['delegate'][] = $value;
				}

				$new[] = $new_delegate;
			}

			$new['processed'] = true;
			$this->class->setStaticPropertyValue('delegate',$new);
		}
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Utils.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Some internal utility functions.
 *
 * @package ActiveRecord
 */
class Utils
{
	public static function extract_options($options)
	{
		return is_array(end($options)) ? end($options) : array();
	}

	public static function add_condition(&$conditions=array(), $condition, $conjuction='AND')
	{
		if (is_array($condition))
		{
			if (empty($conditions))
				$conditions = array_flatten($condition);
			else
			{
				$conditions[0] .= " $conjuction " . array_shift($condition);
				$conditions[] = array_flatten($condition);
			}
		}
		elseif (is_string($condition))
			$conditions[0] .= " $conjuction $condition";

		return $conditions;
	}

	public static function is_odd($number)
	{
		return $number & 1;
	}

	public static function is_a($type, $var)
	{
		switch($type)
		{
			case 'range':
				if (is_array($var) && (int)$var[0] < (int)$var[1])
					return true;

		}

		return false;
	}

	public static function is_blank($var)
	{
		return 0 === strlen($var);
	}

	private static $plural = array(
		'/(quiz)$/i'			   => "$1zes",
		'/^(ox)$/i'				   => "$1en",
		'/([m|l])ouse$/i'		   => "$1ice",
		'/(matr|vert|ind)ix|ex$/i' => "$1ices",
		'/(x|ch|ss|sh)$/i'		   => "$1es",
		'/([^aeiouy]|qu)y$/i'	   => "$1ies",
		'/(hive)$/i'			   => "$1s",
		'/(?:([^f])fe|([lr])f)$/i' => "$1$2ves",
		'/(shea|lea|loa|thie)f$/i' => "$1ves",
		'/sis$/i'				   => "ses",
		'/([ti])um$/i'			   => "$1a",
		'/(tomat|potat|ech|her|vet)o$/i'=> "$1oes",
		'/(bu)s$/i'				   => "$1ses",
		'/(alias)$/i'			   => "$1es",
		'/(octop)us$/i'			   => "$1i",
		'/(ax|test)is$/i'		   => "$1es",
		'/(us)$/i'				   => "$1es",
		'/s$/i'					   => "s",
		'/$/'					   => "s"
	);

	private static $singular = array(
		'/(quiz)zes$/i'				=> "$1",
		'/(matr)ices$/i'			=> "$1ix",
		'/(vert|ind)ices$/i'		=> "$1ex",
		'/^(ox)en$/i'				=> "$1",
		'/(alias)es$/i'				=> "$1",
		'/(octop|vir)i$/i'			=> "$1us",
		'/(cris|ax|test)es$/i'		=> "$1is",
		'/(shoe)s$/i'				=> "$1",
		'/(o)es$/i'					=> "$1",
		'/(bus)es$/i'				=> "$1",
		'/([m|l])ice$/i'			=> "$1ouse",
		'/(x|ch|ss|sh)es$/i'		=> "$1",
		'/(m)ovies$/i'				=> "$1ovie",
		'/(s)eries$/i'				=> "$1eries",
		'/([^aeiouy]|qu)ies$/i'		=> "$1y",
		'/([lr])ves$/i'				=> "$1f",
		'/(tive)s$/i'				=> "$1",
		'/(hive)s$/i'				=> "$1",
		'/(li|wi|kni)ves$/i'		=> "$1fe",
		'/(shea|loa|lea|thie)ves$/i'=> "$1f",
		'/(^analy)ses$/i'			=> "$1sis",
		'/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i'	=> "$1$2sis",
		'/([ti])a$/i'				=> "$1um",
		'/(n)ews$/i'				=> "$1ews",
		'/(h|bl)ouses$/i'			=> "$1ouse",
		'/(corpse)s$/i'				=> "$1",
		'/(us)es$/i'				=> "$1",
		'/(us|ss)$/i'				=> "$1",
		'/s$/i'						=> ""
	);

	private static $irregular = array(
		'move'	 => 'moves',
		'foot'	 => 'feet',
		'goose'	 => 'geese',
		'sex'	 => 'sexes',
		'child'	 => 'children',
		'man'	 => 'men',
		'tooth'	 => 'teeth',
		'person' => 'people'
	);

	private static $uncountable = array(
		'sheep',
		'fish',
		'deer',
		'series',
		'species',
		'money',
		'rice',
		'information',
		'equipment'
	);

	public static function pluralize( $string )
	{
		// save some time in the case that singular and plural are the same
		if ( in_array( strtolower( $string ), self::$uncountable ) )
			return $string;

		// check for irregular singular forms
		foreach ( self::$irregular as $pattern => $result )
		{
			$pattern = '/' . $pattern . '$/i';

			if ( preg_match( $pattern, $string ) )
				return preg_replace( $pattern, $result, $string);
		}

		// check for matches using regular expressions
		foreach ( self::$plural as $pattern => $result )
		{
			if ( preg_match( $pattern, $string ) )
				return preg_replace( $pattern, $result, $string );
		}

		return $string;
	}

	public static function singularize($string)
	{	 
		// save some time in the case that singular and plural are the same
		if ( in_array( strtolower( $string ), self::$uncountable ) )
			return $string;

		// check for irregular plural forms
		foreach ( self::$irregular as $result => $pattern )
		{
			$pattern = '/' . $pattern . '$/i';

			if ( preg_match( $pattern, $string ) )
				return preg_replace( $pattern, $result, $string);
		}

		// check for matches using regular expressions
		foreach ( self::$singular as $pattern => $result )
		{
			if ( preg_match( $pattern, $string ) )
				return preg_replace( $pattern, $result, $string );
		}

		return $string;
	}

	public static function pluralize_if($count, $string)
	{
		if ($count == 1)
			return $string;
		else
			return self::pluralize($string);
	}

	public static function squeeze($char, $string)
	{
		return preg_replace("/$char+/",$char,$string);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Memcache.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
class Memcache
{
	private $memcache;

	public function __construct($options)
	{
		$this->memcache = new \Memcache();

		if (!$this->memcache->connect($options['host'], $options['port']))
			throw new CacheException("Could not connect to $options[host]:$options[port]");
	}

	public function flush()
	{
		$this->memcache->flush();
	}

	public function read($key)
	{
		return $this->memcache->get($key);
	}

	public function write($key, $value, $expire)
	{
		$this->memcache->set($key,$value,null,$expire);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Cache.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * <code>
 * Cache::get('the-cache-key', function() {
 * # this gets executed when cache is stale
 * return "your cacheable datas";
 * });
 * </code>
 */
class Cache
{
	static $adapter = null;
	static $options = array();

	/**
	 * Initializes the cache.
	 *
	 * @param string $url URL to your cache server
	 * @param array $options Specify additional options
	 */
	public static function initialize($url, $options=array())
	{
		if ($url)
		{
			$url = parse_url($url);
			$file = ucwords(Inflector::instance()->camelize($url['scheme']));
			$class = "ActiveRecord\\$file";
			static::$adapter = new $class($url);
		}
		else
			static::$adapter = null;

		static::$options = array_merge(array('expire' => 30),$options);
	}

	public static function flush()
	{
		if (static::$adapter)
			static::$adapter->flush();
	}

	public static function get($key, $closure)
	{
		if (!static::$adapter)
			return $closure();

		if (!($value = static::$adapter->read($key)))
			static::$adapter->write($key,($value = $closure()),static::$options['expire']);

		return $value;
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Validations.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Manages validations for a {@link Model}.
 *
 * This class isn't meant to be directly used. Instead you define
 * validators thru static variables in your {@link Model}. Example:
 *
 * <code>
 * class Person extends ActiveRecord\Model {
 *	 static $validates_length_of = array(
 *	   array('name', 'within' => array(30,100),
 *	   array('state', 'is' => 2)
 *	 );
 * }
 *
 * $person = new Person();
 * $person->name = 'Tito';
 * $person->state = 'this is not two characters';
 *
 * if (!$person->is_valid())
 *	 print_r($person->errors);
 * </code>
 *
 * @package ActiveRecord
 * @see Errors
 * @link http://www.phpactiverecord.org/guides/validations
 */
class Validations
{
	private $model;
	private $options = array();
	private $validators = array();
	private $record;

	private static $VALIDATION_FUNCTIONS = array(
		'validates_presence_of',
		'validates_size_of',
		'validates_length_of',
		'validates_inclusion_of',
		'validates_exclusion_of',
		'validates_format_of',
		'validates_numericality_of',
		'validates_uniqueness_of'
	);

	private static $DEFAULT_VALIDATION_OPTIONS = array(
		'on' => 'save',
		'allow_null' => false,
		'allow_blank' => false,
		'message' => null,
	);

	private static	$ALL_RANGE_OPTIONS = array(
		'is' => null,
		'within' => null,
		'in' => null,
		'minimum' => null,
		'maximum' => null,
	);

	private static $ALL_NUMERICALITY_CHECKS = array(
		'greater_than' => null,
		'greater_than_or_equal_to'	=> null,
		'equal_to' => null,
		'less_than' => null,
		'less_than_or_equal_to' => null,
		'odd' => null,
		'even' => null
	);

	/**
	 * Constructs a {@link Validations} object.
	 *
	 * @param Model $model The model to validate
	 * @return Validations
	 */
	public function __construct($model)
	{
		$this->model = $model;
		$this->record = new Errors($this->model);
		$this->klass = Reflections::instance()->get(get_class($this->model));
		$this->validators =
			array_intersect(array_keys($this->klass->getStaticProperties()),		
			self::$VALIDATION_FUNCTIONS);
	}

	public function get_record()
	{
		return $this->record;
	}	 
	
	/**
	 * Normalizes static definitions (e.g. wraps string definitions 
	 * (if any) into arrays).
	 */
	private static function normalize_definitions($definitions)
	{	
		if ((array) $definitions !== $definitions)
			return array(array($definitions));

		$normalized_definitions = array();
		$outer_options = array();

		foreach ($definitions as $key => $body)
		{	
			if ((string) $key === $key)
				$outer_options[$key] = $body;
			elseif ((array) $body === $body)
			{	 
				$inner_options = array();

				foreach ($body as $k => $v)
				{
					if ((string) $k === $k)
					{
						$inner_options[$k] = $v;
						unset($body[$k]);
					}
				}

				foreach ($body as $b)
					$normalized_definitions[] = array($b) + $inner_options;
			}
			else
				$normalized_definitions[] = array($body);						 
		}

		if ($outer_options)
		{
			foreach ($normalized_definitions as &$nd)
				$nd += $outer_options;
		}

		return $normalized_definitions;
	}

	/**
	 * Returns validator data.
	 *
	 * @return array
	 */
	public function rules()
	{
		$data = array();

		foreach ($this->validators as $validate)
		{
			$attrs = $this->klass->getStaticPropertyValue($validate);
			
			foreach (self::normalize_definitions($attrs) as $attr)
			{
				$field = $attr[0];

				if (!isset($data[$field]) || !is_array($data[$field]))
					$data[$field] = array();

				$attr['validator'] = $validate;
				unset($attr[0]);
				array_push($data[$field],$attr);
			}
		}
		return $data;
	}

	/**
	 * Runs the validators.
	 *
	 * @return Errors the validation errors if any
	 */
	public function validate()
	{	
		foreach ($this->validators as $validate)
		{
			$definition = $this->klass->getStaticPropertyValue($validate);
			$this->$validate(self::normalize_definitions($definition));
		}
		
		$model_reflection = Reflections::instance()->get($this->model);
		if ($model_reflection->hasMethod('validate') 
			&& $model_reflection->getMethod('validate')->isPublic())
			$this->model->validate();
		
		$this->record->clear_model();
		return $this->record;
	}

	/**
	 * Validates a field is not null and not blank.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $validates_presence_of = array(
	 *	   array('first_name'),
	 *	   array('last_name')
	 *	 );
	 * }
	 * </code>
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>message:</b> custom error message</li>
	 * </ul>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_presence_of($attrs)
	{
		$configuration = array_merge(self::$DEFAULT_VALIDATION_OPTIONS, array('message' => Errors::$DEFAULT_ERROR_MESSAGES['blank'], 'on' => 'save'));

		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$this->record->add_on_blank($options[0], $options['message']);
		}
	}

	/**
	 * Validates that a value is included the specified array.
	 *
	 * <code>
	 * class Car extends ActiveRecord\Model {
	 *	 static $validates_inclusion_of = array(
	 *	   array('fuel_type', 'in' => array('hyrdogen', 'petroleum', 'electric')),
	 *	 );
	 * }
	 * </code>
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>in/within:</b> attribute should/shouldn't be a value within an array</li>
	 * <li><b>message:</b> custome error message</li>
	 * </ul>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_inclusion_of($attrs)
	{
		$this->validates_inclusion_or_exclusion_of('inclusion', $attrs);
	}

	/**
	 * This is the opposite of {@link validates_include_of}.
	 *
	 * @param array $attrs Validation definition
	 * @see validates_inclusion_of
	 */
	public function validates_exclusion_of($attrs)
	{
		$this->validates_inclusion_or_exclusion_of('exclusion', $attrs);
	}

	/**
	 * Validates that a value is in or out of a specified list of values.
	 *
	 * @see validates_inclusion_of
	 * @see validates_exclusion_of
	 * @param string $type Either inclusion or exclusion
	 * @param $attrs Validation definition
	 */
	public function validates_inclusion_or_exclusion_of($type, $attrs)
	{
		$configuration = array_merge(self::$DEFAULT_VALIDATION_OPTIONS, array('message' => Errors::$DEFAULT_ERROR_MESSAGES[$type], 'on' => 'save'));

		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$attribute = $options[0];
			$var = $this->model->$attribute;

			if (isset($options['in']))
				$enum = $options['in'];
			elseif (isset($options['within']))
				$enum = $options['within'];

			if (!is_array($enum))
				array($enum);

			$message = str_replace('%s', $var, $options['message']);

			if ($this->is_null_with_option($var, $options) || $this->is_blank_with_option($var, $options))
				continue;

			if (('inclusion' == $type && !in_array($var, $enum)) || ('exclusion' == $type && in_array($var, $enum)))
				$this->record->add($attribute, $message);
		}
	}

	/**
	 * Validates that a value is numeric.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	   static $validates_numericality_of = array(
	 *		   array('salary', 'greater_than' => 19.99, 'less_than' => 99.99)
	 *	   );
	 * }
	 * </code>
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>only_integer:</b> value must be an integer (e.g. not a float)</li>
	 * <li><b>even:</b> must be even</li>
	 * <li><b>odd:</b> must be odd"</li>
	 * <li><b>greater_than:</b> must be greater than specified number</li>
	 * <li><b>greater_than_or_equal_to:</b> must be greater than or equal to specified number</li>
	 * <li><b>equal_to:</b> ...</li>
	 * <li><b>less_than:</b> ...</li>
	 * <li><b>less_than_or_equal_to:</b> ...</li>
	 * </ul>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_numericality_of($attrs)
	{
		$configuration = array_merge(
			self::$DEFAULT_VALIDATION_OPTIONS,	   
			array('only_integer' => false)
		);

		// Notice that for fixnum and float columns empty strings are converted to nil.
		// Validates whether the value of the specified attribute is numeric by trying to convert it to a float with Kernel.Float
		// (if only_integer is false) or applying it to the regular expression /\A[+\-]?\d+\Z/ (if only_integer is set to true).
		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$attribute = $options[0];
			$var = $this->model->$attribute;

			$numericalityOptions =
				array_intersect_key(self::$ALL_NUMERICALITY_CHECKS, $options);

			if ($this->is_null_with_option($var, $options))
				continue;

			$not_a_number_message = isset($options['message']) 
				? $options['message'] 
				: Errors::$DEFAULT_ERROR_MESSAGES['not_a_number'];

			if (true === $options['only_integer'] && !is_integer($var))
			{
				if (!preg_match('/\A[+-]?\d+\Z/', (string)($var)))
				{
					$this->record->add($attribute, $not_a_number_message);
					continue;
				}
			}
			else
			{
				if (!is_numeric($var))
				{
					$this->record->add($attribute, $not_a_number_message);
					continue;
				}

				$var = (float)$var;
			}

			foreach ($numericalityOptions as $option => $check)
			{
				$option_value = $options[$option];
				$message = isset($options['message']) 
					? $options['message'] 
					: Errors::$DEFAULT_ERROR_MESSAGES[$option];

				if ('odd' != $option && 'even' != $option)
				{
					$option_value = (float)$options[$option];

					if (!is_numeric($option_value))
						throw new ValidationsArgumentError(
							"$option must be a number"
						);

					$message = str_replace('%d', $option_value, $message);

					if ('greater_than' == $option && !($var > $option_value))
						$this->record->add($attribute, $message);
					elseif ('greater_than_or_equal_to' == $option 
						&& !($var >= $option_value))
						$this->record->add($attribute, $message);
					elseif ('equal_to' == $option && !($var == $option_value))
						$this->record->add($attribute, $message);
					elseif ('less_than' == $option && !($var < $option_value))
						$this->record->add($attribute, $message);
					elseif ('less_than_or_equal_to' == $option 
						&& !($var <= $option_value))
					$this->record->add($attribute, $message);
				}
				else
				{
					if (('odd' == $option && !Utils::is_odd($var)) 
						|| ('even' == $option && Utils::is_odd($var)))
						$this->record->add($attribute, $message);
				}
			}
		}
	}

	/**
	 * Alias of {@link validates_length_of}
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_size_of($attrs)
	{
		$this->validates_length_of($attrs);
	}

	/**
	 * Validates that a value is matches a regex.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $validates_format_of = array(
	 *	   array('email', 'with' => '/^.*?@.*$/')
	 *	 );
	 * }
	 * </code>
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>with:</b> a regular expression</li>
	 * <li><b>message:</b> custom error message</li>
	 * </ul>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_format_of($attrs)
	{
		$configuration = array_merge(self::$DEFAULT_VALIDATION_OPTIONS, array('message' => Errors::$DEFAULT_ERROR_MESSAGES['invalid'], 'on' => 'save', 'with' => null));

		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$attribute = $options[0];
			$var = $this->model->$attribute;

			if (is_null($options['with']) || !is_string($options['with']) || !is_string($options['with']))
				throw new ValidationsArgumentError('A regular expression must be supplied as the [with] option of the configuration array.');
			else
				$expression = $options['with'];

			if ($this->is_null_with_option($var, $options) || $this->is_blank_with_option($var, $options))
				continue;

			if (!@preg_match($expression, $var))
			$this->record->add($attribute, $options['message']);
		}
	}

	/**
	 * Validates the length of a value.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $validates_length_of = array(
	 *	   array('name', 'within' => array(1,50))
	 *	 );
	 * }
	 * </code>
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>is:</b> attribute should be exactly n characters long</li>
	 * <li><b>in/within:</b> attribute should be within an range array(min,max)</li>
	 * <li><b>maximum/minimum:</b> attribute should not be above/below respectively</li>
	 * <li><b>message:</b> custome error message</li>
	 * <li><b>allow_blank:</b> allow blank strings</li>
	 * <li><b>allow_null:</b> allow null strings. (Even if this is set to false, a null string is always shorter than a maximum value.)</li>
	 * </ul>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_length_of($attrs)
	{
		$configuration = array_merge(self::$DEFAULT_VALIDATION_OPTIONS, array(
			'too_long' => Errors::$DEFAULT_ERROR_MESSAGES['too_long'],
			'too_short' => Errors::$DEFAULT_ERROR_MESSAGES['too_short'],
			'wrong_length' => Errors::$DEFAULT_ERROR_MESSAGES['wrong_length']
		));

		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$range_options = array_intersect(
				array_keys(self::$ALL_RANGE_OPTIONS), 
				array_keys($attr)
			);
			sort($range_options);

			switch (sizeof($range_options))
			{
				case 0:
					throw new ValidationsArgumentError('Range unspecified. Specify the [within], [maximum], or [is] option.');
				case 1:
					break;
				default:
					throw new ValidationsArgumentError('Too many range options specified. Choose only one.');
			}

			$attribute = $options[0];
			$var = $this->model->$attribute;
			
			if ($this->is_null_with_option($var, $options) 
				|| $this->is_blank_with_option($var, $options))
				continue;
			
			if ($range_options[0] == 'within' || $range_options[0] == 'in')
			{
				$range = $options[$range_options[0]];

				if (!(Utils::is_a('range', $range)))
					throw new ValidationsArgumentError("$range_option must be an array composing a range of numbers with key [0] being less than key [1]");
				
				$range_options = array('minimum', 'maximum');
				$attr['minimum'] = $range[0];
				$attr['maximum'] = $range[1];
			}
			
			foreach ($range_options as $range_option)
			{
				$option = $attr[$range_option];

				if ((int)$option <= 0)
					throw new ValidationsArgumentError("$range_option value cannot use a signed integer.");

				if (is_float($option))
					throw new ValidationsArgumentError("$range_option value cannot use a float for length.");

				if (!($range_option == 'maximum' 
					&& is_null($this->model->$attribute)))
				{
					$messageOptions = array(
						'is' => 'wrong_length', 
						'minimum' => 'too_short', 
						'maximum' => 'too_long'
					);

					if (isset($options['message']))
						$message = $options['message'];
					else
						$message = $options[$messageOptions[$range_option]];


					$message = str_replace('%d', $option, $message);
					$attribute_value = $this->model->$attribute;
					$len = strlen($attribute_value);
					$value = (int)$attr[$range_option];

					if ('maximum' == $range_option && $len > $value)
						$this->record->add($attribute, $message);

					if ('minimum' == $range_option && $len < $value)
						$this->record->add($attribute, $message);

					if ('is' == $range_option && $len !== $value)
						$this->record->add($attribute, $message);
				}
			}
		}
	}

	/**
	 * Validates the uniqueness of a value.
	 *
	 * <code>
	 * class Person extends ActiveRecord\Model {
	 *	 static $validates_uniqueness_of = array(
	 *	   array('name'),
	 *	   array(array('blah','bleh'), 'message' => 'blech')
	 *	 );
	 * }
	 * </code>
	 *
	 * @param array $attrs Validation definition
	 */
	public function validates_uniqueness_of($attrs)
	{
		$configuration = array_merge(self::$DEFAULT_VALIDATION_OPTIONS, array(
			'message' => Errors::$DEFAULT_ERROR_MESSAGES['unique']
		));

		foreach ($attrs as $attr)
		{
			$options = array_merge($configuration, $attr);
			$pk = $this->model->get_primary_key();
			$pk_value = $this->model->$pk[0];

			if (is_array($options[0]))
			{
				$add_record = join("_and_", $options[0]);
				$fields = $options[0];
			}
			else
			{
				$add_record = $options[0];
				$fields = array($options[0]);
			}

			$sql = "";
			$conditions = array("");

			if ($pk_value === null)
				$sql = "{$pk[0]} is not null";
			else
			{
				$sql = "{$pk[0]}!=?";
				array_push($conditions,$pk_value);
			}

			foreach ($fields as $field)
			{
				$field = $this->model->get_real_attribute_name($field);
				$sql .= " and {$field}=?";
				array_push($conditions,$this->model->$field);
			}

			$conditions[0] = $sql;

			if ($this->model->exists(array('conditions' => $conditions)))
				$this->record->add($add_record, $options['message']);
		}
	}

	private function is_null_with_option($var, &$options)
	{
		return (is_null($var) && (isset($options['allow_null']) && $options['allow_null']));
	}

	private function is_blank_with_option($var, &$options)
	{
		return (Utils::is_blank($var) && (isset($options['allow_blank']) && $options['allow_blank']));
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'Errors.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Class that holds {@link Validations} errors.
 *
 * @package ActiveRecord
 */
class Errors implements \IteratorAggregate
{
	private $model;
	private $errors;

	public static $DEFAULT_ERROR_MESSAGES = array(
		'inclusion'		=> "is not included in the list",
		'exclusion'		=> "is reserved",
		'invalid'		=> "is invalid",
		'empty'			=> "can't be empty",
		'blank'			=> "can't be blank",
		'too_long'		=> "is too long (maximum is %d characters)",
		'too_short'		=> "is too short (minimum is %d characters)",
		'wrong_length'	=> "is the wrong length (should be %d characters)",
		'not_a_number'	=> "is not a number",
		'greater_than'	=> "must be greater than %d",
		'equal_to'		=> "must be equal to %d",
		'less_than'		=> "must be less than %d",
		'odd'			=> "must be odd",
		'even'			=> "must be even",
		'unique'		=> "must be unique",
		'less_than_or_equal_to' => "must be less than or equal to %d",
		'greater_than_or_equal_to' => "must be greater than or equal to %d"
	);

	/**
	 * Constructs an {@link Errors} object.
	 *
	 * @param $model The model the error is for
	 * @return Errors
	 */
	public function __construct($model)
	{
		$this->model = $model;
	}
	
	/**
	 * Nulls $model so we don't get pesky circular references. 
	 * $model is only needed during the validation process and 
	 * so can be safely cleared once that is done.
	 */
	public function clear_model()
	{
		$this->model = null;
	}

	/**
	 * Add an error message.
	 *
	 * @param string $attribute Name of an attribute on the model
	 * @param string $msg The error message
	 */
	public function add($attribute, $msg)
	{
		if (is_null($msg))
			$msg = self :: $DEFAULT_ERROR_MESSAGES['invalid'];

		if (!isset($this->errors[$attribute]))
			$this->errors[$attribute] = array($msg);
		else
			$this->errors[$attribute][] = $msg;
	}

	/**
	 * Adds an error message only if the attribute value is {@link http://www.php.net/empty empty}.
	 *
	 * @param string $attribute Name of an attribute on the model
	 * @param string $msg The error message
	 */
	public function add_on_empty($attribute, $msg)
	{
		if (empty($msg))
			$msg = self::$DEFAULT_ERROR_MESSAGES['empty'];

		if (empty($this->model->$attribute))
			$this->add($attribute, $msg);
	}

	/**
	 * Retrieve error messages for an attribute.
	 *
	 * @param string $attribute Name of an attribute on the model
	 * @return array or null if there is no error.
	 */
	public function __get($attribute)
	{
		if (!isset($this->errors[$attribute]))
			return null;

		return $this->errors[$attribute];
	}

	/**
	 * Adds the error message only if the attribute value was null or an empty string.
	 * 
	 * FIXED by Szymon Wrozynski to allow 0 value.
	 * @param string $attribute Name of an attribute on the model
	 * @param string $msg The error message
	 */
	public function add_on_blank($attribute, $msg)
	{
		if (!$msg)
			$msg = self::$DEFAULT_ERROR_MESSAGES['blank'];
		
		$var = $this->model->$attribute;

		if (is_numeric($var))
			return;

		if (!$var)
			$this->add($attribute, $msg);
	}

	/**
	 * Returns true if the specified attribute had any error messages.
	 *
	 * @param string $attribute Name of an attribute on the model
	 * @return boolean
	 */
	public function is_invalid($attribute)
	{
		return isset($this->errors[$attribute]);
	}

	/**
	 * Returns the error message(s) for the specified attribute or null if none.
	 *
	 * @param string $attribute Name of an attribute on the model
	 * @return string/array Array of strings if several error occured on this attribute.
	 */
	public function on($attribute)
	{
		$errors = $this->$attribute;
		return $errors && count($errors) == 1 ? $errors[0] : $errors;
	}
	
	/**
	 * Returns the internal errors object.
	 *
	 * <code>
	 * $model->errors->get_raw_errors();
	 *
	 * # array(
	 * # "name" => array("can't be blank"),
	 * # "state" => array("is the wrong length (should be 2 chars)",
	 * # )
	 * </code>
	 */
	public function get_raw_errors()
	{
		return $this->errors;
	}

	/**
	 * Returns all the error messages as an array.
	 *
	 * <code>
	 * $model->errors->full_messages();
	 *
	 * # array(
	 * #  "Name can't be blank",
	 * #  "State is the wrong length (should be 2 chars)"
	 * # )
	 * </code>
	 *
	 * @param mixed $separator Separator used between a name and a message. 
	 *	   If empty the name will be omitted. Default: ' '
	 * @param bool $localize Explicitly turns on/off localization (true/false)
	 * @return array
	 */
	public function full_messages($separator=' ', $localize=null)
	{
		$full_messages = array();
		
		$this->to_array(
			$separator, 
			$localize, 
			function($a, $m) use (&$full_messages) { $full_messages[] = $m; }
		);
		
		return $full_messages;
	}
	
	/**
	 * Returns all the error messages as an array, including error key.
	 *
	 * <code>
	 * $model->errors->to_array();
	 *
	 * # array(
	 * # "name" => array("Name can't be blank"),
	 * # "state" => array("State is the wrong length (should be 2 chars))"
	 * # )
	 * </code>
	 *
	 * @param mixed $separator Separator used between a name and a message. 
	 *	   If empty the name will be omitted. Default: ' '
	 * @param bool $localize Explicitly turns on/off localization (true/false)
	 * @param \Closure $closure Closure to fetch the errors in some other format
	 *	   (optional). This closure has the signature function($attribute, 
	 *	   $message) and is called for each available error message.
	 * @return array
	 */
	public function to_array($separator=' ', $localize=null, $closure=null)
	{
		$errors = array();
		
		static $localization;
		
		if (!isset($localization))
			$localization = \Application\Configuration::instance()->localization;
			
		if ($this->errors)
		{
			if ($localize === null)
				$localize = ($localization !== false);
			
			foreach ($this->errors as $attr => $error_messages)
			{
				foreach ($error_messages as $em)
				{
					if ($em === null)
						continue;
						
					if (!$separator)
						$msg = $localize ? t($em) : $em;
					elseif ($localize)
						$msg = t($attr) . $separator . t($em);
					else
						$msg=ucfirst(str_replace('_',' ',$attr)).$separator.$em;
					
					$errors[$attr][] = $msg;
					
					if ($closure)
						$closure($attr, $msg);
				}
			}
		}
		
		return $errors;
	}

	/**
	 * Returns true if there are no error messages.
	 * @return boolean
	 */
	public function is_empty()
	{
		return empty($this->errors);
	}

	/**
	 * Clears out all error messages.
	 */
	public function clear()
	{
		$this->errors = array();
	}

	/**
	 * Returns the number of error messages there are.
	 * @return int
	 */
	public function size()
	{
		if ($this->is_empty())
			return 0;

		$count = 0;

		foreach ($this->errors as $attribute => $error)
			$count += count($error);

		return $count;
	}
	
	/**
	 * Convert all error messages to a String.
	 * This function is called implicitely if the object is casted to a string:
	 *
	 * <code>
	 * echo $error;
	 *
	 * # "Name can't be blank\nState is the wrong length (should be 2 chars)"
	 * </code>
	 * @return string
	 */
	public function __toString()
	{
		return implode("\n", $this->full_messages());
	}

	/**
	 * Returns an iterator to the error messages.
	 *
	 * This will allow you to iterate over the {@link Errors} object using foreach.
	 *
	 * <code>
	 * foreach ($model->errors as $msg)
	 *	 echo "$msg\n";
	 * </code>
	 *
	 * @return \ArrayIterator
	 */
	public function getIterator()
	{
		return new \ArrayIterator($this->full_messages());
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'MysqlAdapter.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
class MysqlAdapter extends Connection
{
	static $DEFAULT_PORT = 3306;
	
	public function limit($sql, $offset, $limit)
	{
		$offset = is_null($offset) ? '' : intval($offset) . ',';
		$limit = intval($limit);
		return "$sql LIMIT {$offset}$limit";
	}

	public function query_column_info($table)
	{
		return $this->query("SHOW COLUMNS FROM $table");
	}

	public function query_for_tables()
	{
		return $this->query('SHOW TABLES');
	}

	public function create_column(&$column)
	{
		$c = new Column();
		$c->inflected_name	= Inflector::instance()->variablize($column['field']);
		$c->name			= $column['field'];
		$c->nullable		= ($column['null'] === 'YES' ? true : false);
		$c->pk				= ($column['key'] === 'PRI' ? true : false);
		$c->auto_increment	= ($column['extra'] === 'auto_increment' ? true : false);

		if ($column['type'] == 'timestamp' || $column['type'] == 'datetime')
		{
			$c->raw_type = 'datetime';
			$c->length = 19;
		}
		elseif ($column['type'] == 'date')
		{
			$c->raw_type = 'date';
			$c->length = 10;
		}
		elseif ($column['type'] == 'time')
		{
			$c->raw_type = 'time';
			$c->length = 8;
		}
		else
		{
			preg_match('/^([A-Za-z0-9_]+)(\(([0-9]+(,[0-9]+)?)\))?/',$column['type'],$matches);

			$c->raw_type = (count($matches) > 0 ? $matches[1] : $column['type']);

			if (count($matches) >= 4)
				$c->length = intval($matches[3]);
		}

		$c->map_raw_type();
		$c->default = $c->cast($column['default'],$this);

		return $c;
	}
	
	public function set_encoding($charset)
	{
		$params = array($charset);
		$this->query('SET NAMES ?',$params);
	}
	
	public function accepts_limit_and_order_for_update_and_delete() 
	{ 
		return true; 
	}
	
	public function native_database_types()
	{
		return array(
			'primary_key' => 'int(11) DEFAULT NULL auto_increment PRIMARY KEY',
			'string' => array('name' => 'varchar', 'length' => 255),
			'text' => array('name' => 'text'),
			'integer' => array('name' => 'int', 'length' => 11),
			'float' => array('name' => 'float'),
			'datetime' => array('name' => 'datetime'),
			'timestamp' => array('name' => 'datetime'),
			'time' => array('name' => 'time'),
			'date' => array('name' => 'date'),
			'binary' => array('name' => 'blob'),
			'boolean' => array('name' => 'tinyint', 'length' => 1)
		);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'TablelessModel.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
class TablelessModel
{
	public $errors;
	private $_callback;

	public function __construct($attributes=null)
	{
		Reflections::instance()->add($this);
		$this->_callback = new CallBack(get_class($this));
		if ($attributes)
			$this->set_attributes($attributes);
	}
	
	public function attributes()
	{
		$attributes = get_public_properties($this);
		unset($attributes['errors']);
		return $attributes;
	}
	
	public function get_validation_rules()
	{
		$validator = new Validations($this);
		return $validator->rules();
	}

	public function get_values_for($attributes)
	{
		$ret = array();
		$public_attributes = $this->attributes();
		foreach ($attributes as $name)
		{
			if (array_key_exists($name, $public_attributes))
				$ret[$name] = $this->$name;
		}
		return $ret;
	}

	public function values_for($attribute_names)
	{
		$filter = array();
		foreach ($attribute_names as $name)
			$filter[$name] = $this->$name;

		return $filter;
	}

	private function _validate()
	{
		$validator = new Validations($this);
		
		if ($this->_callback->invoke($this, 'before_validation', false) 
			=== false)
			return false;
		
		$this->errors = $validator->get_record();
		$validator->validate();
		$this->_callback->invoke($this, 'after_validation', false);
		return $this->errors->is_empty();
	}

	public function is_valid()
	{
		return $this->_validate();
	}

	public function is_invalid()
	{
		return !$this->_validate();
	}
	
	public function update_attributes($attributes)
	{
		$this->set_attributes($attributes);
		return $this->is_valid();
	}

	public function set_attributes($attributes)
	{	
		foreach ($attributes as $name => $value)
		{
			if ($name !== 'errors')
				$this->$name = $value;
		}
	}
	
	public function __get($name)
	{
		$name = "get_$name";
		if (method_exists($this, $name))
			return $this->$name();
		
		throw new UndefinedPropertyException(get_called_class(), $name);
	}

	public function __set($name, $value)
	{		 
		if (method_exists($this, "set_$name"))
		{
			$name = "set_$name";
			return $this->$name($value);
		}
		   
		throw new UndefinedPropertyException(get_called_class(), $name);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'OciAdapter.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Adapter for OCI (not completed yet).
 * 
 * @package ActiveRecord
 */
class OciAdapter extends Connection
{
	static $QUOTE_CHARACTER = '';
	static $DEFAULT_PORT = 1521;

	protected function __construct($info)
	{
		try 
		{
			$this->dsn_params = isset($info->charset) 
				? ";charset=$info->charset" : "";
			$this->connection = 
				new \PDO("oci:dbname=//$info->host/$info->db$this->dsn_params",
					$info->user,$info->pass,static::$PDO_OPTIONS
				);
		} 
		catch (\PDOException $e) 
		{
			throw new DatabaseException($e);
		}
	}

	public function supports_sequences() { return true; }

	public function get_next_sequence_value($sequence_name)
	{
		return $this->query_and_fetch_one('SELECT ' . $this->next_sequence_value($sequence_name) . ' FROM dual');
	}

	public function next_sequence_value($sequence_name)
	{
		return "$sequence_name.nextval";
	}
	
	public function date_to_string($datetime)
	{
		return $datetime->format('d-M-Y');
	}

	public function datetime_to_string($datetime)
	{
		return $datetime->format('d-M-Y h:i:s A');
	}

	// $string = DD-MON-YYYY HH12:MI:SS(\.[0-9]+) AM
	public function string_to_datetime($string)
	{
		return parent::string_to_datetime(str_replace('.000000','',$string));
	}

	public function limit($sql, $offset, $limit)
	{
		$offset = intval($offset);
		$stop = $offset + intval($limit);
		return 
			"SELECT * FROM (SELECT a.*, rownum ar_rnum__ FROM ($sql) a " .
			"WHERE rownum <= $stop) WHERE ar_rnum__ > $offset";
	}

	public function query_column_info($table)
	{
		$sql = 
			"SELECT c.column_name, c.data_type, c.data_length, c.data_scale, c.data_default, c.nullable, " .
				"(SELECT a.constraint_type " .
				"FROM all_constraints a, all_cons_columns b " .
				"WHERE a.constraint_type='P' " .
				"AND a.constraint_name=b.constraint_name " .
				"AND a.table_name = t.table_name AND b.column_name=c.column_name) AS pk " .
			"FROM user_tables t " .
			"INNER JOIN user_tab_columns c on(t.table_name=c.table_name) " .
			"WHERE t.table_name=?";
		$values = array(strtoupper($table));
		return $this->query($sql,$values);
	}

	public function query_for_tables()
	{
		return $this->query("SELECT table_name FROM user_tables");
	}

	public function create_column(&$column)
	{
		$column['column_name'] = strtolower($column['column_name']);
		$column['data_type'] = strtolower(preg_replace('/\(.*?\)/','',$column['data_type']));

		if ($column['data_default'] !== null)
			$column['data_default'] = trim($column['data_default'],"' ");

		if ($column['data_type'] == 'number')
		{
			if ($column['data_scale'] > 0)
				$column['data_type'] = 'decimal';
			elseif ($column['data_scale'] == 0)
				$column['data_type'] = 'int';
		}

		$c = new Column();
		$c->inflected_name	= Inflector::instance()->variablize($column['column_name']);
		$c->name			= $column['column_name'];
		$c->nullable		= $column['nullable'] == 'Y' ? true : false;
		$c->pk				= $column['pk'] == 'P' ? true : false;
		$c->length			= $column['data_length'];

		if ($column['data_type'] == 'timestamp')
			$c->raw_type = 'datetime';
		else
			$c->raw_type = $column['data_type'];

		$c->map_raw_type();
		$c->default = $c->cast($column['data_default'],$this);

		return $c;
	}
	
	public function set_encoding($charset)
	{
		// is handled in the constructor
	}
	
	public function native_database_types()
	{
		return array(
			'primary_key' => "NUMBER(38) NOT NULL PRIMARY KEY",
			'string' => array('name' => 'VARCHAR2', 'length' => 255),
			'text' => array('name' => 'CLOB'),
			'integer' => array('name' => 'NUMBER', 'length' => 38),
			'float' => array('name' => 'NUMBER'),
			'datetime' => array('name' => 'DATE'),
			'timestamp' => array('name' => 'DATE'),
			'time' => array('name' => 'DATE'),
			'date' => array('name' => 'DATE'),
			'binary' => array('name' => 'BLOB'),
			'boolean' => array('name' => 'NUMBER', 'length' => 1)
		);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'PgsqlAdapter.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Adapter for Postgres (not completed yet)
 * 
 * @package ActiveRecord
 */
class PgsqlAdapter extends Connection
{
	static $QUOTE_CHARACTER = '"';
	static $DEFAULT_PORT = 5432;

	public function supports_sequences() 
	{ 
		return true; 
	}
	
	public function get_sequence_name($table, $column_name)
	{
		return "{$table}_{$column_name}_seq";
	}

	public function next_sequence_value($sequence_name)
	{
		return "nextval('" . str_replace("'","\\'",$sequence_name) . "')";
	}

	public function limit($sql, $offset, $limit)
	{
		return $sql . ' LIMIT ' . intval($limit) . ' OFFSET ' . intval($offset);
	}

	public function query_column_info($table)
	{
		$sql = <<<SQL
SELECT a.attname AS field, a.attlen,
REPLACE(pg_catalog.format_type(a.atttypid, a.atttypmod),'character varying','varchar') AS type,
a.attnotnull AS not_nullable, 
i.indisprimary as pk,
REGEXP_REPLACE(REGEXP_REPLACE(REGEXP_REPLACE(s.column_default,'::[a-z_ ]+',''),'\'$',''),'^\'','') AS default
FROM pg_catalog.pg_attribute a
LEFT JOIN pg_catalog.pg_class c ON(a.attrelid=c.oid)
LEFT JOIN pg_catalog.pg_index i ON(c.oid=i.indrelid AND a.attnum=any(i.indkey))
LEFT JOIN information_schema.columns s ON(s.table_name=? AND a.attname=s.column_name)
WHERE a.attrelid = (select c.oid from pg_catalog.pg_class c inner join pg_catalog.pg_namespace n on(n.oid=c.relnamespace) where c.relname=? and pg_catalog.pg_table_is_visible(c.oid))
AND a.attnum > 0
AND NOT a.attisdropped
ORDER BY a.attnum
SQL;
		$values = array($table,$table);
		return $this->query($sql,$values);
	}

	public function query_for_tables()
	{
		return $this->query("SELECT tablename FROM pg_tables WHERE schemaname NOT IN('information_schema','pg_catalog')");
	}

	public function create_column(&$column)
	{
		$c = new Column();
		$c->inflected_name	= Inflector::instance()->variablize($column['field']);
		$c->name			= $column['field'];
		$c->nullable		= ($column['not_nullable'] ? false : true);
		$c->pk				= ($column['pk'] ? true : false);
		$c->auto_increment	= false;

		if (substr($column['type'],0,9) == 'timestamp')
		{
			$c->raw_type = 'datetime';
			$c->length = 19;
		}
		elseif ($column['type'] == 'date')
		{
			$c->raw_type = 'date';
			$c->length = 10;
		}
		else
		{
			preg_match('/^([A-Za-z0-9_]+)(\(([0-9]+(,[0-9]+)?)\))?/',$column['type'],$matches);

			$c->raw_type = (count($matches) > 0 ? $matches[1] : $column['type']);
			$c->length = count($matches) >= 4 ? intval($matches[3]) : intval($column['attlen']);

			if ($c->length < 0)
				$c->length = null;
		}

		$c->map_raw_type();

		if ($column['default'])
		{
			preg_match("/^nextval\('(.*)'\)$/",$column['default'],$matches);

			if (count($matches) == 2)
				$c->sequence = $matches[1];
			else
				$c->default = $c->cast($column['default'],$this);
		}
		return $c;
	}
	
	public function set_encoding($charset)
	{
		$this->query("SET NAMES '$charset'");
	}
	
	public function native_database_types()
	{
		return array(
			'primary_key' => 'serial primary key',
			'string' => array('name' => 'character varying', 'length' => 255),
			'text' => array('name' => 'text'),
			'integer' => array('name' => 'integer'),
			'float' => array('name' => 'float'),
			'datetime' => array('name' => 'datetime'),
			'timestamp' => array('name' => 'timestamp'),
			'time' => array('name' => 'time'),
			'date' => array('name' => 'date'),
			'binary' => array('name' => 'binary'),
			'boolean' => array('name' => 'boolean')
		);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
	write($path . 'SqliteAdapter.php', _strip_phpdoc(<<< 'AR'
<?php
namespace ActiveRecord;
/**
 * Adapter for SQLite.
 *
 * @package ActiveRecord
 */
class SqliteAdapter extends Connection
{
	protected function __construct($info)
	{
		if (!file_exists($info->host))
			throw new DatabaseException("Could not find sqlite db: $info->host");

		$this->connection = new \PDO("sqlite:$info->host",null,null,static::$PDO_OPTIONS);
	}

	public function limit($sql, $offset, $limit)
	{
		$offset = is_null($offset) ? '' : intval($offset) . ',';
		$limit = intval($limit);
		return "$sql LIMIT {$offset}$limit";
	}

	public function query_column_info($table)
	{
		return $this->query("pragma table_info($table)");
	}

	public function query_for_tables()
	{
		return $this->query("SELECT name FROM sqlite_master");
	}

	public function create_column($column)
	{
		$c = new Column();
		$c->inflected_name	= Inflector::instance()->variablize($column['name']);
		$c->name			= $column['name'];
		$c->nullable		= $column['notnull'] ? false : true;
		$c->pk				= $column['pk'] ? true : false;
		$c->auto_increment	= $column['type'] == 'INTEGER' && $c->pk;

		$column['type'] = preg_replace('/ +/',' ',$column['type']);
		$column['type'] = str_replace(array('(',')'),' ',$column['type']);
		$column['type'] = Utils::squeeze(' ',$column['type']);
		$matches = explode(' ',$column['type']);

		if (!empty($matches))
		{
			$c->raw_type = strtolower($matches[0]);

			if (count($matches) > 1)
				$c->length = intval($matches[1]);
		}

		$c->map_raw_type();

		if ($c->type == Column::DATETIME)
			$c->length = 19;
		elseif ($c->type == Column::DATE)
			$c->length = 10;

		// From SQLite3 docs: The value is a signed integer, stored in 1, 2, 3, 4, 6,
		// or 8 bytes depending on the magnitude of the value.
		// so is it ok to assume it's possible an int can always go up to 8 bytes?
		if ($c->type == Column::INTEGER && !$c->length)
			$c->length = 8;

		$c->default = $c->cast($column['dflt_value'],$this);

		return $c;
	}
	
	public function set_encoding($charset)
	{
		throw new ActiveRecordException(
			"SqliteAdapter::set_charset not supported."
		);
	}
	
	public function accepts_limit_and_order_for_update_and_delete() 
	{ 
		return true; 
	}

	public function native_database_types()
	{
		return array(
			'primary_key' => 'INTEGER NOT NULL PRIMARY KEY',
			'string' => array('name' => 'varchar', 'length' => 255),
			'text' => array('name' => 'text'),
			'integer' => array('name' => 'integer'),
			'float' => array('name' => 'float'),
			'decimal' => array('name' => 'decimal'),
			'datetime' => array('name' => 'datetime'),
			'timestamp' => array('name' => 'datetime'),
			'time' => array('name' => 'time'),
			'date' => array('name' => 'date'),
			'binary' => array('name' => 'blob'),
			'boolean' => array('name' => 'boolean')
		);
	}
}
?>
AR
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_mailer_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR
		. 'mailer.php';
	write($path, sprintf(<<< 'MAILER'
<?php
/**
 * Mailer Module 1.0 for Pragwork %s
 * This is a PHP Mailer v. 5.1 library with a bit changed API, to follow
 * Pragwork conventions.
 * 
 * @copyright (c) 2001 - 2009 Andy Prevost and Marcus Bointon. 
 *     API changes - (c) 2010 Szymon Wrozynski
 * @license Licensed under LGPL
 * @version %s
 * @package Mailer
 */


MAILER
		, PRAGWORK_VERSION, PRAGWORK_VERSION) . _strip_phpdoc(<<< 'MAILER'
namespace Mailer;
/*~ class.smtp.php
.---------------------------------------------------------------------------.
|  Software: PHPMailer - PHP email class									|
|	Version: 5.1															|
|	Contact: via sourceforge.net support pages (also www.codeworxtech.com)	|
|	   Info: http://phpmailer.sourceforge.net								|
|	Support: http://sourceforge.net/projects/phpmailer/						|
| ------------------------------------------------------------------------- |
|	  Admin: Andy Prevost (project admininistrator)							|
|	Authors: Andy Prevost (codeworxtech) codeworxtech@users.sourceforge.net |
|		   : Marcus Bointon (coolbru) coolbru@users.sourceforge.net			|
|	Founder: Brent R. Matzelle (original founder)							|
| Copyright (c) 2004-2009, Andy Prevost. All Rights Reserved.				|
| Copyright (c) 2001-2003, Brent R. Matzelle								|
| ------------------------------------------------------------------------- |
|	License: Distributed under the Lesser General Public License (LGPL)		|
|			 http://www.gnu.org/copyleft/lesser.html						|
| This program is distributed in the hope that it will be useful - WITHOUT	|
| ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or		|
| FITNESS FOR A PARTICULAR PURPOSE.											|
| ------------------------------------------------------------------------- |
| We offer a number of paid services (www.codeworxtech.com):				|
| - Web Hosting on highly optimized fast and secure servers					|
| - Technology Consulting													|
| - Oursourcing (highly qualified programmers and graphic designers)		|
'---------------------------------------------------------------------------'
*/

/*
 * PHPMailer - PHP SMTP email transport class
 * NOTE: Designed for use with PHP version 5 and up
 * @package PHPMailer
 * @author Andy Prevost
 * @author Marcus Bointon
 * @copyright 2004 - 2008 Andy Prevost
 * @license http://www.gnu.org/copyleft/lesser.html Distributed under the Lesser General Public License (LGPL)
 * @version $Id: class.smtp.php 444 2009-05-05 11:22:26Z coolbru $
 */

/*
 * SMTP is rfc 821 compliant and implements all the rfc 821 SMTP
 * commands except TURN which will always return a not implemented
 * error. SMTP also provides some utility methods for sending mail
 * to an SMTP server.
 * original author: Chris Ryan
 */

class SMTP {
  /**
   *  SMTP server port
   *  @var int
   */
  public $SMTP_PORT = 25;

  /**
   *  SMTP reply line ending
   *  @var string
   */
  public $CRLF = "\r\n";

  /**
   *  Sets whether debugging is turned on
   *  @var bool
   */
  public $do_debug;		  // the level of debug to perform

  /**
   *  Sets VERP use on/off (default is off)
   *  @var bool
   */
  public $do_verp = false;

  /////////////////////////////////////////////////
  // PROPERTIES, PRIVATE AND PROTECTED
  /////////////////////////////////////////////////

  private $smtp_conn; // the socket to the server
  private $error;	  // error if any on the last call
  private $helo_rply; // the reply the server sent to us for HELO

  /**
   * Initialize the class so that the data is in a known state.
   * @access public
   * @return void
   */
  public function __construct() {
	$this->smtp_conn = 0;
	$this->error = null;
	$this->helo_rply = null;

	$this->do_debug = 0;
  }

  /////////////////////////////////////////////////
  // CONNECTION FUNCTIONS
  /////////////////////////////////////////////////

  /**
   * Connect to the server specified on the port specified.
   * If the port is not specified use the default SMTP_PORT.
   * If tval is specified then a connection will try and be
   * established with the server for that number of seconds.
   * If tval is not specified the default is 30 seconds to
   * try on the connection.
   *
   * SMTP CODE SUCCESS: 220
   * SMTP CODE FAILURE: 421
   * @access public
   * @return bool
   */
  public function Connect($host, $port = 0, $tval = 30) {
	// set the error val to null so there is no confusion
	$this->error = null;

	// make sure we are __not__ connected
	if($this->connected()) {
	  // already connected, generate error
	  $this->error = array("error" => "Already connected to a server");
	  return false;
	}

	if(empty($port)) {
	  $port = $this->SMTP_PORT;
	}

	// connect to the smtp server
	$this->smtp_conn = @fsockopen($host,	// the host of the server
								 $port,	   // the port to use
								 $errno,   // error number if any
								 $errstr,  // error message if any
								 $tval);   // give up after ? secs
	// verify we connected properly
	if(empty($this->smtp_conn)) {
	  $this->error = array("error" => "Failed to connect to server",
						   "errno" => $errno,
						   "errstr" => $errstr);
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": $errstr ($errno)" . $this->CRLF . '<br />';
	  }
	  return false;
	}

	// SMTP server can take longer to respond, give longer timeout for first read
	// Windows does not have support for this timeout function
	if(substr(PHP_OS, 0, 3) != "WIN")
	 socket_set_timeout($this->smtp_conn, $tval, 0);

	// get any announcement
	$announce = $this->get_lines();

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $announce . $this->CRLF . '<br />';
	}

	return true;
  }

  /**
   * Initiate a TLS communication with the server.
   *
   * SMTP CODE 220 Ready to start TLS
   * SMTP CODE 501 Syntax error (no parameters allowed)
   * SMTP CODE 454 TLS not available due to temporary reason
   * @access public
   * @return bool success
   */
  public function StartTLS() {
	$this->error = null; # to avoid confusion

	if(!$this->connected()) {
	  $this->error = array("error" => "Called StartTLS() without being connected");
	  return false;
	}

	fputs($this->smtp_conn,"STARTTLS" . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 220) {
	  $this->error =
		 array("error"	   => "STARTTLS not accepted from server",
			   "smtp_code" => $code,
			   "smtp_msg"  => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	// Begin encrypted connection
	if(!stream_socket_enable_crypto($this->smtp_conn, true, STREAM_CRYPTO_METHOD_TLS_CLIENT)) {
	  return false;
	}

	return true;
  }

  /**
   * Performs SMTP authentication.	Must be run after running the
   * Hello() method.  Returns true if successfully authenticated.
   * @access public
   * @return bool
   */
  public function Authenticate($username, $password) {
	// Start authentication
	fputs($this->smtp_conn,"AUTH LOGIN" . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($code != 334) {
	  $this->error =
		array("error" => "AUTH not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	// Send encoded username
	fputs($this->smtp_conn, base64_encode($username) . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($code != 334) {
	  $this->error =
		array("error" => "Username not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	// Send encoded password
	fputs($this->smtp_conn, base64_encode($password) . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($code != 235) {
	  $this->error =
		array("error" => "Password not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	return true;
  }

  /**
   * Returns true if connected to a server otherwise false
   * @access public
   * @return bool
   */
  public function Connected() {
	if(!empty($this->smtp_conn)) {
	  $sock_status = socket_get_status($this->smtp_conn);
	  if($sock_status["eof"]) {
		// the socket is valid but we are not connected
		if($this->do_debug >= 1) {
			echo "SMTP -> NOTICE:" . $this->CRLF . "EOF caught while checking if connected";
		}
		$this->Close();
		return false;
	  }
	  return true; // everything looks good
	}
	return false;
  }

  /**
   * Closes the socket and cleans up the state of the class.
   * It is not considered good to use this function without
   * first trying to use QUIT.
   * @access public
   * @return void
   */
  public function Close() {
	$this->error = null; // so there is no confusion
	$this->helo_rply = null;
	if(!empty($this->smtp_conn)) {
	  // close the connection and cleanup
	  fclose($this->smtp_conn);
	  $this->smtp_conn = 0;
	}
  }

  /////////////////////////////////////////////////
  // SMTP COMMANDS
  /////////////////////////////////////////////////

  /**
   * Issues a data command and sends the msg_data to the server
   * finializing the mail transaction. $msg_data is the message
   * that is to be send with the headers. Each header needs to be
   * on a single line followed by a <code><CRLF></code> with the message headers
   * and the message body being seperated by and additional <code><CRLF></code>.
   *
   * Implements rfc 821: DATA <code><CRLF></code>
   *
   * SMTP CODE INTERMEDIATE: 354
   *	 [data]
   *	 <code><CRLF></code>.<code><CRLF></code>
   *	 SMTP CODE SUCCESS: 250
   *	 SMTP CODE FAILURE: 552,554,451,452
   * SMTP CODE FAILURE: 451,554
   * SMTP CODE ERROR  : 500,501,503,421
   * @access public
   * @return bool
   */
  public function Data($msg_data) {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
			  "error" => "Called Data() without being connected");
	  return false;
	}

	fputs($this->smtp_conn,"DATA" . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 354) {
	  $this->error =
		array("error" => "DATA command not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	/* the server is ready to accept data!
	 * according to rfc 821 we should not send more than 1000
	 * including the CRLF
	 * characters on a single line so we will break the data up
	 * into lines by \r and/or \n then if needed we will break
	 * each of those into smaller lines to fit within the limit.
	 * in addition we will be looking for lines that start with
	 * a period '.' and append and additional period '.' to that
	 * line. NOTE: this does not count towards limit.
	 */

	// normalize the line breaks so we know the explode works
	$msg_data = str_replace("\r\n","\n",$msg_data);
	$msg_data = str_replace("\r","\n",$msg_data);
	$lines = explode("\n",$msg_data);

	/* we need to find a good way to determine is headers are
	 * in the msg_data or if it is a straight msg body
	 * currently I am assuming rfc 822 definitions of msg headers
	 * and if the first field of the first line (':' sperated)
	 * does not contain a space then it _should_ be a header
	 * and we can process all lines before a blank "" line as
	 * headers.
	 */

	$field = substr($lines[0],0,strpos($lines[0],":"));
	$in_headers = false;
	if(!empty($field) && !strstr($field," ")) {
	  $in_headers = true;
	}

	$max_line_length = 998; // used below; set here for ease in change

	while(list(,$line) = @each($lines)) {
	  $lines_out = null;
	  if($line == "" && $in_headers) {
		$in_headers = false;
	  }
	  // ok we need to break this line up into several smaller lines
	  while(strlen($line) > $max_line_length) {
		$pos = strrpos(substr($line,0,$max_line_length)," ");

		// Patch to fix DOS attack
		if(!$pos) {
		  $pos = $max_line_length - 1;
		  $lines_out[] = substr($line,0,$pos);
		  $line = substr($line,$pos);
		} else {
		  $lines_out[] = substr($line,0,$pos);
		  $line = substr($line,$pos + 1);
		}

		/* if processing headers add a LWSP-char to the front of new line
		 * rfc 822 on long msg headers
		 */
		if($in_headers) {
		  $line = "\t" . $line;
		}
	  }
	  $lines_out[] = $line;

	  // send the lines to the server
	  while(list(,$line_out) = @each($lines_out)) {
		if(strlen($line_out) > 0)
		{
		  if(substr($line_out, 0, 1) == ".") {
			$line_out = "." . $line_out;
		  }
		}
		fputs($this->smtp_conn,$line_out . $this->CRLF);
	  }
	}

	// message data has been sent
	fputs($this->smtp_conn, $this->CRLF . "." . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 250) {
	  $this->error =
		array("error" => "DATA not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}
	return true;
  }

  /**
   * Sends the HELO command to the smtp server.
   * This makes sure that we and the server are in
   * the same known state.
   *
   * Implements from rfc 821: HELO <code><SP></code> <code><domain></code> <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250
   * SMTP CODE ERROR  : 500, 501, 504, 421
   * @access public
   * @return bool
   */
  public function Hello($host = '') {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
			"error" => "Called Hello() without being connected");
	  return false;
	}

	// if hostname for HELO was not specified send default
	if(empty($host)) {
	  // determine appropriate default to send to server
	  $host = "localhost";
	}

	// Send extended hello first (RFC 2821)
	if(!$this->SendHello("EHLO", $host)) {
	  if(!$this->SendHello("HELO", $host)) {
		return false;
	  }
	}

	return true;
  }

  /**
   * Sends a HELO/EHLO command.
   * @access private
   * @return bool
   */
  private function SendHello($hello, $host) {
	fputs($this->smtp_conn, $hello . " " . $host . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER: " . $rply . $this->CRLF . '<br />';
	}

	if($code != 250) {
	  $this->error =
		array("error" => $hello . " not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	$this->helo_rply = $rply;

	return true;
  }

  /**
   * Starts a mail transaction from the email address specified in
   * $from. Returns true if successful or false otherwise. If True
   * the mail transaction is started and then one or more Recipient
   * commands may be called followed by a Data command.
   *
   * Implements rfc 821: MAIL <code><SP></code> FROM:<code><reverse-path></code> <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250
   * SMTP CODE SUCCESS: 552,451,452
   * SMTP CODE SUCCESS: 500,501,421
   * @access public
   * @return bool
   */
  public function Mail($from) {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
			  "error" => "Called Mail() without being connected");
	  return false;
	}

	$useVerp = ($this->do_verp ? "XVERP" : "");
	fputs($this->smtp_conn,"MAIL FROM:<" . $from . ">" . $useVerp . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 250) {
	  $this->error =
		array("error" => "MAIL not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}
	return true;
  }

  /**
   * Sends the quit command to the server and then closes the socket
   * if there is no error or the $close_on_error argument is true.
   *
   * Implements from rfc 821: QUIT <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 221
   * SMTP CODE ERROR  : 500
   * @access public
   * @return bool
   */
  public function Quit($close_on_error = true) {
	$this->error = null; // so there is no confusion

	if(!$this->connected()) {
	  $this->error = array(
			  "error" => "Called Quit() without being connected");
	  return false;
	}

	// send the quit command to the server
	fputs($this->smtp_conn,"quit" . $this->CRLF);

	// get any good-bye messages
	$byemsg = $this->get_lines();

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $byemsg . $this->CRLF . '<br />';
	}

	$rval = true;
	$e = null;

	$code = substr($byemsg,0,3);
	if($code != 221) {
	  // use e as a tmp var cause Close will overwrite $this->error
	  $e = array("error" => "SMTP server rejected quit command",
				 "smtp_code" => $code,
				 "smtp_rply" => substr($byemsg,4));
	  $rval = false;
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $e["error"] . ": " . $byemsg . $this->CRLF . '<br />';
	  }
	}

	if(empty($e) || $close_on_error) {
	  $this->Close();
	}

	return $rval;
  }

  /**
   * Sends the command RCPT to the SMTP server with the TO: argument of $to.
   * Returns true if the recipient was accepted false if it was rejected.
   *
   * Implements from rfc 821: RCPT <code><SP></code> TO:<code><forward-path></code> <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250,251
   * SMTP CODE FAILURE: 550,551,552,553,450,451,452
   * SMTP CODE ERROR  : 500,501,503,421
   * @access public
   * @return bool
   */
  public function Recipient($to) {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
			  "error" => "Called Recipient() without being connected");
	  return false;
	}

	fputs($this->smtp_conn,"RCPT TO:<" . $to . ">" . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 250 && $code != 251) {
	  $this->error =
		array("error" => "RCPT not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}
	return true;
  }

  /**
   * Sends the RSET command to abort and transaction that is
   * currently in progress. Returns true if successful false
   * otherwise.
   *
   * Implements rfc 821: RSET <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250
   * SMTP CODE ERROR  : 500,501,504,421
   * @access public
   * @return bool
   */
  public function Reset() {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
			  "error" => "Called Reset() without being connected");
	  return false;
	}

	fputs($this->smtp_conn,"RSET" . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 250) {
	  $this->error =
		array("error" => "RSET failed",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}

	return true;
  }

  /**
   * Starts a mail transaction from the email address specified in
   * $from. Returns true if successful or false otherwise. If True
   * the mail transaction is started and then one or more Recipient
   * commands may be called followed by a Data command. This command
   * will send the message to the users terminal if they are logged
   * in and send them an email.
   *
   * Implements rfc 821: SAML <code><SP></code> FROM:<code><reverse-path></code> <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250
   * SMTP CODE SUCCESS: 552,451,452
   * SMTP CODE SUCCESS: 500,501,502,421
   * @access public
   * @return bool
   */
  public function SendAndMail($from) {
	$this->error = null; // so no confusion is caused

	if(!$this->connected()) {
	  $this->error = array(
		  "error" => "Called SendAndMail() without being connected");
	  return false;
	}

	fputs($this->smtp_conn,"SAML FROM:" . $from . $this->CRLF);

	$rply = $this->get_lines();
	$code = substr($rply,0,3);

	if($this->do_debug >= 2) {
	  echo "SMTP -> FROM SERVER:" . $rply . $this->CRLF . '<br />';
	}

	if($code != 250) {
	  $this->error =
		array("error" => "SAML not accepted from server",
			  "smtp_code" => $code,
			  "smtp_msg" => substr($rply,4));
	  if($this->do_debug >= 1) {
		echo "SMTP -> ERROR: " . $this->error["error"] . ": " . $rply . $this->CRLF . '<br />';
	  }
	  return false;
	}
	return true;
  }

  /**
   * This is an optional command for SMTP that this class does not
   * support. This method is here to make the RFC821 Definition
   * complete for this class and __may__ be implimented in the future
   *
   * Implements from rfc 821: TURN <code><CRLF></code>
   *
   * SMTP CODE SUCCESS: 250
   * SMTP CODE FAILURE: 502
   * SMTP CODE ERROR  : 500, 503
   * @access public
   * @return bool
   */
  public function Turn() {
	$this->error = array("error" => "This method, TURN, of the SMTP ".
									"is not implemented");
	if($this->do_debug >= 1) {
	  echo "SMTP -> NOTICE: " . $this->error["error"] . $this->CRLF . '<br />';
	}
	return false;
  }

  /**
  * Get the current error
  * @access public
  * @return array
  */
  public function getError() {
	return $this->error;
  }

  /////////////////////////////////////////////////
  // INTERNAL FUNCTIONS
  /////////////////////////////////////////////////

  /**
   * Read in as many lines as possible
   * either before eof or socket timeout occurs on the operation.
   * With SMTP we can tell if we have more lines to read if the
   * 4th character is '-' symbol. If it is a space then we don't
   * need to read anything else.
   * @access private
   * @return string
   */
  private function get_lines() {
	$data = "";
	while($str = @fgets($this->smtp_conn,515)) {
	  if($this->do_debug >= 4) {
		echo "SMTP -> get_lines(): \$data was \"$data\"" . $this->CRLF . '<br />';
		echo "SMTP -> get_lines(): \$str is \"$str\"" . $this->CRLF . '<br />';
	  }
	  $data .= $str;
	  if($this->do_debug >= 4) {
		echo "SMTP -> get_lines(): \$data is \"$data\"" . $this->CRLF . '<br />';
	  }
	  // if 4th character is a space, we are done reading, break the loop
	  if(substr($str,3,1) == " ") { break; }
	}
	return $data;
  }

}


/*~ class.phpmailer.php
.---------------------------------------------------------------------------.
|  Software: PHPMailer - PHP email class									|
|	Version: 5.1															|
|	Contact: via sourceforge.net support pages (also www.worxware.com)		|
|	   Info: http://phpmailer.sourceforge.net								|
|	Support: http://sourceforge.net/projects/phpmailer/						|
| ------------------------------------------------------------------------- |
|	  Admin: Andy Prevost (project admininistrator)							|
|	Authors: Andy Prevost (codeworxtech) codeworxtech@users.sourceforge.net |
|		   : Marcus Bointon (coolbru) coolbru@users.sourceforge.net			|
|	Founder: Brent R. Matzelle (original founder)							|
| Copyright (c) 2004-2009, Andy Prevost. All Rights Reserved.				|
| Copyright (c) 2001-2003, Brent R. Matzelle								|
| ------------------------------------------------------------------------- |
|	License: Distributed under the Lesser General Public License (LGPL)		|
|			 http://www.gnu.org/copyleft/lesser.html						|
| This program is distributed in the hope that it will be useful - WITHOUT	|
| ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or		|
| FITNESS FOR A PARTICULAR PURPOSE.											|
| ------------------------------------------------------------------------- |
| We offer a number of paid services (www.worxware.com):					|
| - Web Hosting on highly optimized fast and secure servers					|
| - Technology Consulting													|
| - Oursourcing (highly qualified programmers and graphic designers)		|
'---------------------------------------------------------------------------'
*/

/**
 * PHPMailer - PHP email transport class
 * NOTE: Requires PHP version 5 or later
 * @package PHPMailer
 * @author Andy Prevost
 * @author Marcus Bointon
 * @copyright 2004 - 2009 Andy Prevost
 * @version $Id: class.phpmailer.php 447 2009-05-25 01:36:38Z codeworxtech $
 * @license http://www.gnu.org/copyleft/lesser.html GNU Lesser General Public License
 */

if (version_compare(PHP_VERSION, '5.0.0', '<') ) exit("Sorry, this version of PHPMailer will only run on PHP version 5 or greater!\n");

class Mailer {

  /////////////////////////////////////////////////
  // PROPERTIES, PUBLIC
  /////////////////////////////////////////////////

  /**
   * Email priority (1 = High, 3 = Normal, 5 = low).
   * @var int
   */
  public $priority			= 3;

  /**
   * Sets the charset of the message.
   * @var string
   */
  public $charset			= 'utf-8';

  /**
   * Sets the Content-type of the message.
   * @var string
   */
  public $content_type		 = 'text/plain';

  /**
   * Sets the encoding of the message. Options for this are
   *  "8bit", "7bit", "binary", "base64", and "quoted-printable".
   * @var string
   */
  public $encoding			= '8bit';

  /**
   * Holds the most recent mailer error message.
   * @var string
   */
  public $error_info		 = '';

  /**
   * Sets the From email address for the message.
   * @var string
   */
  public $from				= 'root@localhost';

  /**
   * Sets the From name of the message.
   * @var string
   */
  public $from_name			 = 'Root User';

  /**
   * Sets the sender email (Return-Path) of the message.  If not empty,
   * will be sent via -f to sendmail or as 'MAIL FROM' in smtp mode.
   * @var string
   */
  public $sender			= '';

  /**
   * Sets the subject of the message.
   * @var string
   */
  public $subject			= '';

  /**
   * Sets the body of the message.	This can be either an HTML or text body.
   * If HTML then run use_html(true).
   * @var string
   */
  public $body				= '';

  /**
   * Sets the text-only body of the message.  This automatically sets the
   * email to multipart/alternative.  This body can be read by mail
   * clients that do not have HTML email capability such as mutt. Clients
   * that can read HTML will view the normal body.
   * @var string
   */
  public $alt_body			 = '';

  /**
   * Sets word wrapping on the body of the message to a given number of
   * characters.
   * @var int
   */
  public $word_wrap			 = 0;

  /**
   * Method to send mail: ("mail", "sendmail", or "smtp").
   * @var string
   */
  public $mailer			= 'mail';

  /**
   * Sets the path of the sendmail program.
   * @var string
   */
  public $sendmail			= '/usr/sbin/sendmail';

  /**
   * Path to PHPMailer plugins.	 Useful if the SMTP class
   * is in a different directory than the PHP include path.
   * @var string
   */
  // public $plugin_dir			= ''; // TODO remove

  /**
   * Sets the email address that a reading confirmation will be sent.
   * @var string
   */
  public $confirm_reading_to  = '';

  /**
   * Sets the hostname to use in Message-Id and Received headers
   * and as default HELO string. If empty, the value returned
   * by SERVER_NAME is used or 'localhost.localdomain'.
   * @var string
   */
  public $hostname			= '';

  /**
   * Sets the message ID to be used in the Message-Id header.
   * If empty, a unique id will be generated.
   * @var string
   */
  public $message_id		 = '';

  /////////////////////////////////////////////////
  // PROPERTIES FOR SMTP
  /////////////////////////////////////////////////

  /**
   * Sets the SMTP hosts.  All hosts must be separated by a
   * semicolon.	 You can also specify a different port
   * for each host by using this format: [hostname:port]
   * (e.g. "smtp1.example.com:25;smtp2.example.com").
   * Hosts will be tried in order.
   * @var string
   */
  public $host			= 'localhost';

  /**
   * Sets the default SMTP server port.
   * @var int
   */
  public $port			= 25;

  /**
   * Sets the SMTP HELO of the message (Default is $Hostname).
   * @var string
   */
  public $helo			= '';

  /**
   * Sets connection prefix.
   * Options are "", "ssl" or "tls"
   * @var string
   */
  public $SMTP_secure	 = '';

  /**
   * Sets SMTP authentication. Utilizes the Username and Password variables.
   * @var bool
   */
  public $SMTP_auth		 = false;

  /**
   * Sets SMTP username.
   * @var string
   */
  public $username		= '';

  /**
   * Sets SMTP password.
   * @var string
   */
  public $password		= '';

  /**
   * Sets the SMTP server timeout in seconds.
   * This function will not work with the win32 version.
   * @var int
   */
  public $timeout		= 10;

  /**
   * Sets SMTP class debugging on or off.
   * @var bool
   */
  public $SMTP_debug	 = false;

  /**
   * Prevents the SMTP connection from being closed after each mail
   * sending.  If this is set to true then to close the connection
   * requires an explicit call to smtp_close().
   * @var bool
   */
  public $SMTP_keep_alive = false;

  /**
   * Provides the ability to have the TO field process individual
   * emails, instead of sending to entire TO addresses
   * @var bool
   */
  public $single_to		 = false;

   /**
   * If single_to is true, this provides the array to hold the email addresses
   * @var bool
   */
  public $single_to_array = array();

 /**
   * Provides the ability to change the line ending
   * @var string
   */
  public $LE			  = "\n";

  /**
   * Used with DKIM DNS Resource Record
   * @var string
   */
  public $DKIM_selector	  = 'phpmailer';

  /**
   * Used with DKIM DNS Resource Record
   * optional, in format of email address 'you@yourdomain.com'
   * @var string
   */
  public $DKIM_identity	  = '';

  /**
   * Used with DKIM DNS Resource Record
   * optional, in format of email address 'you@yourdomain.com'
   * @var string
   */
  public $DKIM_domain	  = '';

  /**
   * Used with DKIM DNS Resource Record
   * optional, in format of email address 'you@yourdomain.com'
   * @var string
   */
  public $DKIM_private	  = '';

  /**
   * Callback Action function name
   * the function that handles the result of the send email action. Parameters:
   *   bool	   $result		  result of the send action
   *   string  $to			  email address of the recipient
   *   string  $cc			  cc email addresses
   *   string  $bcc			  bcc email addresses
   *   string  $subject		  the subject
   *   string  $body		  the email body
   * @var string
   */
  public $action_function = ''; //'callbackAction';

  /**
   * Sets the PHPMailer Version number
   * @var string
   */
  public $version		  = '5.1';

  /////////////////////////////////////////////////
  // PROPERTIES, PRIVATE AND PROTECTED
  /////////////////////////////////////////////////

  private	$smtp			= NULL;
  private	$to				= array();
  private	$cc				= array();
  private	$bcc			= array();
  private	$ReplyTo		= array();
  private	$all_recipients = array();
  private	$attachment		= array();
  private	$CustomHeader	= array();
  private	$message_type	= '';
  private	$boundary		= array();
  protected $language		= array();
  private	$error_count	= 0;
  private	$sign_cert_file = "";
  private	$sign_key_file	= "";
  private	$sign_key_pass	= "";
  private	$exceptions		= false;

  /////////////////////////////////////////////////
  // CONSTANTS
  /////////////////////////////////////////////////

  const STOP_MESSAGE  = 0; // message only, continue processing
  const STOP_CONTINUE = 1; // message?, likely ok to continue processing
  const STOP_CRITICAL = 2; // message, plus full stop, critical error reached

  /////////////////////////////////////////////////
  // METHODS, VARIABLES
  /////////////////////////////////////////////////

  /**
   * Constructor
   * @param boolean $exceptions Should we throw external exceptions?
   */
  public function __construct($exceptions=true) {
	$this->exceptions = ($exceptions == true);
  }

  /**
   * Sets message type to HTML.
   * @param bool $use_html
   * @return void
   */
  public function use_html($use_html = true) {
	if ($use_html) {
	  $this->content_type = 'text/html';
	} else {
	  $this->content_type = 'text/plain';
	}
  }

  /**
   * Sets Mailer to send message using SMTP.
   * @return void
   */
  public function use_SMTP() {
	$this->mailer = 'smtp';
  }

  /**
   * Sets Mailer to send message using PHP mail() function.
   * @return void
   */
  public function use_mail() {
	$this->mailer = 'mail';
  }

  /**
   * Sets Mailer to send message using the $Sendmail program.
   * @return void
   */
  public function use_sendmail() {
	if (!stristr(ini_get('sendmail_path'), 'sendmail')) {
	  $this->sendmail = '/var/qmail/bin/sendmail';
	}
	$this->mailer = 'sendmail';
  }

  /**
   * Sets Mailer to send message using the qmail MTA.
   * @return void
   */
  public function use_qmail() {
	if (stristr(ini_get('sendmail_path'), 'qmail')) {
	  $this->sendmail = '/var/qmail/bin/sendmail';
	}
	$this->mailer = 'sendmail';
  }

  /////////////////////////////////////////////////
  // METHODS, RECIPIENTS
  /////////////////////////////////////////////////

  /**
   * Adds a "To" address.
   * @param string $address
   * @param string $name
   * @return boolean true on success, false if address already used
   */
  public function add_address($address, $name = '') {
	return $this->add_an_address('to', $address, $name);
  }

  /**
   * Adds a "Cc" address.
   * Note: this function works with the SMTP mailer on win32, not with the "mail" mailer.
   * @param string $address
   * @param string $name
   * @return boolean true on success, false if address already used
   */
  public function add_cc($address, $name = '') {
	return $this->add_an_address('cc', $address, $name);
  }

  /**
   * Adds a "Bcc" address.
   * Note: this function works with the SMTP mailer on win32, not with the "mail" mailer.
   * @param string $address
   * @param string $name
   * @return boolean true on success, false if address already used
   */
  public function add_bcc($address, $name = '') {
	return $this->add_an_address('bcc', $address, $name);
  }

  /**
   * Adds a "Reply-to" address.
   * @param string $address
   * @param string $name
   * @return boolean
   */
  public function add_reply_to($address, $name = '') {
	return $this->add_an_address('ReplyTo', $address, $name);
  }

  /**
   * Adds an address to one of the recipient arrays
   * Addresses that have been added already return false, but do not throw exceptions
   * @param string $kind One of 'to', 'cc', 'bcc', 'ReplyTo'
   * @param string $address The email address to send to
   * @param string $name
   * @return boolean true on success, false if address already used or invalid in some way
   * @access private
   */
  private function add_an_address($kind, $address, $name = '') {
	if (!preg_match('/^(to|cc|bcc|ReplyTo)$/', $kind)) {
	  echo 'Invalid recipient array: ' . kind;
	  return false;
	}
	$address = trim($address);
	$name = trim(preg_replace('/[\r\n]+/', '', $name)); //Strip breaks and trim
	if (!self::validate_address($address)) {
	  $this->set_error($this->lang('invalid_address').': '. $address);
	  if ($this->exceptions) {
		throw new MailerException($this->lang('invalid_address').': '.$address);
	  }
	  echo $this->lang('invalid_address').': '.$address;
	  return false;
	}
	if ($kind != 'ReplyTo') {
	  if (!isset($this->all_recipients[strtolower($address)])) {
		array_push($this->$kind, array($address, $name));
		$this->all_recipients[strtolower($address)] = true;
		return true;
	  }
	} else {
	  if (!array_key_exists(strtolower($address), $this->ReplyTo)) {
		$this->ReplyTo[strtolower($address)] = array($address, $name);
	  return true;
	}
  }
  return false;
}

/**
 * Set the from and from_name properties
 * @param string $address
 * @param string $name
 * @return boolean
 */
  public function set_from($address, $name = '',$auto=1) {
	$address = trim($address);
	$name = trim(preg_replace('/[\r\n]+/', '', $name)); //Strip breaks and trim
	if (!self::validate_address($address)) {
	  $this->set_error($this->lang('invalid_address').': '. $address);
	  if ($this->exceptions) {
		throw new MailerException($this->lang('invalid_address').': '.$address);
	  }
	  echo $this->lang('invalid_address').': '.$address;
	  return false;
	}
	$this->from = $address;
	$this->from_name = $name;
	if ($auto) {
	  if (empty($this->ReplyTo)) {
		$this->add_an_address('ReplyTo', $address, $name);
	  }
	  if (empty($this->sender)) {
		$this->sender = $address;
	  }
	}
	return true;
  }

  /**
   * Check that a string looks roughly like an email address should
   * Static so it can be used without instantiation
   * Tries to use PHP built-in validator in the filter extension (from PHP 5.2), falls back to a reasonably competent regex validator
   * Conforms approximately to RFC2822
   * @link http://www.hexillion.com/samples/#Regex Original pattern found here
   * @param string $address The email address to check
   * @return boolean
   * @static
   * @access public
   */
  public static function validate_address($address) {
	if (function_exists('filter_var')) { //Introduced in PHP 5.2
	  if(filter_var($address, FILTER_VALIDATE_EMAIL) === FALSE) {
		return false;
	  } else {
		return true;
	  }
	} else {
	  return preg_match('/^(?:[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&\'\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!\.)){0,61}[a-zA-Z0-9_-]?\.)+[a-zA-Z0-9_](?:[a-zA-Z0-9_\-](?!$)){0,61}[a-zA-Z0-9_]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/', $address);
	}
  }

  /////////////////////////////////////////////////
  // METHODS, MAIL SENDING
  /////////////////////////////////////////////////

  /**
   * Creates message and assigns Mailer. If the message is
   * not sent successfully then it returns false.  Use the error_info
   * variable to view description of the error.
   * @return bool
   */
  public function send() {
	try {
	  if ((count($this->to) + count($this->cc) + count($this->bcc)) < 1) {
		throw new MailerException($this->lang('provide_address'), self::STOP_CRITICAL);
	  }

	  // Set whether the message is multipart/alternative
	  if(!empty($this->alt_body)) {
		$this->content_type = 'multipart/alternative';
	  }

	  $this->error_count = 0; // reset errors
	  $this->set_message_type();
	  $header = $this->create_header();
	  $body = $this->create_body();

	  if (empty($this->body)) {
		throw new MailerException($this->lang('empty_message'), self::STOP_CRITICAL);
	  }

	  // digitally sign with DKIM if enabled
	  if ($this->DKIM_domain && $this->DKIM_private) {
		$header_dkim = $this->DKIM_add($header,$this->subject,$body);
		$header = str_replace("\r\n","\n",$header_dkim) . $header;
	  }

	  // Choose the mailer and send through it
	  switch($this->mailer) {
		case 'sendmail':
		  return $this->sendmail_send($header, $body);
		case 'smtp':
		  return $this->smtp_send($header, $body);
		default:
		  return $this->mail_send($header, $body);
	  }

	} catch (MailerException $e) {
	  $this->set_error($e->getMessage());
	  if ($this->exceptions) {
		throw $e;
	  }
	  echo $e->getMessage()."\n";
	  return false;
	}
  }

  /**
   * Sends mail using the $Sendmail program.
   * @param string $header The message headers
   * @param string $body The message body
   * @access protected
   * @return bool
   */
  protected function sendmail_send($header, $body) {
	if ($this->sender != '') {
	  $sendmail = sprintf("%s -oi -f %s -t", escapeshellcmd($this->sendmail), escapeshellarg($this->sender));
	} else {
	  $sendmail = sprintf("%s -oi -t", escapeshellcmd($this->sendmail));
	}
	if ($this->single_to === true) {
	  foreach ($this->single_to_array as $key => $val) {
		if(!@$mail = popen($sendmail, 'w')) {
		  throw new MailerException($this->lang('execute') . $this->sendmail, self::STOP_CRITICAL);
		}
		fputs($mail, "To: " . $val . "\n");
		fputs($mail, $header);
		fputs($mail, $body);
		$result = pclose($mail);
		// implement call back function if it exists
		$isSent = ($result == 0) ? 1 : 0;
		$this->do_callback($isSent,$val,$this->cc,$this->bcc,$this->subject,$body);
		if($result != 0) {
		  throw new MailerException($this->lang('execute') . $this->sendmail, self::STOP_CRITICAL);
		}
	  }
	} else {
	  if(!@$mail = popen($sendmail, 'w')) {
		throw new MailerException($this->lang('execute') . $this->sendmail, self::STOP_CRITICAL);
	  }
	  fputs($mail, $header);
	  fputs($mail, $body);
	  $result = pclose($mail);
	  // implement call back function if it exists
	  $isSent = ($result == 0) ? 1 : 0;
	  $this->do_callback($isSent,$this->to,$this->cc,$this->bcc,$this->subject,$body);
	  if($result != 0) {
		throw new MailerException($this->lang('execute') . $this->sendmail, self::STOP_CRITICAL);
	  }
	}
	return true;
  }

  /**
   * Sends mail using the PHP mail() function.
   * @param string $header The message headers
   * @param string $body The message body
   * @access protected
   * @return bool
   */
  protected function mail_send($header, $body) {
	$toArr = array();
	foreach($this->to as $t) {
	  $toArr[] = $this->addr_format($t);
	}
	$to = implode(', ', $toArr);

	$params = sprintf("-oi -f %s", $this->sender);
	if ($this->sender != '' && strlen(ini_get('safe_mode'))< 1) {
	  $old_from = ini_get('sendmail_from');
	  ini_set('sendmail_from', $this->sender);
	  if ($this->single_to === true && count($toArr) > 1) {
		foreach ($toArr as $key => $val) {
		  $rt = @mail($val, $this->encode_header($this->secure_header($this->subject)), $body, $header, $params);
		  // implement call back function if it exists
		  $isSent = ($rt == 1) ? 1 : 0;
		  $this->do_callback($isSent,$val,$this->cc,$this->bcc,$this->subject,$body);
		}
	  } else {
		$rt = @mail($to, $this->encode_header($this->secure_header($this->subject)), $body, $header, $params);
		// implement call back function if it exists
		$isSent = ($rt == 1) ? 1 : 0;
		$this->do_callback($isSent,$to,$this->cc,$this->bcc,$this->subject,$body);
	  }
	} else {
	  if ($this->single_to === true && count($toArr) > 1) {
		foreach ($toArr as $key => $val) {
		  $rt = @mail($val, $this->encode_header($this->secure_header($this->subject)), $body, $header, $params);
		  // implement call back function if it exists
		  $isSent = ($rt == 1) ? 1 : 0;
		  $this->do_callback($isSent,$val,$this->cc,$this->bcc,$this->subject,$body);
		}
	  } else {
		$rt = @mail($to, $this->encode_header($this->secure_header($this->subject)), $body, $header);
		// implement call back function if it exists
		$isSent = ($rt == 1) ? 1 : 0;
		$this->do_callback($isSent,$to,$this->cc,$this->bcc,$this->subject,$body);
	  }
	}
	if (isset($old_from)) {
	  ini_set('sendmail_from', $old_from);
	}
	if(!$rt) {
	  throw new MailerException($this->lang('instantiate'), self::STOP_CRITICAL);
	}
	return true;
  }

  /**
   * Sends mail via SMTP using PhpSMTP
   * Returns false if there is a bad MAIL FROM, RCPT, or DATA input.
   * @param string $header The message headers
   * @param string $body The message body
   * @uses SMTP
   * @access protected
   * @return bool
   */
  protected function smtp_send($header, $body) {
	$bad_rcpt = array();

	if(!$this->smtp_connect()) {
	  throw new MailerException($this->lang('smtp_connect_failed'), self::STOP_CRITICAL);
	}
	$smtp_from = ($this->sender == '') ? $this->from : $this->sender;
	if(!$this->smtp->Mail($smtp_from)) {
	  throw new MailerException($this->lang('from_failed') . $smtp_from, self::STOP_CRITICAL);
	}

	// Attempt to send attach all recipients
	foreach($this->to as $to) {
	  if (!$this->smtp->Recipient($to[0])) {
		$bad_rcpt[] = $to[0];
		// implement call back function if it exists
		$isSent = 0;
		$this->do_callback($isSent,$to[0],'','',$this->subject,$body);
	  } else {
		// implement call back function if it exists
		$isSent = 1;
		$this->do_callback($isSent,$to[0],'','',$this->subject,$body);
	  }
	}
	foreach($this->cc as $cc) {
	  if (!$this->smtp->Recipient($cc[0])) {
		$bad_rcpt[] = $cc[0];
		// implement call back function if it exists
		$isSent = 0;
		$this->do_callback($isSent,'',$cc[0],'',$this->subject,$body);
	  } else {
		// implement call back function if it exists
		$isSent = 1;
		$this->do_callback($isSent,'',$cc[0],'',$this->subject,$body);
	  }
	}
	foreach($this->bcc as $bcc) {
	  if (!$this->smtp->Recipient($bcc[0])) {
		$bad_rcpt[] = $bcc[0];
		// implement call back function if it exists
		$isSent = 0;
		$this->do_callback($isSent,'','',$bcc[0],$this->subject,$body);
	  } else {
		// implement call back function if it exists
		$isSent = 1;
		$this->do_callback($isSent,'','',$bcc[0],$this->subject,$body);
	  }
	}


	if (count($bad_rcpt) > 0 ) { //Create error message for any bad addresses
	  $badaddresses = implode(', ', $bad_rcpt);
	  throw new MailerException($this->lang('recipients_failed') . $badaddresses);
	}
	if(!$this->smtp->Data($header . $body)) {
	  throw new MailerException($this->lang('data_not_accepted'), self::STOP_CRITICAL);
	}
	if($this->SMTP_keep_alive == true) {
	  $this->smtp->Reset();
	}
	return true;
  }

  /**
   * Initiates a connection to an SMTP server.
   * Returns false if the operation failed.
   * @uses SMTP
   * @access public
   * @return bool
   */
  public function smtp_connect() {
	if(is_null($this->smtp)) {
	  $this->smtp = new SMTP();
	}

	$this->smtp->do_debug = $this->SMTP_debug;
	$hosts = explode(';', $this->host);
	$index = 0;
	$connection = $this->smtp->Connected();

	// Retry while there is no connection
	try {
	  while($index < count($hosts) && !$connection) {
		$hostinfo = array();
		if (preg_match('/^(.+):([0-9]+)$/', $hosts[$index], $hostinfo)) {
		  $host = $hostinfo[1];
		  $port = $hostinfo[2];
		} else {
		  $host = $hosts[$index];
		  $port = $this->port;
		}

		$tls = ($this->SMTP_secure == 'tls');
		$ssl = ($this->SMTP_secure == 'ssl');

		if ($this->smtp->Connect(($ssl ? 'ssl://':'').$host, $port, $this->timeout)) {

		  $hello = ($this->helo != '' ? $this->helo : $this->server_hostname());
		  $this->smtp->Hello($hello);

		  if ($tls) {
			if (!$this->smtp->StartTLS()) {
			  throw new MailerException($this->lang('tls'));
			}

			//We must resend HELO after tls negotiation
			$this->smtp->Hello($hello);
		  }

		  $connection = true;
		  if ($this->SMTP_auth) {
			if (!$this->smtp->Authenticate($this->username, $this->password)) {
			  throw new MailerException($this->lang('authenticate'));
			}
		  }
		}
		$index++;
		if (!$connection) {
		  throw new MailerException($this->lang('connect_host'));
		}
	  }
	} catch (MailerException $e) {
	  $this->smtp->Reset();
	  throw $e;
	}
	return true;
  }

  /**
   * Closes the active SMTP session if one exists.
   * @return void
   */
  public function smtp_close() {
	if(!is_null($this->smtp)) {
	  if($this->smtp->Connected()) {
		$this->smtp->Quit();
		$this->smtp->Close();
	  }
	}
  }

  /**
  * Sets the language for all class error messages.
  * Returns false if it cannot load the language file.	The default language is English.
  * @param string $langcode ISO 639-1 2-character language code (e.g. Portuguese: "br")
  * @param string $lang_path Path to the language file directory
  * @access public
  */
  function set_language($langcode = 'en', $lang_path = 'language/') {
	//Define full set of translatable strings
	$PHPMAILER_LANG = array(
	  'provide_address' => 'You must provide at least one recipient email address.',
	  'mailer_not_supported' => ' mailer is not supported.',
	  'execute' => 'Could not execute: ',
	  'instantiate' => 'Could not instantiate mail function.',
	  'authenticate' => 'SMTP Error: Could not authenticate.',
	  'from_failed' => 'The following From address failed: ',
	  'recipients_failed' => 'SMTP Error: The following recipients failed: ',
	  'data_not_accepted' => 'SMTP Error: Data not accepted.',
	  'connect_host' => 'SMTP Error: Could not connect to SMTP host.',
	  'file_access' => 'Could not access file: ',
	  'file_open' => 'File Error: Could not open file: ',
	  'encoding' => 'Unknown encoding: ',
	  'signing' => 'Signing Error: ',
	  'smtp_error' => 'SMTP server error: ',
	  'empty_message' => 'Message body empty',
	  'invalid_address' => 'Invalid address',
	  'variable_set' => 'Cannot set or reset variable: '
	);
	//Overwrite language-specific strings. This way we'll never have missing translations - no more "language string failed to load"!
	$l = true;
	if ($langcode != 'en') { //There is no English translation file
	  $l = @include $lang_path.'phpmailer.lang-'.$langcode.'.php';
	}
	$this->language = $PHPMAILER_LANG;
	return ($l == true); //Returns false if language not found
  }

  /**
  * Return the current array of language strings
  * @return array
  */
  public function get_translations() {
	return $this->language;
  }

  /////////////////////////////////////////////////
  // METHODS, MESSAGE CREATION
  /////////////////////////////////////////////////

  /**
   * Creates recipient headers.
   * @access public
   * @return string
   */
  public function addr_append($type, $addr) {
	$addr_str = $type . ': ';
	$addresses = array();
	foreach ($addr as $a) {
	  $addresses[] = $this->addr_format($a);
	}
	$addr_str .= implode(', ', $addresses);
	$addr_str .= $this->LE;

	return $addr_str;
  }

  /**
   * Formats an address correctly.
   * @access public
   * @return string
   */
  public function addr_format($addr) {
	if (empty($addr[1])) {
	  return $this->secure_header($addr[0]);
	} else {
	  return $this->encode_header($this->secure_header($addr[1]), 'phrase') . " <" . $this->secure_header($addr[0]) . ">";
	}
  }

  /**
   * Wraps message for use with mailers that do not
   * automatically perform wrapping and for quoted-printable.
   * Original written by philippe.
   * @param string $message The message to wrap
   * @param integer $length The line length to wrap to
   * @param boolean $qp_mode Whether to run in Quoted-Printable mode
   * @access public
   * @return string
   */
  public function wrap_text($message, $length, $qp_mode = false) {
	$soft_break = ($qp_mode) ? sprintf(" =%s", $this->LE) : $this->LE;
	// If utf-8 encoding is used, we will need to make sure we don't
	// split multibyte characters when we wrap
	$is_utf8 = (strtolower($this->charset) == "utf-8");

	$message = $this->fix_EOL($message);
	if (substr($message, -1) == $this->LE) {
	  $message = substr($message, 0, -1);
	}

	$line = explode($this->LE, $message);
	$message = '';
	for ($i=0 ;$i < count($line); $i++) {
	  $line_part = explode(' ', $line[$i]);
	  $buf = '';
	  for ($e = 0; $e<count($line_part); $e++) {
		$word = $line_part[$e];
		if ($qp_mode and (strlen($word) > $length)) {
		  $space_left = $length - strlen($buf) - 1;
		  if ($e != 0) {
			if ($space_left > 20) {
			  $len = $space_left;
			  if ($is_utf8) {
				$len = $this->UTF8_char_boundary($word, $len);
			  } elseif (substr($word, $len - 1, 1) == "=") {
				$len--;
			  } elseif (substr($word, $len - 2, 1) == "=") {
				$len -= 2;
			  }
			  $part = substr($word, 0, $len);
			  $word = substr($word, $len);
			  $buf .= ' ' . $part;
			  $message .= $buf . sprintf("=%s", $this->LE);
			} else {
			  $message .= $buf . $soft_break;
			}
			$buf = '';
		  }
		  while (strlen($word) > 0) {
			$len = $length;
			if ($is_utf8) {
			  $len = $this->UTF8_char_boundary($word, $len);
			} elseif (substr($word, $len - 1, 1) == "=") {
			  $len--;
			} elseif (substr($word, $len - 2, 1) == "=") {
			  $len -= 2;
			}
			$part = substr($word, 0, $len);
			$word = substr($word, $len);

			if (strlen($word) > 0) {
			  $message .= $part . sprintf("=%s", $this->LE);
			} else {
			  $buf = $part;
			}
		  }
		} else {
		  $buf_o = $buf;
		  $buf .= ($e == 0) ? $word : (' ' . $word);

		  if (strlen($buf) > $length and $buf_o != '') {
			$message .= $buf_o . $soft_break;
			$buf = $word;
		  }
		}
	  }
	  $message .= $buf . $this->LE;
	}

	return $message;
  }

  /**
   * Finds last character boundary prior to maxLength in a utf-8
   * quoted (printable) encoded string.
   * Original written by Colin Brown.
   * @access public
   * @param string $encodedText utf-8 QP text
   * @param int	   $maxLength	find last character boundary prior to this length
   * @return int
   */
  public function UTF8_char_boundary($encodedText, $maxLength) {
	$foundSplitPos = false;
	$lookBack = 3;
	while (!$foundSplitPos) {
	  $lastChunk = substr($encodedText, $maxLength - $lookBack, $lookBack);
	  $encodedCharPos = strpos($lastChunk, "=");
	  if ($encodedCharPos !== false) {
		// Found start of encoded character byte within $lookBack block.
		// Check the encoded byte value (the 2 chars after the '=')
		$hex = substr($encodedText, $maxLength - $lookBack + $encodedCharPos + 1, 2);
		$dec = hexdec($hex);
		if ($dec < 128) { // Single byte character.
		  // If the encoded char was found at pos 0, it will fit
		  // otherwise reduce maxLength to start of the encoded char
		  $maxLength = ($encodedCharPos == 0) ? $maxLength :
		  $maxLength - ($lookBack - $encodedCharPos);
		  $foundSplitPos = true;
		} elseif ($dec >= 192) { // First byte of a multi byte character
		  // Reduce maxLength to split at start of character
		  $maxLength = $maxLength - ($lookBack - $encodedCharPos);
		  $foundSplitPos = true;
		} elseif ($dec < 192) { // Middle byte of a multi byte character, look further back
		  $lookBack += 3;
		}
	  } else {
		// No encoded character found
		$foundSplitPos = true;
	  }
	}
	return $maxLength;
  }


  /**
   * Set the body wrapping.
   * @access public
   * @return void
   */
  public function set_word_wrap() {
	if($this->word_wrap < 1) {
	  return;
	}

	switch($this->message_type) {
	  case 'alt':
	  case 'alt_attachments':
		$this->alt_body = $this->wrap_text($this->alt_body, $this->word_wrap);
		break;
	  default:
		$this->body = $this->wrap_text($this->body, $this->word_wrap);
		break;
	}
  }

  /**
   * Assembles message header.
   * @access public
   * @return string The assembled header
   */
  public function create_header() {
	$result = '';

	// Set the boundaries
	$uniq_id = md5(uniqid(time()));
	$this->boundary[1] = 'b1_' . $uniq_id;
	$this->boundary[2] = 'b2_' . $uniq_id;

	$result .= $this->header_line('Date', self::RFC_date());
	if($this->sender == '') {
	  $result .= $this->header_line('Return-Path', trim($this->from));
	} else {
	  $result .= $this->header_line('Return-Path', trim($this->sender));
	}

	// To be created automatically by mail()
	if($this->mailer != 'mail') {
	  if ($this->single_to === true) {
		foreach($this->to as $t) {
		  $this->single_to_array[] = $this->addr_format($t);
		}
	  } else {
		if(count($this->to) > 0) {
		  $result .= $this->addr_append('To', $this->to);
		} elseif (count($this->cc) == 0) {
		  $result .= $this->header_line('To', 'undisclosed-recipients:;');
		}
	  }
	}

	$from = array();
	$from[0][0] = trim($this->from);
	$from[0][1] = $this->from_name;
	$result .= $this->addr_append('From', $from);

	// sendmail and mail() extract Cc from the header before sending
	if(count($this->cc) > 0) {
	  $result .= $this->addr_append('Cc', $this->cc);
	}

	// sendmail and mail() extract Bcc from the header before sending
	if((($this->mailer == 'sendmail') || ($this->mailer == 'mail')) && (count($this->bcc) > 0)) {
	  $result .= $this->addr_append('Bcc', $this->bcc);
	}

	if(count($this->ReplyTo) > 0) {
	  $result .= $this->addr_append('Reply-to', $this->ReplyTo);
	}

	// mail() sets the subject itself
	if($this->mailer != 'mail') {
	  $result .= $this->header_line('Subject', $this->encode_header($this->secure_header($this->subject)));
	}

	if($this->message_id != '') {
	  $result .= $this->header_line('Message-ID',$this->message_id);
	} else {
	  $result .= sprintf("Message-ID: <%s@%s>%s", $uniq_id, $this->server_hostname(), $this->LE);
	}
	$result .= $this->header_line('X-Priority', $this->priority);
	$result .= $this->header_line('X-Mailer', 'PHPMailer '.$this->version.' (phpmailer.sourceforge.net)');

	if($this->confirm_reading_to != '') {
	  $result .= $this->header_line('Disposition-Notification-To', '<' . trim($this->confirm_reading_to) . '>');
	}

	// Add custom headers
	for($index = 0; $index < count($this->CustomHeader); $index++) {
	  $result .= $this->header_line(trim($this->CustomHeader[$index][0]), $this->encode_header(trim($this->CustomHeader[$index][1])));
	}
	if (!$this->sign_key_file) {
	  $result .= $this->header_line('MIME-Version', '1.0');
	  $result .= $this->get_mail_MIME();
	}

	return $result;
  }

  /**
   * Returns the message MIME.
   * @access public
   * @return string
   */
  public function get_mail_MIME() {
	$result = '';
	switch($this->message_type) {
	  case 'plain':
		$result .= $this->header_line('Content-Transfer-Encoding', $this->encoding);
		$result .= sprintf("Content-Type: %s; charset=\"%s\"", $this->content_type, $this->charset);
		break;
	  case 'attachments':
	  case 'alt_attachments':
		if($this->inline_image_exists()){
		  $result .= sprintf("Content-Type: %s;%s\ttype=\"text/html\";%s\tboundary=\"%s\"%s", 'multipart/related', $this->LE, $this->LE, $this->boundary[1], $this->LE);
		} else {
		  $result .= $this->header_line('Content-Type', 'multipart/mixed;');
		  $result .= $this->text_line("\tboundary=\"" . $this->boundary[1] . '"');
		}
		break;
	  case 'alt':
		$result .= $this->header_line('Content-Type', 'multipart/alternative;');
		$result .= $this->text_line("\tboundary=\"" . $this->boundary[1] . '"');
		break;
	}

	if($this->mailer != 'mail') {
	  $result .= $this->LE.$this->LE;
	}

	return $result;
  }

  /**
   * Assembles the message body.  Returns an empty string on failure.
   * @access public
   * @return string The assembled message body
   */
  public function create_body() {
	$body = '';

	if ($this->sign_key_file) {
	  $body .= $this->get_mail_MIME();
	}

	$this->set_word_wrap();

	switch($this->message_type) {
	  case 'alt':
		$body .= $this->get_boundary($this->boundary[1], '', 'text/plain', '');
		$body .= $this->encode_string($this->alt_body, $this->encoding);
		$body .= $this->LE.$this->LE;
		$body .= $this->get_boundary($this->boundary[1], '', 'text/html', '');
		$body .= $this->encode_string($this->body, $this->encoding);
		$body .= $this->LE.$this->LE;
		$body .= $this->end_boundary($this->boundary[1]);
		break;
	  case 'plain':
		$body .= $this->encode_string($this->body, $this->encoding);
		break;
	  case 'attachments':
		$body .= $this->get_boundary($this->boundary[1], '', '', '');
		$body .= $this->encode_string($this->body, $this->encoding);
		$body .= $this->LE;
		$body .= $this->attach_all();
		break;
	  case 'alt_attachments':
		$body .= sprintf("--%s%s", $this->boundary[1], $this->LE);
		$body .= sprintf("Content-Type: %s;%s" . "\tboundary=\"%s\"%s", 'multipart/alternative', $this->LE, $this->boundary[2], $this->LE.$this->LE);
		$body .= $this->get_boundary($this->boundary[2], '', 'text/plain', '') . $this->LE; // Create text body
		$body .= $this->encode_string($this->alt_body, $this->encoding);
		$body .= $this->LE.$this->LE;
		$body .= $this->get_boundary($this->boundary[2], '', 'text/html', '') . $this->LE; // Create the HTML body
		$body .= $this->encode_string($this->body, $this->encoding);
		$body .= $this->LE.$this->LE;
		$body .= $this->end_boundary($this->boundary[2]);
		$body .= $this->attach_all();
		break;
	}

	if ($this->is_error()) {
	  $body = '';
	} elseif ($this->sign_key_file) {
	  try {
		$file = tempnam('', 'mail');
		file_put_contents($file, $body); //TODO check this worked
		$signed = tempnam("", "signed");
		if (@openssl_pkcs7_sign($file, $signed, "file://".$this->sign_cert_file, array("file://".$this->sign_key_file, $this->sign_key_pass), NULL)) {
		  @unlink($file);
		  @unlink($signed);
		  $body = file_get_contents($signed);
		} else {
		  @unlink($file);
		  @unlink($signed);
		  throw new MailerException($this->lang("signing").openssl_error_string());
		}
	  } catch (MailerException $e) {
		$body = '';
		if ($this->exceptions) {
		  throw $e;
		}
	  }
	}

	return $body;
  }

  /**
   * Returns the start of a message boundary.
   * @access private
   */
  private function get_boundary($boundary, $charSet, $contentType, $encoding) {
	$result = '';
	if($charSet == '') {
	  $charSet = $this->charset;
	}
	if($contentType == '') {
	  $contentType = $this->content_type;
	}
	if($encoding == '') {
	  $encoding = $this->encoding;
	}
	$result .= $this->text_line('--' . $boundary);
	$result .= sprintf("Content-Type: %s; charset = \"%s\"", $contentType, $charSet);
	$result .= $this->LE;
	$result .= $this->header_line('Content-Transfer-Encoding', $encoding);
	$result .= $this->LE;

	return $result;
  }

  /**
   * Returns the end of a message boundary.
   * @access private
   */
  private function end_boundary($boundary) {
	return $this->LE . '--' . $boundary . '--' . $this->LE;
  }

  /**
   * Sets the message type.
   * @access private
   * @return void
   */
  private function set_message_type() {
	if(count($this->attachment) < 1 && strlen($this->alt_body) < 1) {
	  $this->message_type = 'plain';
	} else {
	  if(count($this->attachment) > 0) {
		$this->message_type = 'attachments';
	  }
	  if(strlen($this->alt_body) > 0 && count($this->attachment) < 1) {
		$this->message_type = 'alt';
	  }
	  if(strlen($this->alt_body) > 0 && count($this->attachment) > 0) {
		$this->message_type = 'alt_attachments';
	  }
	}
  }

  /**
   *  Returns a formatted header line.
   * @access public
   * @return string
   */
  public function header_line($name, $value) {
	return $name . ': ' . $value . $this->LE;
  }

  /**
   * Returns a formatted mail line.
   * @access public
   * @return string
   */
  public function text_line($value) {
	return $value . $this->LE;
  }

  /////////////////////////////////////////////////
  // CLASS METHODS, ATTACHMENTS
  /////////////////////////////////////////////////

  /**
   * Adds an attachment from a path on the filesystem.
   * Returns false if the file could not be found
   * or accessed.
   * @param string $path Path to the attachment.
   * @param string $name Overrides the attachment name.
   * @param string $encoding File encoding (see $encoding).
   * @param string $type File extension (MIME) type.
   * @return bool
   */
  public function add_attachment($path, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {
	try {
	  if ( !@is_file($path) ) {
		throw new MailerException($this->lang('file_access') . $path, self::STOP_CONTINUE);
	  }
	  $filename = basename($path);
	  if ( $name == '' ) {
		$name = $filename;
	  }

	  $this->attachment[] = array(
		0 => $path,
		1 => $filename,
		2 => $name,
		3 => $encoding,
		4 => $type,
		5 => false,	 // isStringAttachment
		6 => 'attachment',
		7 => 0
	  );

	} catch (MailerException $e) {
	  $this->set_error($e->getMessage());
	  if ($this->exceptions) {
		throw $e;
	  }
	  echo $e->getMessage()."\n";
	  if ( $e->getCode() == self::STOP_CRITICAL ) {
		return false;
	  }
	}
	return true;
  }

  /**
  * Return the current array of attachments
  * @return array
  */
  public function get_attachments() {
	return $this->attachment;
  }

  /**
   * Attaches all fs, string, and binary attachments to the message.
   * Returns an empty string on failure.
   * @access private
   * @return string
   */
  private function attach_all() {
	// Return text of body
	$mime = array();
	$cidUniq = array();
	$incl = array();

	// Add all attachments
	foreach ($this->attachment as $attachment) {
	  // Check for string attachment
	  $bString = $attachment[5];
	  if ($bString) {
		$string = $attachment[0];
	  } else {
		$path = $attachment[0];
	  }

	  if (in_array($attachment[0], $incl)) { continue; }
	  $filename	   = $attachment[1];
	  $name		   = $attachment[2];
	  $encoding	   = $attachment[3];
	  $type		   = $attachment[4];
	  $disposition = $attachment[6];
	  $cid		   = $attachment[7];
	  $incl[]	   = $attachment[0];
	  if ( $disposition == 'inline' && isset($cidUniq[$cid]) ) { continue; }
	  $cidUniq[$cid] = true;

	  $mime[] = sprintf("--%s%s", $this->boundary[1], $this->LE);
	  $mime[] = sprintf("Content-Type: %s; name=\"%s\"%s", $type, $this->encode_header($this->secure_header($name)), $this->LE);
	  $mime[] = sprintf("Content-Transfer-Encoding: %s%s", $encoding, $this->LE);

	  if($disposition == 'inline') {
		$mime[] = sprintf("Content-ID: <%s>%s", $cid, $this->LE);
	  }

	  $mime[] = sprintf("Content-Disposition: %s; filename=\"%s\"%s", $disposition, $this->encode_header($this->secure_header($name)), $this->LE.$this->LE);

	  // Encode as string attachment
	  if($bString) {
		$mime[] = $this->encode_string($string, $encoding);
		if($this->is_error()) {
		  return '';
		}
		$mime[] = $this->LE.$this->LE;
	  } else {
		$mime[] = $this->encode_file($path, $encoding);
		if($this->is_error()) {
		  return '';
		}
		$mime[] = $this->LE.$this->LE;
	  }
	}

	$mime[] = sprintf("--%s--%s", $this->boundary[1], $this->LE);

	return join('', $mime);
  }

  /**
   * Encodes attachment in requested format.
   * Returns an empty string on failure.
   * @param string $path The full path to the file
   * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'
   * @see encode_file()
   * @access private
   * @return string
   */
  private function encode_file($path, $encoding = 'base64') {
	try {
	  if (!is_readable($path)) {
		throw new MailerException($this->lang('file_open') . $path, self::STOP_CONTINUE);
	  }
	  if (function_exists('get_magic_quotes')) {
		function get_magic_quotes() {
		  return false;
		}
	  }
	  if (PHP_VERSION < 6) {
		$magic_quotes = get_magic_quotes_runtime();
		set_magic_quotes_runtime(0);
	  }
	  $file_buffer	= file_get_contents($path);
	  $file_buffer	= $this->encode_string($file_buffer, $encoding);
	  if (PHP_VERSION < 6) { set_magic_quotes_runtime($magic_quotes); }
	  return $file_buffer;
	} catch (\Exception $e) {
	  $this->set_error($e->getMessage());
	  return '';
	}
  }

  /**
   * Encodes string to requested format.
   * Returns an empty string on failure.
   * @param string $str The text to encode
   * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'
   * @access public
   * @return string
   */
  public function encode_string($str, $encoding = 'base64') {
	$encoded = '';
	switch(strtolower($encoding)) {
	  case 'base64':
		$encoded = chunk_split(base64_encode($str), 76, $this->LE);
		break;
	  case '7bit':
	  case '8bit':
		$encoded = $this->fix_EOL($str);
		//Make sure it ends with a line break
		if (substr($encoded, -(strlen($this->LE))) != $this->LE)
		  $encoded .= $this->LE;
		break;
	  case 'binary':
		$encoded = $str;
		break;
	  case 'quoted-printable':
		$encoded = $this->encode_QP($str);
		break;
	  default:
		$this->set_error($this->lang('encoding') . $encoding);
		break;
	}
	return $encoded;
  }

  /**
   * Encode a header string to best (shortest) of Q, B, quoted or none.
   * @access public
   * @return string
   */
  public function encode_header($str, $position = 'text') {
	$x = 0;

	switch (strtolower($position)) {
	  case 'phrase':
		if (!preg_match('/[\200-\377]/', $str)) {
		  // Can't use addslashes as we don't know what value has magic_quotes_sybase
		  $encoded = addcslashes($str, "\0..\37\177\\\"");
		  if (($str == $encoded) && !preg_match('/[^A-Za-z0-9!#$%&\'*+\/=?^_`{|}~ -]/', $str)) {
			return ($encoded);
		  } else {
			return ("\"$encoded\"");
		  }
		}
		$x = preg_match_all('/[^\040\041\043-\133\135-\176]/', $str, $matches);
		break;
	  case 'comment':
		$x = preg_match_all('/[()"]/', $str, $matches);
		// Fall-through
	  case 'text':
	  default:
		$x += preg_match_all('/[\000-\010\013\014\016-\037\177-\377]/', $str, $matches);
		break;
	}

	if ($x == 0) {
	  return ($str);
	}

	$maxlen = 75 - 7 - strlen($this->charset);
	// Try to select the encoding which should produce the shortest output
	if (strlen($str)/3 < $x) {
	  $encoding = 'B';
	  if (function_exists('mb_strlen') && $this->has_multi_bytes($str)) {
		// Use a custom function which correctly encodes and wraps long
		// multibyte strings without breaking lines within a character
		$encoded = $this->base64_encode_wrap_MB($str);
	  } else {
		$encoded = base64_encode($str);
		$maxlen -= $maxlen % 4;
		$encoded = trim(chunk_split($encoded, $maxlen, "\n"));
	  }
	} else {
	  $encoding = 'Q';
	  $encoded = $this->encode_Q($str, $position);
	  $encoded = $this->wrap_text($encoded, $maxlen, true);
	  $encoded = str_replace('='.$this->LE, "\n", trim($encoded));
	}

	$encoded = preg_replace('/^(.*)$/m', " =?".$this->charset."?$encoding?\\1?=", $encoded);
	$encoded = trim(str_replace("\n", $this->LE, $encoded));

	return $encoded;
  }

  /**
   * Checks if a string contains multibyte characters.
   * @access public
   * @param string $str multi-byte text to wrap encode
   * @return bool
   */
  public function has_multi_bytes($str) {
	if (function_exists('mb_strlen')) {
	  return (strlen($str) > mb_strlen($str, $this->charset));
	} else { // Assume no multibytes (we can't handle without mbstring functions anyway)
	  return false;
	}
  }

  /**
   * Correctly encodes and wraps long multibyte strings for mail headers
   * without breaking lines within a character.
   * Adapted from a function by paravoid at http://uk.php.net/manual/en/function.mb-encode-mimeheader.php
   * @access public
   * @param string $str multi-byte text to wrap encode
   * @return string
   */
  public function base64_encode_wrap_MB($str) {
	$start = "=?".$this->charset."?B?";
	$end = "?=";
	$encoded = "";

	$mb_length = mb_strlen($str, $this->charset);
	// Each line must have length <= 75, including $start and $end
	$length = 75 - strlen($start) - strlen($end);
	// Average multi-byte ratio
	$ratio = $mb_length / strlen($str);
	// Base64 has a 4:3 ratio
	$offset = $avgLength = floor($length * $ratio * .75);

	for ($i = 0; $i < $mb_length; $i += $offset) {
	  $lookBack = 0;

	  do {
		$offset = $avgLength - $lookBack;
		$chunk = mb_substr($str, $i, $offset, $this->charset);
		$chunk = base64_encode($chunk);
		$lookBack++;
	  }
	  while (strlen($chunk) > $length);

	  $encoded .= $chunk . $this->LE;
	}

	// Chomp the last linefeed
	$encoded = substr($encoded, 0, -strlen($this->LE));
	return $encoded;
  }

  /**
  * Encode string to quoted-printable.
  * Only uses standard PHP, slow, but will always work
  * @access public
  * @param string $string the text to encode
  * @param integer $line_max Number of chars allowed on a line before wrapping
  * @return string
  */
  public function encode_QP_php( $input = '', $line_max = 76, $space_conv = false) {
	$hex = array('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F');
	$lines = preg_split('/(?:\r\n|\r|\n)/', $input);
	$eol = "\r\n";
	$escape = '=';
	$output = '';
	while( list(, $line) = each($lines) ) {
	  $linlen = strlen($line);
	  $newline = '';
	  for($i = 0; $i < $linlen; $i++) {
		$c = substr( $line, $i, 1 );
		$dec = ord( $c );
		if ( ( $i == 0 ) && ( $dec == 46 ) ) { // convert first point in the line into =2E
		  $c = '=2E';
		}
		if ( $dec == 32 ) {
		  if ( $i == ( $linlen - 1 ) ) { // convert space at eol only
			$c = '=20';
		  } else if ( $space_conv ) {
			$c = '=20';
		  }
		} elseif ( ($dec == 61) || ($dec < 32 ) || ($dec > 126) ) { // always encode "\t", which is *not* required
		  $h2 = floor($dec/16);
		  $h1 = floor($dec%16);
		  $c = $escape.$hex[$h2].$hex[$h1];
		}
		if ( (strlen($newline) + strlen($c)) >= $line_max ) { // CRLF is not counted
		  $output .= $newline.$escape.$eol; //	soft line break; " =\r\n" is okay
		  $newline = '';
		  // check if newline first character will be point or not
		  if ( $dec == 46 ) {
			$c = '=2E';
		  }
		}
		$newline .= $c;
	  } // end of for
	  $output .= $newline.$eol;
	} // end of while
	return $output;
  }

  /**
  * Encode string to RFC2045 (6.7) quoted-printable format
  * Uses a PHP5 stream filter to do the encoding about 64x faster than the old version
  * Also results in same content as you started with after decoding
  * @see encode_QP_php()
  * @access public
  * @param string $string the text to encode
  * @param integer $line_max Number of chars allowed on a line before wrapping
  * @param boolean $space_conv Dummy param for compatibility with existing encode_QP function
  * @return string
  * @author Marcus Bointon
  */
  public function encode_QP($string, $line_max = 76, $space_conv = false) {
	if (function_exists('quoted_printable_encode')) { //Use native function if it's available (>= PHP5.3)
	  return quoted_printable_encode($string);
	}
	$filters = stream_get_filters();
	if (!in_array('convert.*', $filters)) { //Got convert stream filter?
	  return $this->encode_QP_php($string, $line_max, $space_conv); //Fall back to old implementation
	}
	$fp = fopen('php://temp/', 'r+');
	$string = preg_replace('/\r\n?/', $this->LE, $string); //Normalise line breaks
	$params = array('line-length' => $line_max, 'line-break-chars' => $this->LE);
	$s = stream_filter_append($fp, 'convert.quoted-printable-encode', STREAM_FILTER_READ, $params);
	fputs($fp, $string);
	rewind($fp);
	$out = stream_get_contents($fp);
	stream_filter_remove($s);
	$out = preg_replace('/^\./m', '=2E', $out); //Encode . if it is first char on a line, workaround for bug in Exchange
	fclose($fp);
	return $out;
  }

  /**
   * Encode string to q encoding.
   * @link http://tools.ietf.org/html/rfc2047
   * @param string $str the text to encode
   * @param string $position Where the text is going to be used, see the RFC for what that means
   * @access public
   * @return string
   */
  public function encode_Q($str, $position = 'text') {
	// There should not be any EOL in the string
	$encoded = preg_replace('/[\r\n]*/', '', $str);

	switch (strtolower($position)) {
	  case 'phrase':
		$encoded = preg_replace("/([^A-Za-z0-9!*+\/ -])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
		break;
	  case 'comment':
		$encoded = preg_replace("/([\(\)\"])/e", "'='.sprintf('%02X', ord('\\1'))", $encoded);
	  case 'text':
	  default:
		// Replace every high ascii, control =, ? and _ characters
		//TODO using /e (equivalent to eval()) is probably not a good idea
		$encoded = preg_replace('/([\000-\011\013\014\016-\037\075\077\137\177-\377])/e',
			  "'='.sprintf('%02X', ord('\\1'))", $encoded);
		break;
	}

	// Replace every spaces to _ (more readable than =20)
	$encoded = str_replace(' ', '_', $encoded);

	return $encoded;
  }

  /**
   * Adds a string or binary attachment (non-filesystem) to the list.
   * This method can be used to attach ascii or binary data,
   * such as a BLOB record from a database.
   * @param string $string String attachment data.
   * @param string $filename Name of the attachment.
   * @param string $encoding File encoding (see $encoding).
   * @param string $type File extension (MIME) type.
   * @return void
   */
  public function add_string_attachment($string, $filename, $encoding = 'base64', $type = 'application/octet-stream') {
	// Append to $attachment array
	$this->attachment[] = array(
	  0 => $string,
	  1 => $filename,
	  2 => basename($filename),
	  3 => $encoding,
	  4 => $type,
	  5 => true,  // isStringAttachment
	  6 => 'attachment',
	  7 => 0
	);
  }

  /**
   * Adds an embedded attachment.  This can include images, sounds, and
   * just about any other document.	 Make sure to set the $type to an
   * image type.  For JPEG images use "image/jpeg" and for GIF images
   * use "image/gif".
   * @param string $path Path to the attachment.
   * @param string $cid Content ID of the attachment.  Use this to identify
   *		the Id for accessing the image in an HTML form.
   * @param string $name Overrides the attachment name.
   * @param string $encoding File encoding (see $encoding).
   * @param string $type File extension (MIME) type.
   * @return bool
   */
  public function add_embedded_image($path, $cid, $name = '', $encoding = 'base64', $type = 'application/octet-stream') {

	if ( !@is_file($path) ) {
	  $this->set_error($this->lang('file_access') . $path);
	  return false;
	}

	$filename = basename($path);
	if ( $name == '' ) {
	  $name = $filename;
	}

	// Append to $attachment array
	$this->attachment[] = array(
	  0 => $path,
	  1 => $filename,
	  2 => $name,
	  3 => $encoding,
	  4 => $type,
	  5 => false,  // isStringAttachment
	  6 => 'inline',
	  7 => $cid
	);

	return true;
  }

  /**
   * Returns true if an inline attachment is present.
   * @access public
   * @return bool
   */
  public function inline_image_exists() {
	foreach($this->attachment as $attachment) {
	  if ($attachment[6] == 'inline') {
		return true;
	  }
	}
	return false;
  }

  /////////////////////////////////////////////////
  // CLASS METHODS, MESSAGE RESET
  /////////////////////////////////////////////////

  /**
   * Clears all recipients assigned in the TO array.  Returns void.
   * @return void
   */
  public function clear_addresses() {
	foreach($this->to as $to) {
	  unset($this->all_recipients[strtolower($to[0])]);
	}
	$this->to = array();
  }

  /**
   * Clears all recipients assigned in the CC array.  Returns void.
   * @return void
   */
  public function clear_CCs() {
	foreach($this->cc as $cc) {
	  unset($this->all_recipients[strtolower($cc[0])]);
	}
	$this->cc = array();
  }

  /**
   * Clears all recipients assigned in the BCC array.  Returns void.
   * @return void
   */
  public function clear_BCCs() {
	foreach($this->bcc as $bcc) {
	  unset($this->all_recipients[strtolower($bcc[0])]);
	}
	$this->bcc = array();
  }

  /**
   * Clears all recipients assigned in the ReplyTo array.  Returns void.
   * @return void
   */
  public function clear_reply_tos() {
	$this->ReplyTo = array();
  }

  /**
   * Clears all recipients assigned in the TO, CC and BCC
   * array.	 Returns void.
   * @return void
   */
  public function clear_all_recipients() {
	$this->to = array();
	$this->cc = array();
	$this->bcc = array();
	$this->all_recipients = array();
  }

  /**
   * Clears all previously set filesystem, string, and binary
   * attachments.  Returns void.
   * @return void
   */
  public function clear_attachments() {
	$this->attachment = array();
  }

  /**
   * Clears all custom headers.	 Returns void.
   * @return void
   */
  public function clear_custom_headers() {
	$this->CustomHeader = array();
  }

  /////////////////////////////////////////////////
  // CLASS METHODS, MISCELLANEOUS
  /////////////////////////////////////////////////

  /**
   * Adds the error message to the error container.
   * @access protected
   * @return void
   */
  protected function set_error($msg) {
	$this->error_count++;
	if ($this->mailer == 'smtp' and !is_null($this->smtp)) {
	  $lasterror = $this->smtp->getError();
	  if (!empty($lasterror) and array_key_exists('smtp_msg', $lasterror)) {
		$msg .= '<p>' . $this->lang('smtp_error') . $lasterror['smtp_msg'] . "</p>\n";
	  }
	}
	$this->error_info = $msg;
  }

  /**
   * Returns the proper RFC 822 formatted date.
   * @access public
   * @return string
   * @static
   */
  public static function RFC_date() {
	$tz = date('Z');
	$tzs = ($tz < 0) ? '-' : '+';
	$tz = abs($tz);
	$tz = (int)($tz/3600)*100 + ($tz%3600)/60;
	$result = sprintf("%s %s%04d", date('D, j M Y H:i:s'), $tzs, $tz);

	return $result;
  }

  /**
   * Returns the server hostname or 'localhost.localdomain' if unknown.
   * @access private
   * @return string
   */
  private function server_hostname() {
	if (!empty($this->hostname)) {
	  $result = $this->hostname;
	} elseif (isset($_SERVER['SERVER_NAME'])) {
	  $result = $_SERVER['SERVER_NAME'];
	} else {
	  $result = 'localhost.localdomain';
	}

	return $result;
  }

  /**
   * Returns a message in the appropriate language.
   * @access private
   * @return string
   */
  private function lang($key) {
	if(count($this->language) < 1) {
	  $this->set_language('en'); // set the default language
	}

	if(isset($this->language[$key])) {
	  return $this->language[$key];
	} else {
	  return 'Language string failed to load: ' . $key;
	}
  }

  /**
   * Returns true if an error occurred.
   * @access public
   * @return bool
   */
  public function is_error() {
	return ($this->error_count > 0);
  }

  /**
   * Changes every end of line from CR or LF to CRLF.
   * @access private
   * @return string
   */
  private function fix_EOL($str) {
	$str = str_replace("\r\n", "\n", $str);
	$str = str_replace("\r", "\n", $str);
	$str = str_replace("\n", $this->LE, $str);
	return $str;
  }

  /**
   * Adds a custom header.
   * @access public
   * @return void
   */
  public function add_custom_header($custom_header) {
	$this->CustomHeader[] = explode(':', $custom_header, 2);
  }

  /**
   * Evaluates the message and returns modifications for inline images and backgrounds
   * @access public
   * @return $message
   */
  public function msg_html($message, $basedir = '') {
	preg_match_all("/(src|background)=\"(.*)\"/Ui", $message, $images);
	if(isset($images[2])) {
	  foreach($images[2] as $i => $url) {
		// do not change urls for absolute images (thanks to corvuscorax)
		if (!preg_match('#^[A-z]+://#',$url)) {
		  $filename = basename($url);
		  $directory = dirname($url);
		  ($directory == '.')?$directory='':'';
		  $cid = 'cid:' . md5($filename);
		  $ext = pathinfo($filename, PATHINFO_EXTENSION);
		  $mimeType	 = self::_mime_types($ext);
		  if ( strlen($basedir) > 1 && substr($basedir,-1) != '/') { $basedir .= '/'; }
		  if ( strlen($directory) > 1 && substr($directory,-1) != '/') { $directory .= '/'; }
		  if ( $this->add_embedded_image($basedir.$directory.$filename, md5($filename), $filename, 'base64',$mimeType) ) {
			$message = preg_replace("/".$images[1][$i]."=\"".preg_quote($url, '/')."\"/Ui", $images[1][$i]."=\"".$cid."\"", $message);
		  }
		}
	  }
	}
	$this->use_html(true);
	$this->body = $message;
	$textMsg = trim(strip_tags(preg_replace('/<(head|title|style|script)[^>]*>.*?<\/\\1>/s','',$message)));
	if (!empty($textMsg) && empty($this->alt_body)) {
	  $this->alt_body = html_entity_decode($textMsg);
	}
	if (empty($this->alt_body)) {
	  $this->alt_body = 'To view this email message, open it in a program that understands HTML!' . "\n\n";
	}
  }

  /**
   * Gets the MIME type of the embedded or inline image
   * @param string File extension
   * @access public
   * @return string MIME type of ext
   * @static
   */
  public static function _mime_types($ext = '') {
	$mimes = array(
	  'hqx'	  =>  'application/mac-binhex40',
	  'cpt'	  =>  'application/mac-compactpro',
	  'doc'	  =>  'application/msword',
	  'bin'	  =>  'application/macbinary',
	  'dms'	  =>  'application/octet-stream',
	  'lha'	  =>  'application/octet-stream',
	  'lzh'	  =>  'application/octet-stream',
	  'exe'	  =>  'application/octet-stream',
	  'class' =>  'application/octet-stream',
	  'psd'	  =>  'application/octet-stream',
	  'so'	  =>  'application/octet-stream',
	  'sea'	  =>  'application/octet-stream',
	  'dll'	  =>  'application/octet-stream',
	  'oda'	  =>  'application/oda',
	  'pdf'	  =>  'application/pdf',
	  'ai'	  =>  'application/postscript',
	  'eps'	  =>  'application/postscript',
	  'ps'	  =>  'application/postscript',
	  'smi'	  =>  'application/smil',
	  'smil'  =>  'application/smil',
	  'mif'	  =>  'application/vnd.mif',
	  'xls'	  =>  'application/vnd.ms-excel',
	  'ppt'	  =>  'application/vnd.ms-powerpoint',
	  'wbxml' =>  'application/vnd.wap.wbxml',
	  'wmlc'  =>  'application/vnd.wap.wmlc',
	  'dcr'	  =>  'application/x-director',
	  'dir'	  =>  'application/x-director',
	  'dxr'	  =>  'application/x-director',
	  'dvi'	  =>  'application/x-dvi',
	  'gtar'  =>  'application/x-gtar',
	  'php'	  =>  'application/x-httpd-php',
	  'php4'  =>  'application/x-httpd-php',
	  'php3'  =>  'application/x-httpd-php',
	  'phtml' =>  'application/x-httpd-php',
	  'phps'  =>  'application/x-httpd-php-source',
	  'js'	  =>  'application/x-javascript',
	  'swf'	  =>  'application/x-shockwave-flash',
	  'sit'	  =>  'application/x-stuffit',
	  'tar'	  =>  'application/x-tar',
	  'tgz'	  =>  'application/x-tar',
	  'xhtml' =>  'application/xhtml+xml',
	  'xht'	  =>  'application/xhtml+xml',
	  'zip'	  =>  'application/zip',
	  'mid'	  =>  'audio/midi',
	  'midi'  =>  'audio/midi',
	  'mpga'  =>  'audio/mpeg',
	  'mp2'	  =>  'audio/mpeg',
	  'mp3'	  =>  'audio/mpeg',
	  'aif'	  =>  'audio/x-aiff',
	  'aiff'  =>  'audio/x-aiff',
	  'aifc'  =>  'audio/x-aiff',
	  'ram'	  =>  'audio/x-pn-realaudio',
	  'rm'	  =>  'audio/x-pn-realaudio',
	  'rpm'	  =>  'audio/x-pn-realaudio-plugin',
	  'ra'	  =>  'audio/x-realaudio',
	  'rv'	  =>  'video/vnd.rn-realvideo',
	  'wav'	  =>  'audio/x-wav',
	  'bmp'	  =>  'image/bmp',
	  'gif'	  =>  'image/gif',
	  'jpeg'  =>  'image/jpeg',
	  'jpg'	  =>  'image/jpeg',
	  'jpe'	  =>  'image/jpeg',
	  'png'	  =>  'image/png',
	  'tiff'  =>  'image/tiff',
	  'tif'	  =>  'image/tiff',
	  'css'	  =>  'text/css',
	  'html'  =>  'text/html',
	  'htm'	  =>  'text/html',
	  'shtml' =>  'text/html',
	  'txt'	  =>  'text/plain',
	  'text'  =>  'text/plain',
	  'log'	  =>  'text/plain',
	  'rtx'	  =>  'text/richtext',
	  'rtf'	  =>  'text/rtf',
	  'xml'	  =>  'text/xml',
	  'xsl'	  =>  'text/xml',
	  'mpeg'  =>  'video/mpeg',
	  'mpg'	  =>  'video/mpeg',
	  'mpe'	  =>  'video/mpeg',
	  'qt'	  =>  'video/quicktime',
	  'mov'	  =>  'video/quicktime',
	  'avi'	  =>  'video/x-msvideo',
	  'movie' =>  'video/x-sgi-movie',
	  'doc'	  =>  'application/msword',
	  'word'  =>  'application/msword',
	  'xl'	  =>  'application/excel',
	  'eml'	  =>  'message/rfc822'
	);
	return (!isset($mimes[strtolower($ext)])) ? 'application/octet-stream' : $mimes[strtolower($ext)];
  }

  /**
  * Set (or reset) Class Objects (variables)
  *
  * Usage Example:
  * $page->set('X-Priority', '3');
  *
  * @access public
  * @param string $name Parameter Name
  * @param mixed $value Parameter Value
  * NOTE: will not work with arrays, there are no arrays to set/reset
  * @todo Should this not be using __set() magic function?
  */
  public function set($name, $value = '') {
	try {
	  if (isset($this->$name) ) {
		$this->$name = $value;
	  } else {
		throw new MailerException($this->lang('variable_set') . $name, self::STOP_CRITICAL);
	  }
	} catch (\Exception $e) {
	  $this->set_error($e->getMessage());
	  if ($e->getCode() == self::STOP_CRITICAL) {
		return false;
	  }
	}
	return true;
  }

  /**
   * Strips newlines to prevent header injection.
   * @access public
   * @param string $str String
   * @return string
   */
  public function secure_header($str) {
	$str = str_replace("\r", '', $str);
	$str = str_replace("\n", '', $str);
	return trim($str);
  }

  /**
   * Set the private key file and password to sign the message.
   *
   * @access public
   * @param string $key_filename Parameter File Name
   * @param string $key_pass Password for private key
   */
  public function Sign($cert_filename, $key_filename, $key_pass) {
	$this->sign_cert_file = $cert_filename;
	$this->sign_key_file = $key_filename;
	$this->sign_key_pass = $key_pass;
  }

  /**
   * Set the private key file and password to sign the message.
   *
   * @access public
   * @param string $key_filename Parameter File Name
   * @param string $key_pass Password for private key
   */
  public function DKIM_QP($txt) {
	$tmp="";
	$line="";
	for ($i=0;$i<strlen($txt);$i++) {
	  $ord=ord($txt[$i]);
	  if ( ((0x21 <= $ord) && ($ord <= 0x3A)) || $ord == 0x3C || ((0x3E <= $ord) && ($ord <= 0x7E)) ) {
		$line.=$txt[$i];
	  } else {
		$line.="=".sprintf("%02X",$ord);
	  }
	}
	return $line;
  }

  /**
   * Generate DKIM signature
   *
   * @access public
   * @param string $s Header
   */
  public function DKIM_sign($s) {
	$privKeyStr = file_get_contents($this->DKIM_private);
	if ($this->DKIM_passphrase!='') {
	  $privKey = openssl_pkey_get_private($privKeyStr,$this->DKIM_passphrase);
	} else {
	  $privKey = $privKeyStr;
	}
	if (openssl_sign($s, $signature, $privKey)) {
	  return base64_encode($signature);
	}
  }

  /**
   * Generate DKIM Canonicalization Header
   *
   * @access public
   * @param string $s Header
   */
  public function DKIM_header_c($s) {
	$s=preg_replace("/\r\n\s+/"," ",$s);
	$lines=explode("\r\n",$s);
	foreach ($lines as $key=>$line) {
	  list($heading,$value)=explode(":",$line,2);
	  $heading=strtolower($heading);
	  $value=preg_replace("/\s+/"," ",$value) ; // Compress useless spaces
	  $lines[$key]=$heading.":".trim($value) ; // Don't forget to remove WSP around the value
	}
	$s=implode("\r\n",$lines);
	return $s;
  }

  /**
   * Generate DKIM Canonicalization Body
   *
   * @access public
   * @param string $body Message Body
   */
  public function DKIM_body_c($body) {
	if ($body == '') return "\r\n";
	// stabilize line endings
	$body=str_replace("\r\n","\n",$body);
	$body=str_replace("\n","\r\n",$body);
	// END stabilize line endings
	while (substr($body,strlen($body)-4,4) == "\r\n\r\n") {
	  $body=substr($body,0,strlen($body)-2);
	}
	return $body;
  }

  /**
   * Create the DKIM header, body, as new header
   *
   * @access public
   * @param string $headers_line Header lines
   * @param string $subject Subject
   * @param string $body Body
   */
  public function DKIM_add($headers_line,$subject,$body) {
	$DKIMsignatureType	  = 'rsa-sha1'; // Signature & hash algorithms
	$DKIMcanonicalization = 'relaxed/simple'; // Canonicalization of header/body
	$DKIMquery			  = 'dns/txt'; // Query method
	$DKIMtime			  = time() ; // Signature Timestamp = seconds since 00:00:00 - Jan 1, 1970 (UTC time zone)
	$subject_header		  = "Subject: $subject";
	$headers			  = explode("\r\n",$headers_line);
	foreach($headers as $header) {
	  if (strpos($header,'From:') === 0) {
		$from_header=$header;
	  } elseif (strpos($header,'To:') === 0) {
		$to_header=$header;
	  }
	}
	$from	  = str_replace('|','=7C',$this->DKIM_QP($from_header));
	$to		  = str_replace('|','=7C',$this->DKIM_QP($to_header));
	$subject  = str_replace('|','=7C',$this->DKIM_QP($subject_header)) ; // Copied header fields (dkim-quoted-printable
	$body	  = $this->DKIM_body_c($body);
	$DKIMlen  = strlen($body) ; // Length of body
	$DKIMb64  = base64_encode(pack("H*", sha1($body))) ; // Base64 of packed binary SHA-1 hash of body
	$ident	  = ($this->DKIM_identity == '')? '' : " i=" . $this->DKIM_identity . ";";
	$dkimhdrs = "DKIM-Signature: v=1; a=" . $DKIMsignatureType . "; q=" . $DKIMquery . "; l=" . $DKIMlen . "; s=" . $this->DKIM_selector . ";\r\n".
				"\tt=" . $DKIMtime . "; c=" . $DKIMcanonicalization . ";\r\n".
				"\th=From:To:Subject;\r\n".
				"\td=" . $this->DKIM_domain . ";" . $ident . "\r\n".
				"\tz=$from\r\n".
				"\t|$to\r\n".
				"\t|$subject;\r\n".
				"\tbh=" . $DKIMb64 . ";\r\n".
				"\tb=";
	$toSign	  = $this->DKIM_header_c($from_header . "\r\n" . $to_header . "\r\n" . $subject_header . "\r\n" . $dkimhdrs);
	$signed	  = $this->DKIM_sign($toSign);
	return "X-PHPMAILER-DKIM: phpmailer.worxware.com\r\n".$dkimhdrs.$signed."\r\n";
  }

  protected function do_callback($isSent,$to,$cc,$bcc,$subject,$body) {
	if (!empty($this->action_function) && function_exists($this->action_function)) {
	  $params = array($isSent,$to,$cc,$bcc,$subject,$body);
	  call_user_func_array($this->action_function,$params);
	}
  }
}

class MailerException extends \Exception {
  public function errorMessage() {
	$errorMsg = '<strong>' . $this->getMessage() . "</strong><br />\n";
	return $errorMsg;
  }
}
?>
MAILER
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_application_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR;
	write($path . 'application.php', sprintf(<<< 'AP'
<?php
/**
 * The Application Module of Pragwork %s
 *
 * @copyright %s
 * @license %s
 * @version %s
 * @package Application
 */


AP
		, PRAGWORK_VERSION, AUTHOR, LICENSE, PRAGWORK_VERSION) 
	. _strip_phpdoc(<<< 'AP'
namespace Application
{	 
	/**
	 * Starts request processing. This function should be used only once as the entry point while starting 
	 * the Pragwork application.
	 *
	 * @author Szymon Wrozynski
	 */
	function start() 
	{	
		$qpos = strpos($_SERVER['REQUEST_URI'], '?');
		
		$config = Configuration::instance();
		$server_path = $config->server_path;
		
		if ($qpos === false)
			$path = $server_path ? substr($_SERVER['REQUEST_URI'], strlen($server_path)) : $_SERVER['REQUEST_URI'];
		elseif (!$server_path) 
			$path = substr($_SERVER['REQUEST_URI'], 0, $qpos);
		else 
		{
			$splen = strlen($server_path);
			$path = substr($_SERVER['REQUEST_URI'], $splen, $qpos - $splen);
		}
		
		$request = Request::instance($path);
		$response = Response::instance();
		
		global $LOCALE, $ROUTES;
		
		$error = null;
		
		$localization = $config->localization;
		
		if ($localization === true)
		{
			if ($path !== '/')
			{
				$second_slash = strpos($path, '/', 1);
				
				$locale_file = $second_slash
					? LOCALES . substr($path, 1, $second_slash - 1) . '.php'
					: LOCALES . substr($path, 1) . '.php';
				
				if (!is_file($locale_file))
					$error = 404;
				else
					require $locale_file;
				
				$path = $second_slash ? substr($path, $second_slash) : '/';
			}
		}
		elseif ($localization)
			require LOCALES . $localization . '.php';
		
		require CONFIG . 'routes.php';
		
		if ($ROUTES)
			$ROUTES[0][0] = '/';
		
		$found = $error;
		$rc = $rc2 = null;
		
		$p_tokens = array(strtok($path, '/.'));
		
		while (($t = strtok('/.')) !== false)
			$p_tokens[] = $t;
			
		foreach ($ROUTES as $n => $r) 
		{	
			$rc[$r['controller']][$r['action']] = $rc2["{$r['controller']}\\{$r['action']}"] = $n;
			
			if ($found)
			{
				$t = strtok($r[0], '/.');

				if (($t !== false) && $t[0] === ':')
					$ROUTES[$n]['pp'][] = substr($t, 1);

				while (($t = strtok('/.')) !== false)
				{
					if ($t[0] === ':')
						$ROUTES[$n]['pp'][] = substr($t, 1);
				}
				continue;
			}
			else
			{
				$match = true;
				$t = strtok($r[0], '/.');

				if (($t !== false) && $t[0] === ':')
				{
					$pp = substr($t, 1);
					$ROUTES[$n]['pp'][] = $pp;
					$request->path_parameters[$pp] = $p_tokens[0];
				}
				elseif ($t !== $p_tokens[0])
					$match = false;

				$i = 0;
				while (($t = strtok('/.')) !== false)
				{
					if ($t[0] === ':')
					{
						$pp = substr($t, 1);
						$ROUTES[$n]['pp'][] = $pp;
						
						if (isset($p_tokens[++$i]))
							$request->path_parameters[$pp] = $p_tokens[$i];
						else
							$match = false;
					}
					elseif (!isset($p_tokens[++$i]) || ($t !== $p_tokens[$i]))
						$match = false;
				}
				if (!$match || isset($p_tokens[++$i]))
				{
					$request->path_parameters = array();
					continue;
				}
			}	
			
			if (strpos($r['methods'], $_SERVER['REQUEST_METHOD']) === false)
			{
				$error = 405;
				continue;
			}
			
			if (isset($r['ssl']) && $r['ssl'] && ($_SERVER['SERVER_PORT'] != ($config->ssl_port ?: 443)))
			{
				if ($_SERVER['REQUEST_METHOD'] === 'GET')
				{
					$error = 301;
					$response->location = $config->ssl_url() . ($server_path 
						? substr($_SERVER['REQUEST_URI'], strlen($server_path))
						: $_SERVER['REQUEST_URI']);
					break;
				}
				$error = 403;
				continue;
			}
				
			$found = $r;
		}
		
		$ROUTES['__RC'] =& $rc;
		$ROUTES['__RC2'] =& $rc2;

		if ($found && ($found !== $error))
		{
			$request->route =& $found;
			$controller_name = "Controllers\\{$found['controller']}Controller";
			$controller = $controller_name::instance();
			$controller->process($request, $response);
		}
		else
			$response->status = $error ?: 404;
		
		$response->render();
	}
}

namespace
{
	/**
	 * Absolute path to the application directory. 
	 *
	 * @internal
	 */
	define('APPLICATION', dirname(__DIR__));
	
	/**
	 * Absolute path to the modules directory. 
	 *
	 * @internal
	 */
	define('MODULES', APPLICATION . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to the configuration directory. 
	 *
	 * @internal
	 */
	define('CONFIG', APPLICATION . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to the user application code.
	 *
	 * @internal
	 */
	define('APP', APPLICATION . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to helpers directory.
	 *
	 * @internal
	 */
	define('HELPERS', APPLICATION . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'helpers' .DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to views directory.
	 *
	 * @internal
	 */
	define('VIEWS', APPLICATION . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR .'views'. DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to locales directory.
	 *
	 * @internal
	 */
	define('LOCALES', APPLICATION . DIRECTORY_SEPARATOR . 'locales' . DIRECTORY_SEPARATOR);
	
	/**
	 * Absolute path to the directory for temporary files.
	 *
	 * @internal
	 */
	define('TEMP', APPLICATION . DIRECTORY_SEPARATOR . 'temp' . DIRECTORY_SEPARATOR);
	
	/**
	 * Adds the internal class loader to the class loaders chain. The class loader searches classes in the 
	 * 'app' directory. 
	 *
	 * The provided class name should not start with a backslash <code>\</code> character. 
	 * Notice, PHP strips the leading backslashes automatically even if you provide it in the code:
	 * 
	 * <code>
	 * $bar = new \Foo\Bar;
	 * # it passes 'Foo\Bar' string to the class loader if class has not been
	 * # loaded yet
	 * </code>
	 *
	 * However, a user may provide a leading backslash accidentally while dealing with classes loaded from strings:
	 *
	 * <code>
	 * $class_name = '\Foo\Bar'; # WRONG!
	 * $bar = new $class_name;
	 *
	 * $class_name = 'Foo\Bar';	 # CORRECT
	 * $bar = new $class_name;	 # It is an equivalent of: $bar = new \Foo\Bar;
	 * </code>
	 *
	 * Remember, namespaces in strings are always regarded as absolute ones.
	 */
	spl_autoload_register(function($class)
	{
		$file = APP . str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
		
		if (is_file($file))
			require $file;
		elseif (strpos($class, 'Application\\') === 0)
			require MODULES . str_replace('\\', DIRECTORY_SEPARATOR, $class) . '.php';
	});
	
	set_error_handler(function($errno, $errstr, $errfile, $errline)
	{
		throw new ErrorException($errstr, 0, $errno, $errfile, $errline);
	});
	
	require CONFIG . 'application.php';
	
	/**
	 * Constructs URL based on the route name or an action (or a controller) passed as $options. 
	 * The routes are defined in the application configuration directory ('routes.php').
	 *
	 * The following options are available:
	 *
	 * <ul>
	 * <li><b>name</b>: explicit name of the route
	 * <li><b>action</b>: name of the action</li>
	 * <li><b>controller</b>: name of the controller</li>
	 * <li><b>ssl</b>: value must be a bool</li>
	 * <li><b>anchor</b>: anchor part of the URL</li>
	 * <li><b>params</b>: array of parameters or a model</li>
	 * <li><b>locale</b>: custom locale code</li>
	 * </ul>
	 *
	 * <h4>1. URL for a specified route</h4>
	 *
	 * <code>
	 * url_for(array('name' => 'help'));
	 * </code> 
	 *
	 * Returns a URL for the route named <code>help</code>.
	 *
	 * <h4>2. URL for the action and the controller</h4>
	 * 
	 * <code>
	 * url_for();
	 * </code>
	 *
	 * Returns a URL for the current action of the current controller. If the action or controller is not given 
	 * the current one is used instead. If there is no controller at all (e.g. inside error templates) the root
	 * controller is assumed.
	 *
	 * <code>
	 * url_for('/');
	 * </code>
	 *
	 * Returns a URL to the root route of the application (<code>/</code>). The root route is always the first 
	 * entry (0th index) in the <code>$ROUTES</code> array.
	 *
	 * <code>
	 * url_for('index'); 
	 * url_for(array('index'));
	 * url_for(array('action' => 'index'));
	 * </code>
	 *
	 * Returns the URL for the <code>index</code> action of the current controller.
	 *
	 * <code>
	 * url_for('Shop\index');
	 * url_for(array('Shop\index'));
	 * url_for(array('action' => 'index', 'controller' => 'Shop'));
	 * </code>
	 * 
	 * Returns the URL for the <code>index</code> action of the <code>Shop</code> controller. 
	 * The controllers should be specified with the enclosing namespace (if any), 
	 * e.g. <code>Admin\Configuration</code> - for the controller with the full name:
	 * <code>\Controllers\Admin\ConfigurationController</code>.
	 *
	 * <h4>3. Static assets</h4>
	 *
	 * If the string (2 characters length min.) starting with a slash <code>/</code> is passed as 
	 * <code>$options</code> or the first (0th index) element of the options array then it is treated 
	 * as a URI path to a static asset. This feature is used by special assets tags in the <code>Tags</code>
	 * module, therefore rarely there is a need to explicit use it.
	 *
	 * <code>
	 * url_for('/img/foo.png');
	 * url_for($this->request->uri());
	 * </code>
	 *
	 * <h4>4. SSL</h4>
	 *
	 * <code> 
	 * url_for(array('index', 'ssl' => true));
	 * url_for(array('name' => 'help', 'ssl' => false));
	 * </code>
	 *
	 * Returns the URL with the secure protocol or not. If the <code>ssl</code> option is omitted the default 
	 * SSL setting is used (from the corresponding entry in the 'routes.php' configuration file). 
	 * The HTTP and HTTPS protocols use the ports defined in the {@link Configuration} instance. By default
	 * they are set to 80 (HTTP) and and 443 (HTTPS).
	 *
	 * <h4>5. Anchor</h4>
	 * 
	 * <code>
	 * url_for(array('index', 'anchor' => 'foo'));
	 * </code>
	 *
	 * Generates the URL with the anchor <code>foo</code>, for example: 'http://www.mydomain.com/index#foo'.
	 *
	 * <h4>6. Parameters</h4>
	 *
	 * Parameters are passed an an option named <code>params</code>. There are two kind of parameters 
	 * in the URL: path parameters and query parameters. Path parameters are used to compose the URI path, 
	 * and query parameters are used to create the query appended to the URL. Usually, parameters are passed 
	 * as an array where the keys are parameter names. However, path parameters can be passed without keys at all. 
	 * In such case, they are taken first depending on their order. Path parameters always have higher priority 
	 * than query parameters, and keyless path parameters have higher priority than others.
	 *
	 * If there is only one keyless parameter, the array may be omitted.
	 *
	 * Consider the simplest example:
	 *
	 * <code>
	 * url_for(array('show', 'params' => array(
	 *	   'id' => 12, 
	 *	   'size' => 25, 
	 *	   'color' => 'blue'
	 * )));
	 * </code>
	 * 
	 * The result could be (assuming the according route is e.g. <code>'/items/:id'</code>):
	 * <code>'http://www.mydomain.com/items/12?size=25&color=blue'</code>.
	 * 
	 * But you can also write it in a short manner, using the 0th array element:
	 * 
	 * <code>
	 * url_for(array('show', 'params' => array(12,'size'=>25,'color'=>'blue')));
	 * </code>
	 *
	 * Also, if there had not been other parameters than the path one, you would have written it even shorter:
	 * 
	 * <code>
	 * url_for(array('show', 'params' => 12));
	 * </code>
	 *
	 * <h4>7. Locale</h4>
	 * 
	 * If the localization is set to <code>true</code> this option affects the locale code used to construct the URL. 
	 * It could be useful e.g. to provide language choice options. Notice, if the localization is set 
	 * to <code>true</code> the root action omits the autoloading of the locale and thus the locale remains undefined
	 * (unloaded). In such case, in the root action, you have to specify the locale manually or you will get an error.
	 *
	 * @see Controller
	 * @see Configuration
	 * @param mixed $options Array of options
	 * @return string URL generated from given $options
	 * @author Szymon Wrozynski
	 */
	function url_for($options=array())
	{
		if ((array) $options !== $options)
			$options = array($options);
		
		global $ROUTES, $LOCALE;
		
		static $duo, $controller, $action, $http_url, $ssl_url, $ssl_port, $localization;
		
		if (!isset($duo))
		{	
			$c = Application\Controller::instance();
			
			if ($c)
			{
				$duo = $c->default_url_options() ?: false;
				$controller = $c->controller;
				$action = $c->action;
			}
			else
			{
				$duo = false;
				$controller = $ROUTES[0]['controller'];
				$action = $ROUTES[0]['action'];
			}
			
			$config = Application\Configuration::instance();
			$http_url = $config->http_url();
			$ssl_url = $config->ssl_url();
			$ssl_port = $config->ssl_port;
			$localization = $config->localization;
		}
		
		if ($duo)
		{
			if (isset($duo['params'], $options['params']))
				$options['params'] = array_merge(
					((array) $duo['params'] === $duo['params'])
						? $duo['params'] : array($duo['params']),
					((array) $options['params'] === $options['params'])
						? $options['params'] : array($options['params'])
				);
			
			$options = array_merge($duo, $options);
		}
		
		if (isset($options[0][0]))
		{
			if ($options[0] === '/')
				$name = 0;
			elseif ($options[0][0] === '/')
			{
				if (isset($options['ssl']))
					return ($options['ssl'] ? $ssl_url : $http_url) . $options[0];
				else
					return (($_SERVER['SERVER_PORT'] == ($ssl_port ?: 443)) ? $ssl_url : $http_url) . $options[0];		
			}
			elseif (strpos($options[0], '\\') > 0)
				$name = $ROUTES['__RC2'][$options[0]];
			else
				$name = $ROUTES['__RC'][$controller][$options[0]];
		}
		elseif (isset($options['name']))
			$name = $options['name'];
		else
			$name = $ROUTES['__RC'][isset($options['controller']) ? $options['controller'] : $controller]
				[isset($options['action']) ? $options['action'] : $action];
		
		if ($localization === true)
		{
			$uri = '/' . (isset($options['locale']) ? $options['locale'] : $LOCALE[0]);
			
			if ($ROUTES[$name][0] !== '/')
				$uri .= $ROUTES[$name][0];
		}
		else
			$uri = $ROUTES[$name][0];
		
		if (isset($options['anchor']))
			$uri .= '#' . $options['anchor'];
		
		if (isset($options['params']))
		{
			$params = $options['params'];
			
			if (isset($ROUTES[$name]['pp']))
			{
				if ((array) $params !== $params)
				{
					$uri = str_replace(':' . $ROUTES[$name]['pp'][0], $params, $uri);
					$params = null;
				}	 
				else
				{
					foreach ($ROUTES[$name]['pp'] as $i => $pp)
					{
						if (isset($params[$i]))
						{
							$uri = str_replace(":$pp", $params[$i], $uri);
							unset($params[$i]);
						}
						elseif (isset($params[$pp]))
						{
							$uri = str_replace(":$pp", $params[$pp], $uri);
							unset($params[$pp]);
						}
					}
				}
			}
			
			if ($params)
				$uri .= '?' . http_build_query($params);
		}
		
		if (isset($options['ssl']))
			return ($options['ssl'] ? $ssl_url : $http_url) . $uri;
		elseif (isset($ROUTES[$name]['ssl']))
			return ($ROUTES[$name]['ssl'] ? $ssl_url : $http_url) . $uri;
		
		return $http_url . $uri;
	}
	
	/**
	 * Loads the modules listed in the argument list.
	 *
	 * <code>
	 * modules('tags', 'activerecord');
	 * </code>
	 *
	 * @param string ... Variable-length list of module names
	 * @author Szymon Wrozynski
	 */
	function modules(/*...*/)
	{
		foreach (func_get_args() as $m)
			require_once MODULES . $m . '.php';
	}
	
	/**
	 * Translates the given key according to the current locale loaded.
	 *
	 * If the translation was not found the given key is returned back. The key can be a string but it is strongly
	 * advised not to use the escape characters like <code>\</code> inside though it is technically possible. 
	 * Instead, use double quotes to enclose single quotes and vice versa. This will help the <b>Prag</b> tool to
	 * recognize such keys and maintain locale files correctly. Otherwise, you will have to handle such keys by hand.
	 * The same applies to compound keys evaluated dynamically.
	 *
	 * <code>
	 * t('Editor\'s Choice');	# Avoid!
	 * t($editor_msg);			# Avoid!
	 * t("Editor's Choice");	# OK
	 * </code>
	 *
	 * Pragwork requires the first entry (0th index) in the locale file array contains the locale code therefore, 
	 * by specifying <code>t(0)</code> or just <code>t()</code>, the current locale code is returned.
	 * Also, if there is no locale loaded yet this will return 0 (the passed or implied locale key). 
	 * Such test against 0 (int) might be helpful while translating and customizing error pages, where there is no
	 * certainty that the locale code was parsed correctly (e.g. a 404 error).
	 *
	 * @param mixed $key Key to translation (string) or 0 (default)
	 * @return string Localized text or the locale code (if 0 passed)
	 * @author Szymon Wrozynski
	 */
	function t($key=0)
	{
		global $LOCALE;
		return isset($LOCALE[$key]) ? $LOCALE[$key] : $key;
	}
	
	/**
	 * Returns the array of strings with available locale codes based on filenames found in the 'locales' directory.
	 * Filenames starting with a dot '.' are omitted.
	 *
	 * @return array Available locale codes as strings in alphabetical order
	 * @author Szymon Wrozynski
	 */
	function locales()
	{
		static $locales;
		
		if (isset($locales))
			return $locales;
		
		$locales = array();
		$handler = opendir(LOCALES);
		
		while (false !== ($file = readdir($handler)))
		{
			if ($file[0] !== '.')
				$locales[] = substr($file, 0, -4);
		}
		
		closedir($handler);
		
		sort($locales);
		return $locales;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	$path .= 'Application';
	
	if (is_dir($path))
		rmtree($path);
	
	mkdir($path, 0755);
	
	$path .= DIRECTORY_SEPARATOR;
	
	write($path . 'ModuleConfiguration.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The base class for module configuration objects. It provides a unique way of managing different environments.
 * Configuration entries are set (and get) as virtual properties. The properties might be appended directly 
 * to the current environment:
 *
 * <code>
 * $config->foo = 'foo';
 * </code>
 *
 * or (within an array) to many environments at once:
 *
 * <code>
 * $config->foo = array(
 *     'development' => 'foo_dev',
 *     'test' => 'foo_test',
 *     'production' => 'foo_production'
 * );
 * </code>
 *
 * The special virtual property is named <code>environment</code>. It is used to set the current environment. 
 * By default it is set to 'development'.
 *
 * The environment named 'test' is required by integrated <code>Test</code> module. 
 * And the environment having 'production' in its name is recognized as the final production stage. 
 * Notice, it does not have to equal to 'production' exactly. It might be 'en_production' as well. 
 * In that way you may have many production environments. This is helpful with some localization strategies.
 *
 * @author Szymon Wrozynski
 * @package Application
 */
abstract class ModuleConfiguration extends Singleton
{
	protected static $defaults = array();
	protected static $env = 'development';
	protected $env_vars;
	
	protected function __construct()
	{
		$this->env_vars[self::$env] = static::$defaults;
	}
	
	/**
	 * Allows configuration initialization using a closure.
	 *
	 * <code>
	 * Configuration::initialize(new function($config)
	 * {
	 *     $config->foo = 'foo';
	 *
	 *     $config->bar = array(
	 *         'development' => 'bar_dev',
	 *         'test' => 'bar_test',
	 *         'production' => 'bar_production'
	 *     );
	 * });
	 * </code>
	 *
	 * @param \Closure $initializer A closure
	 */
	public static function initialize($initializer)
	{
		$initializer(parent::instance());
	}
	
	/**
	 * If the <code>$name</code> equals to 'environment' the <code>$value</code> is used as the environment
	 * name. Otherwise it sets the configuration entry for the current environment or (in the <code>$value</code> 
	 * is an array), for many environments at once.
	 *
	 * @param string $name The property name
	 * @param mixed $value The property value
	 */
	public function __set($name, $value)
	{
		if ($name === 'environment')
		{
			self::$env = $value;
			if (!isset($this->env_vars[$value]))
				$this->env_vars[$value] = static::$defaults;
		}
		elseif ((array) $value === $value)
		{	
			foreach ($value as $env => $val)
			{
				if (!isset($this->env_vars[$env]))
					$this->env_vars[$env] = static::$defaults;
				
				$this->env_vars[$env][$name] = $val;
			}
		}
		else
			$this->env_vars[self::$env][$name] = $value;
	}
	
	/**
	 * If the <code>$name</code> equals to 'environment' the current environment name is returned. 
	 * Otherwise it returns the configuration variable value for the current environment.
	 *
	 * @param string $name The property name
	 * @return mixed The environment name or configuration variable value
	 */
	public function __get($name)
	{
		return ($name === 'environment') ? self::$env : $this->env_vars[self::$env][$name];
	}
	
	/**
	 * Returns an array containing the selected property values in all available environments.
	 * 
	 * <code>
	 * $config->all_for('foo');
	 * # returns:
	 * # array(3) {
	 * #   ["development"]=>
	 * #   string(7) "bar_dev"
	 * #   ["test"]=>
	 * #   string(8) "bar_test"
	 * #   ["production"]=>
	 * #   string(14) "bar_production"
	 * # }
	 * </code>
	 *
	 * @param string $name The property name
	 * @return array Property values in all available environments
	 */
	public function all_for($name)
	{
		$result = array();
		
		foreach ($this->env_vars as $env => $data)
		{
			if (array_key_exists($name, $data))
				$result[$env] = $data[$name];
		}
		
		return $result;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Configuration.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The Application module configuration class.
 *
 * Contains several properties:
 * 
 * <ul>
 * <li><b>server_path</b>: The optional server path, i.e. the part of the URL appended to the domain name. 
 *     E.g. a server directory.</li>
 * <li><b>http_port</b>: The optional number of the server port for the HTTP protocol. If null (default) the 80 
 *     is used.</li>
 * <li><b>ssl_port</b>: The optional number of the server port for the HTTPS protocol. If null (default) the 443 
 *     is used.</li>
 * <li><b>images_path</b>: The path to the images assets. May be relative and points to the current server or absolute 
 *     (with http://) and points to any server on the net. By default: '/images'.</li>
 * <li><b>javascripts_path</b>: The path to the javascript assets. May be relative and points to the current server 
 *     or absolute (with http://) and points to any server on the net. By default: '/javascripts'.</li>
 * <li><b>stylesheets_path</b>: The path to the css stylesheets. May be relative and points to the current server 
 *     or absolute (with http://) and points to any server on the net. By default: '/stylesheets'.</li>
 * <li><b>localization</b>: Turns on/off (true/false) the localization or explicitly lock it to the chosen one 
 *     (string).</li>
 * <li><b>session</b>: Turns on/off (true/false) the session or explicitly sets it on, along with the given name
 *     (string).</li>
 * <li><b>cache</b>: Enables/disables (true/false) caching features.</li>
 * </ul>
 *
 * Notice, all paths should NOT end with a separator (a slash <code>/</code>).
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Configuration extends ModuleConfiguration
{	
	protected static $instance;
	
	protected static $defaults = array(
		'server_path' => null,
		'http_port' => null,
		'ssl_port' => null,
		'images_path' => '/images',
		'javascripts_path' => '/javascripts',
		'stylesheets_path' => '/stylesheets',
		'localization' => false,
		'session' => true,
		'cache' => false
	);
	
	/**
	 * Return an HTTP URL part based on configuration properties used to construct URLs.
	 *
	 * @return string
	 */
	public function http_url()
	{
		return $this->env_vars[self::$env]['http_port']
			? 'http://' . $_SERVER['SERVER_NAME'] . ':' . $this->env_vars[self::$env]['http_port'] . $this->server_path
			: 'http://' . $_SERVER['SERVER_NAME'] . $this->server_path;
	}
	
	/**
	 * Return an HTTPS URL part based on configuration properties used to construct URLs.
	 *
	 * @return string
	 */
	public function ssl_url()
	{
		return $this->env_vars[self::$env]['ssl_port']
			? 'https://' . $_SERVER['SERVER_NAME'] . ':' . $this->env_vars[self::$env]['ssl_port'] . $this->server_path
			: 'https://' . $_SERVER['SERVER_NAME'] . $this->server_path;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
		
	write($path . 'Response.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * Contains information about the response being generated (headers, status, body).
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Response extends Singleton
{
	protected static $http_codes_by_symbol = array(
		'continue' => 100,
		'switching_protocols' => 101,
		'processing' => 102, 
		'ok' => 200, 
		'created' => 201, 
		'accepted' => 202, 
		'non_authoritative_information' => 203, 
		'no_content' => 204, 
		'reset_content' => 205, 
		'partial_content' => 206, 
		'multi_status' => 207, 
		'im_used' => 226, 
		'multiple_choices' => 300, 
		'moved_permanently' => 301, 
		'found' => 302, 
		'see_other' => 303, 
		'not_modified' => 304, 
		'use_proxy' => 305, 
		'temporary_redirect' => 307, 
		'bad_request' => 400, 
		'unauthorized' => 401, 
		'payment_required' => 402, 
		'forbidden' => 403, 
		'not_found' => 404, 
		'method_not_allowed' => 405, 
		'not_acceptable' => 406, 
		'proxy_authentication_required' => 407, 
		'request_timeout' => 408, 
		'conflict' => 409, 
		'gone' => 410, 
		'length_required' => 411, 
		'precondition_failed' => 412, 
		'request_entity_too_large' => 413, 
		'request_uri_too_long' => 414, 
		'unsupported_media_type' => 415, 
		'requested_range_not_satisfiable' => 416, 
		'expectation_failed' => 417, 
		'unprocessable_entity' => 422, 
		'locked' => 423, 
		'failed_dependency' => 424, 
		'upgrade_required' => 426, 
		'internal_server_error' => 500, 
		'not_implemented' => 501, 
		'bad_gateway' => 502, 
		'service_unavailable' => 503, 
		'gateway_timeout' => 504, 
		'http_version_not_supported' => 505, 
		'insufficient_storage' => 507, 
		'not_extended' => 510, 
	);
	
	protected static $http_codes = array(
		100 => 'Continue', 
		101 => 'Switching Protocols', 
		102 => 'Processing', 
		200 => 'OK', 
		201 => 'Created', 
		202 => 'Accepted', 
		203 => 'Non-Authoritative Information', 
		204 => 'No Content', 
		205 => 'Reset Content', 
		206 => 'Partial Content', 
		207 => 'Multi-Status', 
		226 => 'IM Used', 
		300 => 'Multiple Choices', 
		301 => 'Moved Permanently', 
		302 => 'Found', 
		303 => 'See Other', 
		304 => 'Not Modified', 
		305 => 'Use Proxy', 
		307 => 'Temporary Redirect', 
		400 => 'Bad Request', 
		401 => 'Unauthorized', 
		402 => 'Payment Required', 
		403 => 'Forbidden', 
		404 => 'Not Found', 
		405 => 'Method Not Allowed', 
		406 => 'Not Acceptable', 
		407 => 'Proxy Authentication Required', 
		408 => 'Request Timeout', 
		409 => 'Conflict', 
		410 => 'Gone', 
		411 => 'Length Required', 
		412 => 'Precondition Failed', 
		413 => 'Request Entity Too Large', 
		414 => 'Request-URI Too Long', 
		415 => 'Unsupported Media Type', 
		416 => 'Requested Range Not Satisfiable', 
		417 => 'Expectation Failed', 
		422 => 'Unprocessable Entity', 
		423 => 'Locked', 
		424 => 'Failed Dependency', 
		426 => 'Upgrade Required', 
		500 => 'Internal Server Error', 
		501 => 'Not Implemented', 
		502 => 'Bad Gateway', 
		503 => 'Service Unavailable', 
		504 => 'Gateway Timeout', 
		505 => 'HTTP Version Not Supported', 
		507 => 'Insufficient Storage', 
		510 => 'Not Extended', 
	);
	
	/**
	 * The status code of the response. The available statuses are:
	 *
	 * <ul>
	 * <li>continue (100)</li>
	 * <li>switching_protocols (101)</li>
	 * <li>processing (102)</li> 
	 * <li>ok (200)</li> 
	 * <li>created (201)</li> 
	 * <li>accepted (202)</li> 
	 * <li>non_authoritative_information (203)</li> 
	 * <li>no_content (204)</li> 
	 * <li>reset_content (205)</li> 
	 * <li>partial_content (206)</li> 
	 * <li>multi_status (207)</li> 
	 * <li>im_used (226)</li> 
	 * <li>multiple_choices (300)</li> 
	 * <li>moved_permanently (301)</li> 
	 * <li>found (302)</li> 
	 * <li>see_other (303)</li> 
	 * <li>not_modified (304)</li> 
	 * <li>use_proxy (305)</li> 
	 * <li>temporary_redirect (307)</li> 
	 * <li>bad_request (400)</li> 
	 * <li>unauthorized (401)</li> 
	 * <li>payment_required (402)</li> 
	 * <li>forbidden (403)</li> 
	 * <li>not_found (404)</li> 
	 * <li>method_not_allowed (405)</li> 
	 * <li>not_acceptable (406)</li> 
	 * <li>proxy_authentication_required (407)</li> 
	 * <li>request_timeout (408)</li> 
	 * <li>conflict (409)</li> 
	 * <li>gone (410)</li> 
	 * <li>length_required (411)</li> 
	 * <li>precondition_failed (412)</li> 
	 * <li>request_entity_too_large (413)</li> 
	 * <li>request_uri_too_long (414)</li> 
	 * <li>unsupported_media_type (415)</li> 
	 * <li>requested_range_not_satisfiable (416)</li> 
	 * <li>expectation_failed (417)</li> 
	 * <li>unprocessable_entity (422)</li> 
	 * <li>locked (423)</li> 
	 * <li>failed_dependency (424)</li> 
	 * <li>upgrade_required (426)</li> 
	 * <li>internal_server_error (500)</li> 
	 * <li>not_implemented (501)</li> 
	 * <li>bad_gateway (502)</li> 
	 * <li>service_unavailable (503)</li> 
	 * <li>gateway_timeout (504)</li> 
	 * <li>http_version_not_supported (505)</li> 
	 * <li>insufficient_storage (507)</li> 
	 * <li>not_extended (510)</li>
	 * </ul>
	 *
	 * @var mixed Int or symbolic string
	 */
	public $status = 200;
	
	/**
	 * The content type of the response.
	 *
	 * @var string
	 */
	public $content_type = 'text/html';
	
	/**
	 * The charset of the content (default utf-8);
	 *
	 * @var string
	 */
	public $charset = 'utf-8';
	
	/**
	 * The string containg the output rendered while performing an action.
	 *
	 * @var mixed String or null
	 */
	public $body;
	
	/**
	 * The URL of the redirection (if any).
	 *
	 * @var mixed String or null
	 */
	public $location;
	
	/**
	 * The exception occured (if any).
	 *
	 * @var \Exception
	 */
	public $exception;
	
	protected static $instance;
	protected $headers = array();
	
	/**
	 * Renders the generated response (sends headers and print out the body or an error template).
	 */
	public function render()
	{
		if ((string) $this->status === $this->status)
			$this->status = self::$http_codes_by_symbol[$this->status];
		
		header(((strpos(PHP_SAPI, 'cgi') === 0) ? 'Status: ' : 'HTTP/1.1 ') 
			. $this->status . ' ' . self::$http_codes[$this->status]);
		
		if (($this->status > 300) && ($this->status < 400))
		{
			header("Location: $this->location");
			return;
		}
		elseif (($this->status >= 400) && ($this->status < 500) && !$this->body)
		{
			$file = APPLICATION . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR . $this->status . '.php';
			
			if (is_file($file))
			{
				ob_start();
				require $file;
				$this->body = ob_get_clean();
			}
		}
		elseif ($this->status >= 500)
			$this->body = $this->error_500();
		
		foreach ($this->headers as $h)
			header($h, false);
		
		$ctype = "Content-Type: $this->content_type";
		
		if ($this->charset)
			$ctype .= "; charset=$this->charset";
		
		header($ctype);
		
		echo $this->body;
	}
	
	/**
	 * Returns the full HTTP status string of the current response.
	 *
	 * @return string
	 */
	public function full_status()
	{
		return self::resolve_full_status($this->status);
	}
	
	/**
	 * Returns the code (<code>int</code>) of the HTTP status of the current response.
	 *
	 * @return int
	 */
	public function status_code()
	{
		return ((string) $this->status === $this->status) 
			? self::$http_codes_by_symbol[$this->status] : $this->status;
	}
	
	/**
	 * Returns the full HTTP status string basing on passed status.
	 *
	 * @see $status
	 * @params mixed $status Symbolic string or int
	 * @return string The full HTTP status string
	 */
	public static function resolve_full_status($status)
	{
		if ((string) $status === $status)
			$status = self::$http_codes_by_symbol[$status];
		
		return $status . ' ' . self::$http_codes[$status];
	}
	
	/**
	 * Adds a raw HTTP header to send (just like the <code>header()</code> function).
	 *
	 * @param string $string The header string
	 * @param bool $replace If true replaces the previously added similar 
	 *	   headers with the current one instead of appending.
	 * @params mixed $status Optional HTTP status
	 */
	public function add_header($string, $replace=true, $status=null)
	{
		if ($status)
			$this->status = $status;
		
		if ($replace)
			$this->remove_header(substr($string, strpos($string, ':')));
		
		$this->headers[] = $string;
	}
	
	/**
	 * Removes similar headers (they will not be sent).
	 *
	 * @param string $name The header name
	 */
	public function remove_header($name)
	{
		foreach ($this->headers as &$h)
		{
			if ($name === substr($h, 0, strpos($h, ':')))
				unset($h);
		}
		header_remove($name);
	}
	
	/**
	 * Returns the list of headers ready to sending.
	 *
	 * @return array
	 */
	public function headers_list()
	{
		return array_merge(headers_list(), $this->headers);
	}
	
	protected function error_500()
	{
		$e = $this->exception;
		$date = "Date/Time: " . date('Y-m-d H:i:s');
		
		if (strpos(Configuration::instance()->environment, 'production') !== false) 
		{
			error_log(get_class($e) . ': ' . $e->getMessage() . ' at line ' . $e->getLine() 
				. ' in file ' . $e->getFile() . PHP_EOL . $date . PHP_EOL . 'Stack trace:' . PHP_EOL
				. $e->getTraceAsString() . PHP_EOL . '------------------------------' . PHP_EOL,
				3, TEMP . 'errors.log');
			ob_start();
			require APPLICATION . DIRECTORY_SEPARATOR . 'errors' . DIRECTORY_SEPARATOR . '500.php';
			return ob_get_clean();
		}
		
		$result = '<p>' . get_class($e) . ': <b>' . $e->getMessage() . '</b> at line ' 
			. $e->getLine() . ' in file ' . $e->getFile() . '. ' . $date . '</p>';
			
		$app_path_cut_point = strlen(realpath(APPLICATION)) + 1;
			
		$trace = $e->getTrace();
		array_pop($trace); # remove the last entry (public/index.php)
		
		$traces = '';
		
		foreach ($trace as $entry)
		{
			# ignore if the entry neither has 'file' nor 'line' keys
			if (!isset($entry['file'], $entry['line']))
				continue;
				
			$file = substr($entry['file'], $app_path_cut_point);
				
			# omit the modules
			if (strpos($file, 'modules') === 0)
				continue;
				
			$traces .= '<li><b>' . $file . ':' . $entry['line'] . '</b> &mdash; ';
					
			if (isset($entry['class']) && $entry['class'])
				$traces .= 'method: <i>' . $entry['class'] . $entry['type'];
			else
				$traces .= 'function: <i>';
					
			$traces .= $entry['function'] . '(' . implode(', ', array_map(function($a) {
				if (($a === null) || ((bool) $a === $a))
					return gettype($a);
				elseif ((object) $a === $a)
					return get_class($a);
				elseif ((string) $a === $a)
					return "'$a'";
				else
					return strval($a);
				}, $entry['args'])) . ')</i></li>';
		}
		
		if ($traces)
			$result .= "<p>Local trace:<ol>$traces</ol></p>";
		
		return $result;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'StopException.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * An exception throwing to stop the action processing. Throw it instead of 
 * calling <code>die()</code> or <code>exit()</code> functions.
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class StopException extends \Exception {}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Singleton.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The singleton pattern implementation based on the late static binding.
 * Requires a protected static variable named <code>$instance</code> to be 
 * declared at the appropriate level of the inheritance hierarchy.
 *
 * @author Szymon Wrozynski
 * @package Application
 */
abstract class Singleton
{	
	protected function __construct() {}
	
	/**
	 * Returns the instance of the descendant or creates a new one.
	 * 
	 * @return Singleton
	 */
	public static function &instance()
	{
		if (!static::$instance)
		{
			$class = get_called_class();
			static::$instance = new $class;
		}
		
		return static::$instance;
	}
	
	private final function __clone() {}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);

	write($path . 'Store.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The abstract class providing common mechanics for {@link Session},
 * {@link Parameters}, {@link Cookies}, and {@link Flash} classes. 
 *
 * @author Szymon Wrozynski
 * @package Application
 */
abstract class Store extends Singleton implements \IteratorAggregate
{
	protected $store;
	
	protected function __construct(array &$store)
	{
		$this->store =& $store;
	}
			
	/**
	 * Sets a new variable in the store.
	 *
	 * @param string $name Name of the variable
	 * @param mixed $value Variable value
	 */
	public function __set($name, $value)
	{
		$this->store[$name] = $value;
	}

	/**
	 * Gets a variable from the store.
	 *
	 * @param string $name Name of the variable
	 * @return mixed Variable value or null
	 */
	public function &__get($name)
	{
		$value = null;
		
		if (isset($this->store[$name]))
			$value =& $this->store[$name];
		
		return $value;
	}
	
	/**
	 * Checks if a variable is present in the store.
	 *
	 * @param string $name Name of the variable
	 * @return bool True if the variable exists, false otherwise
	 */
	public function __isset($name)
	{
		return isset($this->store[$name]);
	}
	
	/**
	 * Removes the variable if present.
	 *
	 * @param string $name Name of the variable
	 */
	public function __unset($name)
	{
		unset($this->store[$name]);
	}

	/**
	 * Returns an iterator to stored variables. This will allow to iterate
	 * over using <code>foreach</code>. 
	 *
	 * @return \ArrayIterator
	 */
	public function getIterator()
	{
		return new \ArrayIterator($this->store);
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Flash.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The class for reading and writing message stored in the session. Once read they are discarded upon the next request. 
 *
 * This class requires session to be enabled.
 * 
 * Examples:
 *
 * <code>
 * $this->flash->notice = 'This is a notice.'; # saves the message
 * </code>
 *
 * <code>
 * echo $this->flash->notice; # gets the message - now it is marked as read
 * </code>
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Flash extends Store
{	
	protected static $instance;
	
	protected function __construct($session)
	{		 
		if ($session->__PRAGWORK_FLASH_STORAGE)
		{
			foreach ($session->__PRAGWORK_FLASH_STORAGE as $name => $msg) 
			{
				if ($msg[1])
					unset($session->__PRAGWORK_FLASH_STORAGE[$name]);
			}
		}
		else
			$session->__PRAGWORK_FLASH_STORAGE = array();
		
		parent::__construct($session->__PRAGWORK_FLASH_STORAGE);
	}
	
	/**
	 * Returns the {@link Flash} instance only if the sessions are available (see {@link Configuration}).
	 * Otherwise returns <code>null</code>.
	 * 
	 * @return Flash
	 */
	public static function &instance()
	{
		if (!static::$instance)
		{
			$session = Session::instance();
			if ($session)
				static::$instance = new Flash($session);
		}
		
		return static::$instance;
	}
	
	/**
	 * Writes the instant message stored in the session. It requires a session to be enabled.
	 *
	 * @param string $name Message name
	 * @param mixed $message Message
	 */
	public function __set($name, $message)
	{	
		$this->store[$name] = array($message, false);
	}
	
	/**
	 * Reads the instant message stored in the session. Once read it is discarded upon the next request. 
	 * 
	 * @param string $name Message name
	 * @return mixed Message
	 */
	public function &__get($name)
	{
		$value = null;
		
		if (isset($this->store[$name])) 
		{
			$this->store[$name][1] = true;
			$value =& $this->store[$name][0];
		}
		
		return $value;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Parameters.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The class holding {@link Controller}'s request parameters.
 *
 * The parameters can come both from the request and from the URI path. Path parameters are strings and they 
 * are always present (if not mispelled) because they are parsed before the action was fired.
 * The regular parameters are strings usually but it is possible to pass a parameter as an array of strings 
 * (with the help of the <code>[]</code> suffix) therefore you should be careful and never make an assumption 
 * that the 'plain' regular parameter is a string every time.
 *
 * To help with that, the {@link Parameters} class has two additional methods: {@link get_string()} 
 * and {@link get_array()}. Both will return the parameter value only if it belongs to a certain type.
 *
 * Path parameters always override the the regular ones if there is a clash of names.
 *
 * Parameters can be iterated in the <code>foreach</code> loop and therefore they might be passed directly 
 * to the {@link ActiveRecord\Model} instances.
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Parameters extends Store
{
	protected static $instance;

	protected function __construct()
	{	
		$request = Request::instance();
		$this->store = $request->path_parameters + $request->request_parameters + $request->query_parameters;
	}

	/**
	 * Returns the parameter only if it contains a string value. 
	 * The <code>null</code> is returned if the parameter neither has the string
	 * value nor exists.
	 *
	 * @param string $name Name of a parameter
	 * @return string
	 */
	public function &get_string($name)
	{
		$value = null;
		
		if (isset($this->store[$name]) && ((string) $this->store[$name] === $this->store[$name]))
			$value =& $this->store[$name];
			
		return $value;
	}
	
	/**
	 * Returns the parameter only if it contains an array. 
	 * The <code>null</code> is returned if the parameter neither contains 
	 * the array value nor exists.
	 *
	 * @param string $name Name of a parameter
	 * @return array
	 */
	public function &get_array($name)
	{
		$value = null;
		
		if (isset($this->store[$name]) && ((array) $this->store[$name] === $this->store[$name]))
			$value =& $this->store[$name];
		
		return $value;
	}
	
	/**
	 * Returns the parameters array copy.
	 *
	 * @return array
	 */
	public function to_a()
	{
		return $this->store;
	}
	
	/**
	 * Returns the filtered parameters array copy without specified ones.
	 *
	 * @param string ... Variable-length list of parameter names
	 * @return array
	 */
	public function except(/*...*/)
	{
		$params = $this->store;

		foreach (func_get_args() as $name)
			unset($params[$name]);
		
		return $params;
	}
	
	/**
	 * Returns the filtered parameters array copy containing only specified
	 * parameters.
	 *
	 * @param string ... Variable-length list of parameter names
	 * @return array
	 */
	public function only(/*...*/)
	{
		$params = array();
		
		foreach (func_get_args() as $name)
			$params[$name] = $this->store[$name];
			
		return $params;
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Cookies.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The class simplifying handling cookies.
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Cookies extends Store
{
	protected static $instance;
	
	protected function __construct()
	{		 
		parent::__construct($_COOKIE);
	}
	
	/**
	 * If <code>$value</code> is a string this method sends a cookie just like the <code>setcookie()</code> PHP
	 * function, except the default path. It is set to '/'.
	 * 
	 * If the <code>$value</code> is an array, the following options are available:
	 *
	 * <ul>
	 * <li><b>value</b>: the value of the cookie
	 * <li><b>expire</b>: the time the cookie expires (default 0)</li>
	 * <li><b>path</b>: the path on the server in which the cookie will be available on (default <code>/</code>)</li>
	 * <li><b>domain</b>: the domain that the cookie is available to</li>
	 * <li><b>secure</b>: indicates that cookie should be transmitted through SSL (default false)</li>
	 * <li><b>http_only</b>: if true the cookie will use HTTP protocol only (default false)</li>
	 * <li><b>raw</b>: if true the cookie will not be url-encoded</li>
	 * </ul>
	 * 
	 * @param string $name The name of the cookie
	 * @param mixed $value The value of the cookie or the array of options
	 */
	public function __set($name, $value)
	{
		if ((array) $value === $value)
		{
			$val = isset($value['value']) ? $value['value'] : '';
			parent::__set($name, $val);
			Response::instance()->add_header(
				self::create_cookie_header(
					$name, 
					$val,
					isset($value['expire']) ? $value['expire'] : 0,
					isset($value['path']) ? $value['path'] : '/',
					isset($value['domain']) ? $value['domain'] : '',
					isset($value['secure']) ? $value['secure'] : false,
					isset($value['http_only']) ? $value['http_only'] : false,
					isset($value['raw']) ? $value['raw'] : false
				), 
				false
			);
		}
		else
		{
			parent::__set($name, $value);
			Response::instance()->add_header(self::create_cookie_header($name, $value),	false);
		}
	}
	
	/**
	 * Causes the browser to remove the session cookie.
	 *
	 * @param string $name The name of the cookie
	 */
	public function __unset($name)
	{
		parent::__unset($name);
		Response::instance()->add_header(self::create_cookie_header($name, '', $_SERVER['REQUEST_TIME'] - 60000),false);
	}
	
	private final function create_cookie_header($name, $val='', $exp=0, $path='/', $domain='',
		$sec=false, $http=false, $raw=false)
	{	
		if ($domain)
		{
			if (strtolower(strpos($domain, 'www.')) === 0)
				$domain = substr($domain, 4);
				
			if ($domain[0] !== '.')
				$domain = '.' . $domain;
			
			$port = strpos($domain, ':');
			if ($port !== false)
				$domain = substr($domain, 0, $port);
		}
		return 'Set-Cookie: ' . rawurlencode($name) . '=' 
			. ($raw ? $value : rawurlencode($value))
			. ($domain ? "; Domain=$domain" : '')
			. (exp ? '; expires=' . gmdate('D, d-M-Y H:i:s', $exp) . ' GMT' :'')									   
			. ($path ? "; Path=$path" : '')
			. ($sec ? '; Secure' : '')
			. ($http ? '; HttpOnly' : '');
		
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Request.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * Class encapsulating the request details parsed on processing.
 * 
 * @package Application
 * @author Szymon Wrozynski
 */
class Request extends Singleton
{ 
	/**
	 * The reference to the parsed routing entry from the <code>$ROUTES</code> array.
	 *
	 * @internal
	 * @var array
	 */
	public $route;
	
	/**
	 * The path parameters array.
	 *
	 * @internal
	 * @var array
	 */
	public $path_parameters = array();
	
	/**
	 * The query parameters array.
	 *
	 * @internal
	 * @var array
	 */
	public $query_parameters;
	
	/**
	 * The request parameters array (passed in the request body).
	 *
	 * @internal
	 * @var array
	 */
	public $request_parameters;
	
	protected static $instance;
	private $_uri;
	
	protected function __construct($uri) 
	{
		$this->_uri = $uri;
		$this->query_parameters = $_GET;
		
		if ($_SERVER['REQUEST_METHOD'] === 'POST')
			$this->request_parameters = $_POST;
		else
			parse_str(file_get_contents('php://input'), $this->request_parameters);
	}
	
	/**
	 * Returns the {@link Request} instance.
	 * 
	 * @param string $uri URI used once while creating the instance
	 * @return Request
	 */
	public static function &instance($uri=null)
	{
		if (!static::$instance && $uri)
			static::$instance = new Request($uri);
		
		return static::$instance;
	}
	
	/**
	 * Gets the request URI path (without the specified server path).
	 * 
	 * @return string
	 */
	public function uri()
	{
		return $this->_uri;
	}
	
	/**
	 * Gets the client remote IP.
	 *
	 * @return string
	 */
	public function remote_ip()
	{
		return $_SERVER['REMOTE_ADDR'];
	}

	/**
	 * Returns the current HTTP request method.
	 *
	 * @return string Current HTTP method
	 */
	public function method()
	{
		return $_SERVER['REQUEST_METHOD'];
	}

	/**
	 * Determines if the current HTTP request is secure (SSL) or not.
	 *
	 * @return bool True if SSL is used, false otherwise
	 */
	public function is_ssl()
	{
		return $_SERVER['SERVER_PORT'] == (Configuration::instance()->ssl_port ?: 443);
	}

	/**
	 * Determines if the current HTTP request uses a GET method.
	 *
	 * @return bool True if a GET method is used, false otherwise
	 */
	public function is_get()
	{
		return $_SERVER['REQUEST_METHOD'] === 'GET';
	}

	/**
	 * Determines if the current HTTP request uses a POST method.
	 *
	 * @return bool True if a POST method is used, false otherwise
	 */
	public function is_post()
	{
		return $_SERVER['REQUEST_METHOD'] === 'POST';
	}
	
	/**
	 * Determines if the current HTTP request uses a PUT method.
	 *
	 * @return bool True if a PUT method is used, false otherwise
	 */
	public function is_put()
	{
		return $_SERVER['REQUEST_METHOD'] === 'PUT';
	}

	/**
	 * Determines if the current HTTP request uses a DELETE method.
	 *
	 * @return bool True if a DELETE method is used, false otherwise
	 */
	public function is_delete()
	{
		return $_SERVER['REQUEST_METHOD'] === 'DELETE';
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Session.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The class simplifying the session usage.
 * 
 * <code>
 * $login = $session->login;
 * # the same as:
 * # $login = $_SESSION['login'];
 *
 *
 * $session->login = $login;
 * # the same as: 
 * # $_SESSION['login'] = $login;
 *
 *
 * unset($session->login);
 * # the same as: 
 * # unset($_SESSION['login']);
 *
 *
 * isset($session->login);
 * # the same as: 
 * # isset($_SESSION['login']);
 * </code>
 *
 * @author Szymon Wrozynski
 * @package Application
 */
class Session extends Store
{	
	protected static $instance;
	
	protected function __construct($session_name)
	{
		if ($session_name !== true)
			session_name($session_name);
		
		session_start();
		parent::__construct($_SESSION);
	}
	
	/**
	 * Returns the {@link Session} instance only if the session is enable through the {@link Configuration} instance.
	 * Otherwise returns null.
	 * 
	 * @return Session
	 */
	public static function &instance()
	{
		if (!static::$instance)
		{
			$session = Configuration::instance()->session;
			
			if ($session)
				static::$instance = new Session($session);
		}
		
		return static::$instance;
	}
	
	/**
	 * Destroys the current session and causes the browser to remove the session cookie.
	 */
	public function kill()
	{
		$_SESSION = array();
		session_destroy();
		setcookie(session_name(), '', $_SERVER['REQUEST_TIME'] - 60000, '/', '', 0, 0);
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
	
	write($path . 'Controller.php', _strip_phpdoc(<<< 'AP'
<?php
namespace Application;

/**
 * The abstract base class for your controllers.
 *
 * @author Szymon Wrozynski
 * @package Application
 */ 
abstract class Controller extends Singleton
{
	/**
	 * Sets the name of the default layout for templates of this {@link Controller}. All layouts are placed under 
	 * the 'layouts' subdirectory. A layout may be placed in its own subdirectory as well.
	 * The subdirectories are separated with a backslash <code>\</code>. If there is a backslash in the specified 
	 * value then the given value is treated as a path starting from the 'views' directory.
	 * The backslash should not be a first character.
	 * 
	 * Examples:
	 *
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   static $layout = 'main'; # views/layouts/main.php
	 *	   static $layout = '\Admin\main'; # bad!
	 *	   static $layout = 'Admin\main'; # views/layouts/Admin/main.php
	 * }
	 * </code>
	 *
	 * The layout(s) may be specified with modifiers:
	 *
	 * <ul>
	 * <li><b>only</b>: the layout will be used only for the specified 
	 *	   action(s)</li>
	 * <li><b>except</b>: the layout will be used for everything but the 
	 *	   specified action(s)</li>
	 * </ul>
	 *
	 * Example: 
	 *
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   static $layout = array(
	 *		   array('custom', 'only' => array('index', 'show')),
	 *		   'main'
	 *	   );
	 *	   # ...
	 * } 
	 * </code>
	 *
	 * In the example above, the <code>custom</code> layout is used only for <code>index</code> and <code>show</code>
	 * actions. For all other actions the <code>main</code> layout is used.
	 *
	 * All layout entries are evaluated in the order defined in the array until the first matching layout.
	 *
	 * @var mixed
	 */
	static $layout = null;
	
	/**
	 * Sets public filter methods to run before firing the requested action.
	 *
	 * According to the general Pragwork rule, single definitions may be kept as strings whereas the compound ones
	 * should be expressed within arrays.
	 *
	 * Filters can be extended or modified by class inheritance. The filters defined in a subclass can alter 
	 * the modifiers of the superclass. Filters are fired from the superclass to the subclass.
	 * If a filter method returns a boolean false then the filter chain execution is stopped.
	 * 
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   $before_filter = 'init';
	 *
	 *	   # ...
	 * }
	 * </code>
	 *
	 * There are two optional modifiers: 
	 *
	 * <ul>
	 * <li><b>only</b>: action or an array of actions that trigger off the filter</li>
	 * <li><b>except</b>: action or an array of actions excluded from the filter triggering</li>
	 * </ul>
	 *
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   static $before_filter = array(
	 *		   'alter_breadcrumbs', 
	 *		   'except' => 'write_to_all'
	 *	   );
	 *
	 *	   # ...
	 * }
	 * </code>
	 *
	 * <code>
	 * class ShopController extends \Application\Controller
	 * {
	 *	   static $before_filter = array(
	 *		   array('redirect_if_no_payments', 'except' => 'index'),
	 *		   array('convert_floating_point', 
	 *			   'only' => array('create', 'update'))
	 *	   );
	 *
	 *	   # ...
	 * }
	 * </code>
	 *
	 * @see $before_render_filter
	 * @see $after_filter
	 * @see $exception_filter
	 * @var mixed
	 */
	static $before_filter = null;
	
	/**
	 * Sets public filter methods to run just before the first rendering a view (excluding partials).
	 *
	 * According to the general Pragwork rule, single definitions may be kept as strings whereas the compound ones
	 * should be expressed within arrays.
	 * 
	 * There are two optional modifiers: 
	 *
	 * <ul>
	 * <li><b>only</b>: action or an array of actions that trigger off the filter</li>
	 * <li><b>except</b>: action or an array of actions excluded from the filter triggering</li>
	 * </ul>
	 *
	 * See {@link $before_filter} for syntax details.
	 *
	 * @see $before_filter
	 * @see $after_filter
	 * @see $exception_filter
	 * @var mixed
	 */
	static $before_render_filter = null;
	
	/**
	 * Sets public filter methods to run after rendering a view.
	 *
	 * According to the general Pragwork rule, single definitions may be kept as strings whereas the compound ones
	 * should be expressed within arrays. 
	 *
	 * There are two optional modifiers: 
	 *
	 * <ul>
	 * <li><b>only</b>: action or an array of actions that trigger off the filter</li>
	 * <li><b>except</b>: action or an array of actions excluded from the filter triggering</li>
	 * </ul>
	 *
	 * See {@link $before_filter} for syntax details.
	 *
	 * @see $before_filter
	 * @see $before_render_filter
	 * @see $exception_filter
	 * @var mixed
	 */
	static $after_filter = null;
	
	/**
	 * Sets filter methods to run after rendering a view. 
	 * 
	 * Filter methods must be public or protected. The exception is passed  as a parameter.
	 * 
	 * Unlike in other filter definitions, there are also three (not two) optional modifiers: 
	 *
	 * <ul>
	 * <li><b>only</b>: action or an array of actions that trigger off the filter</li>
	 * <li><b>except</b>: action or an array of actions excluded from the filter triggering</li>
	 * <li><b>exception</b>: the name of the exception class that triggers off the filter</li>
	 * </ul>
	 *
	 * <code>
	 * class PeopleController extends \Application\Controller
	 * {
	 *	   static $exception_filter = array(
	 *		   array(
	 *			   'record_not_found', 
	 *			   'exception' => 'ActiveRecord\RecordNotFound'
	 *		   ),
	 *		   array(
	 *			   'undefined_property',
	 *			   'only' => array('create', 'update'),
	 *			   'exception' => 'ActiveRecord\UndefinedPropertyException'
	 *		   )
	 *	   );
	 *
	 *	   # ...
	 * }
	 * </code>
	 * 
	 * <code>
	 * class AddressesController extends \Application\Controller
	 * {
	 *	   static $exception_filter = array(
	 *		   'undefined_property', 
	 *		   'only' => array('create', 'update'),
	 *		   'exception' => 'ActiveRecord\UndefinedPropertyException'
	 *	   );
	 *
	 *	   # ...
	 * }
	 * </code>
	 *
	 * If the <code>exception</code> modifier is missed, any exception triggers off the filter method. If the modifier
	 * is specified, only a class specified as a string triggers off the filter method. 
	 *
	 * Only a string is allowed to be a value of the <code>exception</code> modifier. This is because of the nature of
	 * exception handling. Exceptions are most often constructed with the inheritance in mind and they are grouped by
	 * common ancestors. 
	 *
	 * The filter usage resembles the <code>try-catch</code> blocks where the single exception types are allowed 
	 * in the <code>catch</code> clause. In fact, the {@link $exception_filter} may be considered as a syntactic sugar
	 * to <code>try-catch</code> blocks, where the same <code>catch</code> clause may be adopted to different actions.
	 * 
	 * See {@link $before_filter} for more syntax details.
	 *
	 * @see $before_filter
	 * @see $before_render_filter
	 * @see $after_filter
	 * @var mixed
	 */
	static $exception_filter = null;
	
	/**
	 * Caches the actions using the page-caching approach. The cache is stored within the public directory, 
	 * in a path matching the requested URL. All cached files have the '.html' extension if needed. 
	 * They can be loaded with the help of the <b>mod_rewrite</b> module (Apache) or similar (see the Pragwork default
	 * .htaccess file). Notice, caching usually requires the 'DirectorySlash Off' directive (<b>mod_dir</b>) 
	 * or equivalent to prevent appending a trailing slash to the path (and automatic redirection) if the web server
	 * finds a directory named similarly to the cached file.
	 *
	 * The parameters in the query string are not cached.
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>if</b>: name(s) of (a) callback method(s)</li>
	 * </ul>
	 *
	 * The writing of cache may be prevented by setting a callback method or an array of callback methods in the
	 * <code>if</code> option. The callback methods are run just before cache writing at the end of the 
	 * {@link $after_filter} chain. If one of them returns a value evaluated to false the writing is not performed. 
	 * You may also prevent caching by redirecting, throwing the {@link StopException}, or interrupting the
	 * {@link $after_filter} chain.
	 *
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   static $caches_page = array( 
	 *		   array(
	 *			   'page',
	 *			   'post',
	 *			   'if' => array('no_forms', 'not_logged_and_no_flash')
	 *		   ),
	 *		   'index', 
	 *		   'if' => 'not_logged_and_no_flash'
	 *	   );
	 *
	 *	   public function no_forms()
	 *	   {
	 *		   return (isset($this->page) && !$this->page->form)
	 *			   || (isset($this->post) && !$this->post->allow_comments);
	 *	   }
	 *
	 *	   public function not_logged_and_no_flash()
	 *	   {
	 *		   return !$this->session->admin && !$this->flash->notice;
	 *	   }
	 *
	 *	   # ...
	 * } 
	 * </code>
	 *
	 * Notice that caching is working properly only if the cache is enable in the configuration 
	 * (see {@link Configuration}).
	 *
	 * @see expire_page()
	 * @see $caches_action
	 * @see Configuration
	 * @var mixed String or array containing action name(s)
	 */
	static $caches_page = null;
	
	/**
	 * Caches the actions views and stores cache files in the 'temp' directory. Action caching differs from page 
	 * caching because action caching always runs {@link $before_filter}(s). 
	 *
	 * Available options:
	 *
	 * <ul>
	 * <li><b>if</b>: name(s) of (a) callback method(s)</li>
	 * <li><b>cache_path</b>: custom cache path</li>
	 * <li><b>expires_in</b>: expiration time for the cached action in seconds</li>
	 * <li><b>layout</b>: set to false to cache the action only (without the default layout)</li>
	 * </ul>
	 *
	 * The writing of cache may be prevented by setting a callback method or an array of callback methods in the
	 * <code>if</code> option. The callback methods are run just before cache writing at the end of the 
	 * {@link $after_filter} chain. If one of them returns a value evaluated to false the writing is not performed. 
	 * You may also prevent caching by redirecting, throwing the {@link StopException}, or interrupting the
	 * {@link $after_filter} chain.
	 *
	 * The <code>cache_path</code> option may be a string started from <code>/</code> or just a name of a method
	 * returning the path. If a method is used, then its returned value should be a string beginning with the
	 * <code>/</code> or a full URL (starting with 'http') as returned by the {@link url_for()} function.
	 *
	 * <code>
	 * class MyController extends \Application\Controller
	 * {
	 *	   static $caches_action = array(
	 *		   'edit', 
	 *		   'cache_path' => 'edit_cache_path'
	 *	   );
	 *	   
	 *	   public function edit_cache_path()
	 *	   {
	 *		   return url_for(array(
	 *			   'edit', 
	 *			   'params' => $this->params->only('lang')
	 *		   ));
	 *	   }
	 *
	 *	   # ...
	 * }
	 * </code>
	 *
	 * Notice that caching is working properly only if the cache is enable in the configuration 
	 * (see {@link Configuration}).
	 *
	 * @see expire_action()
	 * @see $caches_page
	 * @var mixed String or array with action name(s)
	 */
	static $caches_action = null;
	
	/**
	 * The {@link Parameters} object that contains request parameters. 
	 *
	 * @see Parameters
	 * @var Parameters
	 */
	public $params;
	
	/**
	 * The {@link Session} object that simplifies the session usage or null if sessions are disabled.
	 *
	 * @see Session
	 * @see Configuration
	 * @var Session
	 */
	public $session;
	
	/**
	 * The {@link Cookies} object that simplifies handling cookies.
	 *
	 * @see Cookies
	 * @var Cookies
	 */
	public $cookies;
	
	/**
	 * The {@link Flash} object for easy handling flash messages or null if sessions are disabled.
	 *
	 * @see Flash
	 * @see Session
	 * @var Flash
	 */
	public $flash;
	
	/**
	 * The {@link Request} object storing data and informative methods about the current request.
	 *
	 * @see Request
	 * @var Request
	 */
	public $request;
	
	/**
	 * The {@link Response} object storing data about the request response being generated.
	 *
	 * @see Response
	 * @var Response
	 */
	public $response;
	
	/**
	 * The name of the current action.
	 *
	 * @var string
	 */
	public $action;
	
	/**
	 * The simplified name of the current controller (e.g. 'Admin\People', 'Index', etc.). 
	 *
	 * @var string
	 */
	public $controller;
	
	protected static $instance;
	
	private static $_content;
	private static $_ch_file;
	private static $_ch_dir;
	private static $_ch_layout;
	private static $_ch_if;
	private static $_rendered;
	private static $_http_url;
	private static $_ssl_url;
	private static $_cache;
	
	protected function __construct()
	{
		$config = Configuration::instance();
		
		self::$_http_url = $config->http_url();
		self::$_ssl_url = $config->ssl_url();
		self::$_cache = $config->cache;
		
		$this->params = Parameters::instance();
		$this->session = Session::instance();
		$this->flash = Flash::instance();
		$this->cookies = Cookies::instance();
		
		$class = get_class($this);
		do 
		{
			require HELPERS . str_replace('\\', DIRECTORY_SEPARATOR, substr($class, 12, -10)) . 'Helper.php';
		}
		while (($class = get_parent_class($class)) !== __CLASS__);
	}
	
	/**
	 * The method name reserved for testing environment
	 */
	private final function clean_up() {}
	
	/**
	 * Starts request processing. It starts the the proper action depending on the {@link Request} object. 
	 * It is called automatically by the {@link Application\start()} function.
	 *
	 * @param Request $request The Request object instance
	 * @internal
	 */
	public function process($request, $response)
	{
		$this->request = $request;
		$this->response = $response;
		$this->action = $action = $request->route['action'];
		$this->controller = $request->route['controller'];
		
		try
		{
			ob_start();
			
			$this->invoke_filters('before_filter');
			
			if (self::$_cache)
			{
				if (static::$caches_action)
					$this->set_action_cache($request->uri());
				
				if (static::$caches_page)
					$this->set_page_cache($request->uri());
			}	
						
			$this->$action();

			if (!self::$_rendered)
				$this->render();
			
			$this->response->body = ob_get_clean();
			
			$this->invoke_filters('after_filter');
		}
		catch (StopException $e)
		{
			$this->response->body = ob_get_clean();
		}
		catch (\Exception $e) 
		{
			if ($this->invoke_filters('exception_filter', $e) !== false)
			{
				$this->response->body = ob_get_clean();
				$this->response->status = 500;
				$this->response->exception = $e;
			}
		}
	}
	
	/**
	 * Returns the default URL options used by all functions based on the {@link url_for()} function. 
	 * This method should return an array of default options or nothing (a null value). 
	 * Each default option may be overridden by each call to the {@link url_for()} function.
	 *
	 * @see url_for()
	 * @return array Default URL options or null
	 */
	public function default_url_options() {}
	
	/**
	 * Deletes the cached page, cached via the {@link $caches_page}. 
	 * 
	 * The cache path is computed from options passed internally to the {@link url_for()} function. 
	 * Therefore see the {@link url_for()} function for options syntax.
	 *
	 * @see $caches_page
	 * @param mixed $options Options array or action name (string)
	 */
	public function expire_page($options=array())
	{
		$key = url_for($options);
		$qpos = strpos($key, '?');
		$start = strlen(($key[4] === 's') ? self::$_ssl_url : self::$_http_url);
		$key = ($qpos === false) 
			? trim(substr($key, $start), '/.')
			: trim(substr($key, $start, $qpos - $start), '/.');
		
		if (isset($key[0]))
		{
			$cached_page = str_replace('/', DIRECTORY_SEPARATOR, $key);
			
			if (substr($key, -5) !== '.html')
				$cached_page .= '.html';
		}
		else
			$cached_page = 'index.html';
		
		if (is_file($cached_page))
		{
			unlink($cached_page);
		
			while (($dir = dirname($cached_page)) !== '.')
			{
				$empty = true;
				$handler = opendir($dir);
				
				while (false !== ($file = readdir($handler)))
				{
					if (($file !== '.') && ($file !== '..'))
					{
						$empty = false;
						break;
					}
				}
				
				closedir($handler);
			
				if (!$empty)
					break;
					
				rmdir($dir);
				$cached_page = $dir;
			}
		}
	}
	
	/**
	 * Deletes the cached action view, cached via the  {@link $caches_action}. 
	 * 
	 * The cache path is computed from options passed internally to the {@link url_for()} function. 
	 * Therefore see the {@link url_for()} function for options syntax. 
	 *
	 * @see $caches_action
	 * @param mixed $options Options array or action name (string)
	 */
	public function expire_action($options=array())
	{
		$key = url_for($options);
		$key = substr($key, strlen(($key[4]==='s') ? self::$_ssl_url : self::$http_url));
		
		# if longer than 1 char (e.g. longer than '/')
		if (isset($key[1])) 
			$key = rtrim($key, '/.');
			
		$cached_dir = TEMP . 'ca_' . md5($key);
		
		if (is_dir($cached_dir))
		{
			$handler = opendir($cached_dir);

			while (false !== ($file = readdir($handler)))
			{
				if ($file[0] !== '.')
					unlink($cached_dir . DIRECTORY_SEPARATOR . $file);
			}

			closedir($handler);
			rmdir($cached_dir);
		}
		
		$cached_action = $cached_dir . '.cache';
		
		if (is_file($cached_action))
			unlink($cached_action);
	}
	
	/**
	 * Returns true if the cached fragment is available. 
	 * 
	 * The cache path is computed from options passed internally to the {@link url_for()} function. 
	 * Therefore see the {@link url_for()} function for options syntax. 
	 * Moreover, the additional following options are available:
	 *
	 * <ul>
	 * <li><b>action_suffix</b>: the path suffix allowing many fragments in the same action</li>
	 * </ul>
	 *
	 * @see cache()
	 * @see expire_fragment()
	 * @param mixed $options Options array or action name (string)
	 * @return bool True if the fragment exists, false otherwise
	 */
	public function fragment_exists($options=array())
	{
		return is_file(self::fragment_file($options));
	}
	
	/**
	 * Deletes a cached fragment. 
	 * 
	 * The cache path is computed from options passed internally to the {@link url_for()} function. 
	 * Therefore see the {@link url_for()} function for options syntax. 
	 * Moreover, the additional following options are available:
	 *
	 * <ul>
	 * <li><b>action_suffix</b>: the path suffix allowing many fragments in the same action</li>
	 * </ul>
	 *
	 * @see cache()
	 * @see fragment_exists()
	 * @param mixed $options Options array or action name (string)
	 */
	public function expire_fragment($options=array())
	{
		$fragment = self::fragment_file($options);
		if (is_file($fragment))
			unlink($fragment);
	}
	
	/**
	 * Caches the fragment enclosed in the closure. 
	 *
	 * The cache path is computed from options passed internally to the {@link url_for()} function. 
	 * Therefore see the {@link url_for()} function for options syntax. 
	 * Moreover, the additional following options are available:
	 *
	 * <ul>
	 * <li><b>action_suffix</b>: the suffix allowing many fragments in the same action</li>
	 * <li><b>expires_in</b>: time-to-live for the cached fragment (in sec)</li>
	 * </ul>
	 *
	 * Notice, this method will write and read cached fragments only if the cache is enable in the configuration 
	 * (see {@link Configuration}).
	 *
	 * @see expire_fragment()
	 * @see fragment_exists()
	 * @param mixed $options Options array or action name (string)
	 * @param \Closure $closure Content to be cached and displayed
	 */
	public function cache($options, $closure)
	{
		if (!self::$_cache)
			return $closure($this);
		
		$frag = self::fragment_file($options);
		
		if (is_file($frag))
		{
			if (isset($options['expires_in']))
			{
				if ((filemtime($frag) + $options['expires_in']) > $_SERVER['REQUEST_TIME'])
					return readfile($frag);
			}
			else
				return readfile($frag);
		}
		
		ob_start();
		$closure($this);
		$output = ob_get_clean();
		file_put_contents($frag, $output);
		echo $output;
	}
	
	private static final function fragment_file($options)
	{
		$key = url_for($options);
		$key = substr($key,strlen(($key[4]==='s') ? self::$_ssl_url : self::$_http_url));   
		
		if (isset($options['action_suffix']))
			$key .= $options['action_suffix'];
		
		return TEMP . 'cf_' . md5($key) . '.cache';
	}
	
	private final function render_cache_in_layout()
	{
		if (is_dir(self::$_ch_dir))
		{
			$handler = opendir(self::$_ch_dir);

			while (false !== ($file = readdir($handler)))
			{
				if ($file[0] !== '.')
					self::$_content[$file] = file_get_contents(self::$_ch_dir . DIRECTORY_SEPARATOR . $file);
			}

			closedir($handler);
		}
		
		$this->render(array('text' => file_get_contents(self::$_ch_file), 'layout' => true));
		throw new StopException;
	}
	
	private final function set_action_cache($key)
	{
		if (self::$_ch_file)
			return;
		
		foreach (self::normalize_defs(static::$caches_action) as $ch)
		{
			if ($ch[0] !== $this->action)
				continue;
			
			if (isset($ch['cache_path']))
			{
				if ($ch['cache_path'][0] === '/')
					self::$_ch_dir = TEMP . 'ca_' . md5($ch['cache_path']);
				else
				{
					$chp = $this->$ch['cache_path']();
						
					if ($chp[0] === '/')
						self::$_ch_dir = TEMP . 'ca_' . md5($chp);
					elseif ($chp[4] === 's')
						self::$_ch_dir = TEMP . 'ca_' . md5(substr($chp, strlen(self::$_ssl_url)));
					else
						self::$_ch_dir = TEMP . 'ca_' . md5(substr($chp, strlen(self::$_http_url)));
				}
			}
			else
				self::$_ch_dir = TEMP . 'ca_' . md5(isset($key[1]) ? rtrim($key, '/.') : $key);

			self::$_ch_file = self::$_ch_dir . '.cache';
			
			if (isset($ch['layout']) && !$ch['layout'])
			{ 
				if (is_file(self::$_ch_file))
				{
					if (isset($ch['expires_in']))
					{ 
						if ((filemtime(self::$_ch_file)+$ch['expires_in'])>$_SERVER['REQUEST_TIME'])
							$this->render_cache_in_layout();
					}
					else
						$this->render_cache_in_layout();
				}
				self::$_ch_layout = self::resolve_layout($this->action);
				static::$layout = null;
			}
			elseif (is_file(self::$_ch_file))
			{
				if (isset($ch['expires_in']))
				{ 
					if ((filemtime(self::$_ch_file) + $ch['expires_in']) > $_SERVER['REQUEST_TIME'])
					{
						readfile(self::$_ch_file);
						throw new StopException;
					}
				}
				else
				{
					readfile(self::$_ch_file);
					throw new StopException;
				}
			}
			
			if (isset($ch['if']))
				self::$_ch_if = $ch['if'];
			   
			self::add_to_filter('after_filter', 'write_and_show_cache');
			break;
		}
	}
	
	private final function set_page_cache($key)
	{
		if (self::$_ch_file)
			return;
		
		foreach (self::normalize_defs(static::$caches_page) as $ch)
		{	
			if ($ch[0] !== $this->action)
				continue;
						
			$key = trim($key, '/.');
				
			if (isset($key[0]))
			{
				self::$_ch_file = str_replace('/', DIRECTORY_SEPARATOR, $key);
									
				if (!strpos($key, '.'))
					self::$_ch_file .= '.html';
			}
			else
				self::$_ch_file = 'index.html';
			
			if (isset($ch['if']))
				self::$_ch_if = $ch['if'];
			
			self::add_to_filter('after_filter', 'write_and_show_cache');
			break;
		}
	}
	
	private final function write_and_show_cache()
	{			 
		if (self::$_ch_if)
		{
			if ((array) self::$_ch_if === self::$_ch_if)
			{
				foreach (self::$_ch_if as $ifm)
				{
					if (!$this->$ifm())
						return;
				}
			}
			else
			{
				$ifm = self::$_ch_if;
				
				if (!$this->$ifm())
					return;
			}
		}
		
		if (!self::$_ch_dir) # if caches page
		{
			$dir = dirname(self::$_ch_file);
				
			if (!is_dir($dir))
				mkdir($dir, 0775, true);
		}
		
		file_put_contents(self::$_ch_file, $this->response->body);
		
		if (self::$_ch_layout)
		{
			if (self::$_content)
			{
				if (is_dir(self::$_ch_dir))
				{
					$handler = opendir(self::$_ch_dir);

					while (false !== ($f = readdir($handler)))
					{
						if ($f[0] !== '.')
							unlink(self::$_ch_dir .DIRECTORY_SEPARATOR .$f);
					}

					closedir($handler);
				}
				else
					mkdir(self::$_ch_dir, 0775);
				
				foreach (self::$_content as $r => $c)
					file_put_contents(self::$_ch_dir.DIRECTORY_SEPARATOR.$r,$c);	   
			}
			
			ob_start();
			$this->render(array('text' => $this->response->body, 'layout' => self::$_ch_layout));
			$this->response->body = ob_get_clean();
		}
	}
	
	/**
	 * Sends a location in the HTTP header causing a HTTP client to redirect. 
	 * 
	 * The location URL is obtained from {@link url_for()} function. See {@link url_for()} function for options syntax.
	 *
	 * Additionally, following options are available:
	 * 
	 * <ul>
	 * <li><b>status</b>: HTTP status code (default: 302). It might be an int or a symbolic name (e.g. 'found')</li>
	 * <li><b>[name]</b>: additional flash message</li>
	 * </ul>
	 *
	 * Example:
	 *
	 * <code>
	 * $this->redirect_to(array('index', 'notice' => 'Post updated.'));
	 * # Redirects to the action 'index' and sets the appropriate flash
	 * # message.
	 * </code>
	 *
	 * @see url_for()
	 * @see redirect_to_url()
	 * @param mixed $options Options array or action name (string)
	 * @throws {@link StopException} In order to stop further execution
	 */
	public function redirect_to($options=array())
	{
		if ((array) $options !== $options)
			$this->redirect_to_url(url_for($options));
		elseif (!$this->session)
			$this->redirect_to_url(url_for($options), $options);
		
		$url = url_for($options);
		
		unset(
			$options['params'], 
			$options[0],
			$options['name'],
			$options['ssl'], 
			$options['anchor'],
			$options['locale'],
			$options['action'], 
			$options['controller']
		);
		
		$this->redirect_to_url($url, $options);
	}
	
	/**
	 * Sends a location in the HTTP header causing a HTTP client to redirect. 
	 * 
	 * The following options are available:
	 * 
	 * <ul>
	 * <li><b>status</b>: HTTP status code (default: 302) It might be an int or a symbolic name (e.g. 'found')</li>
	 * <li><b>[name]</b>: additional flash message</li>
	 * </ul>
	 *
	 * @see redirect_to()
	 * @param string $url URL of the location
	 * @param mixed $options Options array
	 * @throws {@link StopException} In order to stop further execution
	 */
	public function redirect_to_url($url, $options=array())
	{
		if (isset($options['status']))
		{
			$this->response->status = $options['status'];
			unset($options['status']);
		}
		else 
			$this->response->status = 302;
		
		if ($this->flash)
		{
			foreach ($options as $name => $msg)
				$this->flash->$name = $msg;
		}
		
		$this->response->location = $url;
		throw new StopException;
	}
	
	/**
	 * Renders a template depending on parameters passed via $options.
	 * 
	 * The rendering topic may be divided into two big areas of use: rendering of templates and rendering of partial
	 * templates.
	 * 
	 * <h4>A. General rendering of templates</h4>
	 *
	 * Templates are placed under the directory 'views' of the application code. They fill the directory structure
	 * according to the controllers structure.
	 *
	 * <h4>A.1. Rendering a template in the current controller</h4>
	 *
	 * <code>
	 * class ShopController extends \Application\Controller
	 * {
	 *	   public function index()
	 *	   {
	 *		   # $this->render();
	 *	   }
	 *
	 *	   public function show()
	 *	   {
	 *		   $this->render('index');
	 *		   $this->render(array('index'));
	 *		   $this->render(arary('action' => 'index'));
	 *	   }
	 * }
	 * </code>
	 *
	 * Each of the method calls in the action <code>show</code> above renders the template of the action
	 * <code>index</code> of the current controller. However you should render a template once. 
	 * Notice also, rendering the template does not stop the further action execution.
	 *
	 * The {@link render()} with no arguments renders the template of the current action. 
	 * But the action renders its own template implicitly if no other render is used (except partial templates).
	 * Therefore there is no need to explicit call {@link render()} in the <code>index</code> action above.
	 *
	 * <h4>A.2. Rendering a template of another controller</h4>
	 *
	 * <code>
	 * class CustomersController extends \Application\Controller
	 * {
	 *	   public function edit() {}
	 * }
	 *
	 * class ShopController extends \Application\Controller
	 * {
	 *	   public function show()
	 *	   {
	 *		   $this->render(array(
	 *			   'action' => 'edit', 
	 *			   'controller' => 'Customers'
	 *		   ));
	 *
	 *		   # or just: $this->render('Customers\edit')
	 *	   }
	 * }
	 * </code>
	 *
	 * Renders the template of the <code>edit</code> action of the Customers controller.
	 *
	 * <h4>A.3. Rendering a custom template</h4>
	 *
	 * <code>
	 * $this->render('my_custom_template');
	 * $this->render('my_templates\my_custom_template');
	 * $this->render(array('my_custom_template', 'layout' => false))
	 * $this->render(array('my_custom_template', 'layout' => 'my_layout'));
	 * </code>
	 *
	 * Renders a custom template. The custom template may be placed in a subdirectory. 
	 * The subdirectories are separated with a backslash <code>\</code>. If there is a backslash in the string,
	 * the path starts from the root (the 'views' directory).
	 *
	 * Each of the examples from the part <b>A</b> can be altered with an option <code>layout</code> which can point 
	 * to a certain {@link $layout}. Also, this option can be set to <code>false</code> disabling the global
	 * layout defined in the controller. The layout file should be put in the 'views/layouts' subdirectory.
	 *
	 * <code>
	 * class ShopController extends \Application\Controller
	 * {
	 *	   static $layout = 'shop';
	 *
	 *	   public function index()
	 *	   {
	 *		   # use the default layout ('views/layouts/shop.php')
	 *	   }
	 *
	 *	   public function show()
	 *	   {
	 *		   $this->render(array('layout' => false));
	 *
	 *		   # do not use any layout, same as self::$layout = null;
	 *	   }
	 *
	 *	   public function edit()
	 *	   {
	 *		   $this->render(array(
	 *			   'action' => 'show',
	 *			   'layout' => 'custom_layout'
	 *		   ));
	 *
	 *		   # or just:
	 *		   # $this->render(array('show', 'layout' => 'custom_layout'));
	 *
	 *		   # use the template 'views/Shop/show.php' with 
	 *		   # the layout 'views/layouts/custom_layout.php'.
	 *	   }
	 * }
	 * </code>
	 *
	 * <h4>A.4. Content Format and Status</h4>
	 *
	 * It is possible to specify a content format in the header sended with the first use of the {@link render()} 
	 * method (excluding partials). It can be done with help of the <code>content_type</code> option.
	 *
	 * <code>
	 * $this->render(array('show', 'content_type' => 'text/xml'));
	 * </code>
	 *
	 * Also, you can set a status for your content:
	 *
	 * <code>
	 * $this->render(array('status' => 200)); # 200 OK
	 * $this->render(array('status' => 'created')); # 201 Created
	 * </code>
	 *
	 * If a status denotes the client error (400 - 499) and there is no template to selected explicitly to render 
	 * then the error template (from 'errors' directory) is rendered. For server errors (greater or equal than 500),
	 * the special template (500.php) is rendered.
	 *
	 * <code>
	 * $this->render(array('status' => 'not_found')); # renders errors/404.php
	 * $this->render(array('status' => 405)); #renders errors/405.php
	 * </code>
	 *
	 * <h4>A.5. Format</h4>
	 *
	 * Format enables additional headers to be sent on the first call of {@link render()} (again partials does not
	 * count). Also, it provides additional, specific behavior, depending on the chosen format.
	 *
	 * Currently there is only one format available: <b>xml</b>.
	 *
	 * <code>
	 * $this->render(array('format' => 'xml'));
	 * </code>
	 *
	 * It renders the template (the default one in this particular example) with the header: "Content-Type: text/xml;
	 * charset=utf-8" (no content format was specified). Moreover, it disables the global layout. You can always use 
	 * a layout by specifying a layout template:
	 *
	 * <code>
	 * $this->render(array('format' => 'xml', 'layout' => 'my_xml_layout'));
	 * </code>
	 *
	 * Or, you can turn on the global layout by setting <code>layout</code> to <code>true</code> explicitly.
	 *
	 * <h4>A.6. Text, XML, JSON</h4>
	 * 
	 * You can also specify a text (or xml, json) instead of a template. 
	 * It is useful especially in the AJAX applications.
	 *
	 * <code>
	 * $this->render(array('text' => 'OK'));
	 * $this->render(array('xml' => $xml));
	 * $this->render(array('json' => array('a' => 1, 'b' => 2, 'c' => 3)));
	 * </code>
	 *
	 * If you do not set the custom content format, the 'application/xml' is  used for XML and 'application/json' 
	 * is used for JSON.
	 * 
	 * The <code>json</code> option allows to pass <code>json_options</code> bitmask, just like it is done 
	 * in the global <code>json_encode()</code> function.
	 * 
	 * <code>
	 * $this->render(array(
	 *	   'json' => array(array(1, 2, 3)), 
	 *	   'json_options' => JSON_FORCE_OBJECT
	 * ));
	 * </code>
	 *
	 *
	 * <h4>B. Rendering partial templates</h4>
	 *
	 * Partial templates are placed in the same directory structure as normal templates. They differ from the normal
	 * ones in extensions. Partial templates ends with the '.part.php' extension.
	 *
	 * Whereas normal rendering of templates is taking place in the controller, the rendering of partials is the domain
	 * of template files mainly. Usually partial templates represent repetitive portions of code used to construct more
	 * compound structures. The result of rendering the partial template is returned as a string - it is not
	 * displayed immediately and therefore it should be displayed explicitly with the <code>echo</code> function.
	 *
	 * If the '.part.php' file is not found the '.php' one is used instead and the template is rendered in the normal
	 * way described in the section A.
	 *
	 * <h4>B.1. Rendering the partial template</h4>
	 * 
	 * <code>
	 * <?php echo $this->render('item') ?>
	 * </code>
	 *
	 * The code above renders the partial template 'item.part.php' placed under the controller's directory in the views
	 * structure. If the partial template name contains a backslash <code>\</code> the absolute path will be used 
	 * (with the root set to 'views' directory).
	 *
	 * <code>
	 * <?php echo $this->render('shared\header') ?>
	 * # renders /views/shared/header.part.php
	 * </code>
	 *
	 * Everything (except <code>collection</code>) passed as named array elements are converted to local variables
	 * inside the partial template.
	 * 
	 * <code>
	 * <?php echo $this->render(array('item', 'text' => 'Hello')) ?>
	 * # renders the partial template ('item.part.php') and creates a local 
	 * # variable named $text there.
	 * </code>
	 *
	 * <h4>B.2. Rendering a partial template with a collection</h4>
	 *
	 * If you use the <code>collection</code> option you can render the partial template a few times, according to items
	 * passed in an array as the <code>collection</code>. The current item from the collection is named after 
	 * the template name, and the array key name has the <code>'_key'</code> suffix.
	 *
	 * The code below:
	 *
	 * <code>
	 * <?php $this->render(array(
	 *	   'person', 
	 *	   'collection' => array('John', 'Frank'),
	 *	   'message' => 'The message.'
	 * )) ?>
	 * </code>
	 *
	 * could be used in the 'person.part.php' like here:
	 *
	 * <code>
	 * <h1><?php echo Hello $person ?></h1>
	 * <p><?php echo $message ?></p>
	 * <p>And the current key is: <?php echo $person_key ?></p>
	 * </code>
	 * 
	 * In the above example the 'person.part.php' will be rendered twice, with different names (<code>$person</code>)
	 * and keys (<code>$person_key</code>). The whole collection will be still available under 
	 * the <code>$collection</code> variable.
	 *
	 * @see $layout
	 * @param mixed $options Options array or string
	 * @return mixed Rendered partial template or null
	 */
	public function render($options=array())
	{	
		if ((array) $options !== $options)
		{
			$template = VIEWS . ((strpos($options, '\\') === false)
				? str_replace('\\', DIRECTORY_SEPARATOR, $this->controller) . DIRECTORY_SEPARATOR . $options
				: str_replace('\\', DIRECTORY_SEPARATOR, $options));
			
			$partial = $template . '.part.php';
			
			if (is_file($partial))
			{
				ob_start();
				require $partial;
				return ob_get_clean();
			}
			
			if (!self::$_rendered)
			{
				$this->invoke_filters('before_render_filter');
				self::$_rendered = true;
			}
			
			$layout = self::resolve_layout($this->action);
			
			if ($layout)
			{
				ob_start();
				require $template . '.php';
				self::$_content[0] = ob_get_clean();
				require VIEWS . 'layouts' . DIRECTORY_SEPARATOR
					. str_replace('\\', DIRECTORY_SEPARATOR, $layout) . '.php';
			}
			else
				require $template . '.php';
			return;
		}
		elseif (isset($options[0]))
		{
			$template = VIEWS . ((strpos($options[0], '\\') === false)
				? str_replace('\\', DIRECTORY_SEPARATOR, $this->controller) . DIRECTORY_SEPARATOR . $options[0]
				: str_replace('\\', DIRECTORY_SEPARATOR, $options[0]));
			
			$partial = $template . '.part.php';
			
			if (is_file($partial))
			{
				unset($options[0]);
				ob_start();
			
				if (isset($options['collection']))
				{
					$name = basename($partial, '.part.php');		
					$key_name = $name . '_key';
				
					foreach ($options['collection'] as $key => $item)
						$this->render_partial($partial, array($name => $item, $key_name => $key) + $options);
				}
				else
					$this->render_partial($partial, $options);
			
				return ob_get_clean();
			}
		}
		elseif (isset($options['xml']))
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'application/xml';
			
			$options['text'] = $xml;
		}
		elseif (isset($options['json']))
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'application/json';
			
			$options['text'] = isset($options['json_options'])
				? json_encode($options['json'], $options['json_options'])
				: json_encode($options['json']);
		}
		elseif (!isset($options['text']))	 
			$template = VIEWS . str_replace('\\', DIRECTORY_SEPARATOR,
				isset($options['controller']) ? $options['controller'] : $this->controller) 
				. DIRECTORY_SEPARATOR . (isset($options['action']) ? $options['action'] : $this->action);
		
		if (isset($options['status']))
			$this->response->status = $options['status'];
		
		if (isset($options['text']))
		{
			if (isset($options['content_type']))
				$this->response->content_type = $options['content_type'];
				
			if (!self::$_rendered)
			{
				$this->invoke_filters('before_render_filter');
				self::$_rendered = true;
			}
						
			if (isset($options['layout']))
			{
				if ($options['layout'] === true)
					$options['layout'] = self::resolve_layout($this->action);
				
				self::$_content[0] = $options['text'];
				require VIEWS . 'layouts' . DIRECTORY_SEPARATOR . 
					str_replace('\\', DIRECTORY_SEPARATOR, $options['layout']) . '.php';
			}
			else
				echo $options['text'];
			
			return;
		}
		
		if (!isset($options[0]) && !isset($options['action']) && !isset($options['controller']) 
			&& $this->response->status_code() >= 400)
		{
			if (isset($options['content_type']))
				$this->response->content_type = $options['content_type'];
			
			throw new StopException;
		}
		
		if (isset($options['format']) && $options['format'] === 'xml')
		{
			if (!isset($options['content_type']))
				$options['content_type'] = 'text/xml';
			
			if (!isset($options['layout']))
				$options['layout'] = false;
		}
		elseif (!isset($options['layout']))
			$options['layout'] = self::resolve_layout($this->action);
		
		if (isset($options['content_type']))
			$this->response->content_type = $options['content_type'];
		
		if (!self::$_rendered)
		{
			$this->invoke_filters('before_render_filter');
			self::$_rendered = true;
		}
		
		if ($options['layout'])
		{
			ob_start();
			require $template . '.php';
			self::$_content[0] = ob_get_clean();
			require VIEWS . 'layouts' . DIRECTORY_SEPARATOR 
				. str_replace('\\', DIRECTORY_SEPARATOR, $options['layout']) . '.php';
		}
		else
			require $template . '.php';
	}
	
	/**
	 * Renders the template just like the {@link render()} method but returns
	 * the results as a string.
	 *
	 * @see render()
	 * $param mixed $options Options array or string
	 * @return string
	 */
	public function render_to_string($options=array())
	{
		ob_start();
		$str = $this->render($options);
		return ob_get_clean() ?: $str;
	}
	
	private function render_partial($___path___, $___args___)
	{	
		foreach ($___args___ as $___n___ => $___v___) 
			$$___n___ = $___v___;
		
		require $___path___;
	}

	/**
	 * Returns a rendered template or a template region constructed with the {@link content_for()} method and a name
	 * passed as a parameter. 
	 *
	 * This method should be used directly from a layout template. If the region does not exist the null is returned
	 * instead.
	 *
	 * <code>
	 * <?php echo $this->yield() ?>
	 * </code>
	 *
	 * <code>
	 * <?php echo $this->yield('title') ?>
	 * </code>
	 *
	 * @see content_for()
	 * @see render()
	 * @param string $region Optional region name
	 * @return mixed Rendered template, template region, or null
	 */
	public function yield($region=0)
	{
		if (isset(self::$_content[$region]))
			return self::$_content[$region];
	}
	
	/**
	 * Inserts a named content block into a layout view directly from a template. 
	 * 
	 * The region name can be used in the layout with the {@link yield()} method. The closure with the content may have
	 * an argument. If so, the current controller instance is passed there allowing to get to controller methods and
	 * variables. 
	 *
	 * <code>
	 * <?php $this->content_for('title', function() { ?>
	 *	   Just simple title
	 * <?php }) ?>
	 * </code>
	 *
	 * <code>
	 * <?php $this->content_for('title', function($that) { ?>
	 *
	 *	   # the current controller is named '$that' by convention
	 *	   # and because '$this' cannot be used in the closure context
	 *
	 *	   Records found: <?php echo count($that->records) ?>
	 * <?php }) ?>
	 * </code>
	 *
	 * @see yield()
	 * @param string $region Region name
	 * @param \Closure $closure Content for partial yielding
	 */
	public function content_for($region, $closure)
	{
		ob_start();
		$closure($this);
		self::$_content[$region] = ob_get_clean();
	}
	
	private final function resolve_layout($action)
	{
		if (!static::$layout)
			return;
		
		static $layout;
		
		if (!isset($layout))
		{
			$layout = null;
			
			foreach (self::normalize_defs(static::$layout) as $l)
			{
				if (isset($l['only']))
				{
					if ((((array) $l['only'] === $l['only']) && in_array($action, $l['only'], true))
						|| ($l['only'] === $action))
					{
						$layout = $l[0];
						break;
					}
					continue;
				}
				elseif (isset($l['except']) && ((((array) $l['except'] === $l['except']) 
					&& in_array($action, $l['except'], true)) || ($l['except'] === $action)))
					continue;
				
				$layout = $l[0];
				break;
			}
		}
		
		return $layout;
	}
	
	private static final function get_filter_mods(&$entry)
	{
		$modifiers = array();
		if (isset($entry['only']))
		{
			$modifiers['only'] = ((array) $entry['only'] === $entry['only']) 
				? $entry['only'] : array($entry['only']);
			unset($entry['only']);
		}
		if (isset($entry['except']))
		{
			$modifiers['except'] = ((array) $entry['except'] === $entry['except'])
				? $entry['except'] : array($entry['except']);
			unset($entry['except']);
		}
		if (isset($entry['exception']))
		{
			$modifiers['exception'] = $entry['exception'];
			unset($entry['exception']);
		}
		return $modifiers;
	}
	
	private static final function normalize_defs($definitions)
	{	
		if ((array) $definitions !== $definitions)
			return array(array($definitions));

		$normalized_definitions = array();
		$outer_options = array();

		foreach ($definitions as $key => $body)
		{	
			if ((string) $key === $key)
				$outer_options[$key] = $body;
			elseif ((array) $body === $body)
			{	 
				$inner_options = array();

				foreach ($body as $k => $v)
				{
					if ((string) $k === $k)
					{
						$inner_options[$k] = $v;
						unset($body[$k]);
					}
				}

				foreach ($body as $b)
					$normalized_definitions[] = array($b) + $inner_options;
			}
			else
				$normalized_definitions[] = array($body);						 
		}

		if ($outer_options)
		{
			foreach ($normalized_definitions as &$nd)
				$nd += $outer_options;
		}

		return $normalized_definitions;
	}
	
	private static final function add_to_filter($filter, $method)
	{
		if (!static::$$filter)
			static::$$filter = $method;
		elseif ((array) static::$$filter === static::$$filter)
		{
			if (array_key_exists('except', static::$$filter) || array_key_exists('only', static::$$filter))
				static::$$filter = self::normalize_defs(static::$$filter);
			
			array_push(static::$$filter, $method);
		}
		else
			static::$$filter = array(static::$$filter, $method);
	}
	
	private final function invoke_filters($filter, $value=null)
	{	
		$filter_chain = array();
		
		$class = get_class($this);
		do 
		{
			$class_filters = $class::$$filter;
			
			if (!$class_filters)
				continue;
				
			if ((array) $class_filters !== $class_filters)
			{
				if (!isset($filter_chain[$class_filters]))
					$filter_chain[$class_filters] = null;
			}
			else
			{
				$class_mods = self::get_filter_mods($class_filters);
			
				foreach (array_reverse($class_filters) as $entry)
				{
					if ((array) $entry !== $entry)
					{
						if (!isset($filter_chain[$entry]))
							$filter_chain[$entry] = $class_mods;
					}
					else
					{
						$mods = self::get_filter_mods($entry);
					
						foreach (array_reverse($entry) as $e)
						{
							if (!isset($filter_chain[$e]))
								$filter_chain[$e] = $mods ?: $class_mods;
						}
					}
				}
			}
		} while (($class = get_parent_class($class)) !== __CLASS__);
		
		foreach (array_reverse($filter_chain) as $flt => $mods)
		{
			if (isset($mods['only']) && !in_array($this->action, $mods['only']))
				continue;
			elseif (isset($mods['except']) && in_array($this->action, $mods['except']))
				continue;
			elseif (isset($mods['exception']) && !($value && is_a($value, $mods['exception'])))
				continue;

			if ($this->$flt($value) === false)
				return false;
		}
	}
}
?>
AP
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_tags_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR;
	write($path . 'tags.php', sprintf(<<< 'TAGS'
<?php
/**
 * Tags Module 1.1 for Pragwork %s
 *
 * @copyright %s
 * @license %s
 * @version %s
 * @package Tags
 */


TAGS
		, PRAGWORK_VERSION, AUTHOR, LICENSE, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'TAGS'
namespace
{
	/**
	 * Creates the <code><a></code> tag from the passed text and options. 
	 * 
	 * The text is used as the inner text of the link. It might be a plain text or other HTML code. 
	 * The options are used to construct the URL for the link (see {@link url_for()} for syntax details). 
	 * All options left are appended to the constructed tag as its attributes.
	 *
	 * <code>
	 * echo link_to('link 1', 'index');
	 *
	 * # <a href="http://www.mydomain.com/shop/index">link 1</a>;
	 *
	 * echo link_to('link 2', array(
	 *	   'action' => 'add', 
	 *	   'controller' => 'Shop', 
	 *	   'anchor' => 'foo', 
	 *	   'class' => 'my-link'
	 * ));
	 *
	 * # <a href="http://www.mydomain.com/shop/add#foo" class="my-link">
	 * # link 2</a>
	 * </code>
	 *
	 * @see link_to_url()
	 * @see url_for()
	 * @param string $text Inner text of the link
	 * @param mixed $options Options for URL and attributes
	 * @return string <code><a></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function link_to($text, $options=array())
	{
		if ((array) $options !== $options)
			return link_to_url($text, url_for($options));
		
		$url = url_for($options);
		
		unset(
			$options['params'], 
			$options[0],
			$options['name'],
			$options['ssl'], 
			$options['anchor'],
			$options['locale'],
			$options['action'], 
			$options['controller']
		);
		
		return link_to_url($text, $url, $options);
	}
	
	/**
	 * Creates the <code><a></code> tag from the passed text, URL, and options. 
	 *
	 * The text is used as the inner text of the link. It might be a plain text or other HTML code. 
	 * The URL is placed in the <code>href</code> attribute. Options are appended to the constructed tag as its 
	 * attributes.
	 *
	 * <code>
	 * echo link_to_url('Pragwork', 'http://pragwork.com');
	 *
	 * # <a href="http://pragwork.com">Pragwork</a>
	 *
	 * echo link_to_url('Pragwork', 'http://pragwork.com', array(
	 *	   'class' => 'my-link'
	 * ));
	 *
	 * # <a href="http://pragwork.com" class="my-link">Pragwork</a>
	 * </code>
	 *
	 * @see link_to()
	 * @param string $text Inner text of the link
	 * @param string $url URL used to create the hiperlink
	 * @param array $options Attributes
	 * @return string <code><a></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function link_to_url($text, $url, $options=array())
	{
		$html = '<a href="' . $url . '"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . '>' . $text . '</a>';
	}
	
	/**
	 * Creates the one button form (An <code><input></code> tag enclosed in a <code><form></code>). 
	 * 
	 * The text is used as the value of the button. The options are used to construct the URL for the
	 * link (see {@link url_for()} for syntax details). However, there are special options:
	 * 
	 * <ul>
	 * <li><b>method</b>: HTTP method for the form (default: POST)</li>
	 * <li><b>confirm</b>: confirmation message (default: null)</li>
	 * <li><b>hidden_fields</b>: (array) adds hidden fields to the form</li>
	 * </ul>
	 *
	 * If the HTTP GET method is used then all query parameters are abandoned because the new query string is created
	 * automatically from form fields upon form sending. Therefore you should specify custom parameters as
	 * <code>hidden_fields</code> in such case.
	 *
	 * All other options left are appended to the <code><input></code> tag as its attributes. The possible confirm
	 * message is used to construct a javascript confirm dialog. All quotes in the message are safely encoded.
	 *
	 * The <code><form></code> tag has a special class - <code>button-to</code>. 
	 * The <code><input></code> can have the class defined explicitly in the options.
	 * 
	 * <code>
	 * echo button_to('button 1', 'index');
	 *
	 * # <form class="button-to" action="http://www.mydomain.com/shop/index"
	 * # method="post"><input type="submit" 
	 * # value="button 1" /></form>
	 * 
	 * echo button_to('button 2', array(
	 *	   'action' => 'add', 
	 *	   'controller' => 'Shop',	
	 *	   'method' => 'get',
	 *	   'class' => 'my-button'
	 * ));
	 *
	 * # <form class="button-to" action="http://www.mydomain.com/shop/add"
	 * # method="get"><input type="submit" value="button 2"
	 * # class="my-button"/></form>
	 *
	 * echo button_to('button 3', array('delete', 'params' => array(':id' => 3),
	 *	   'confirm' => 'Are you sure?'));
	 *
	 * # <form class="button-to"
	 * # action="http://www.mydomain.com/shop/delete/3" method="post"
	 * # onSubmit="return confirm('Are you sure?');">
	 * # <input type="submit" value="button 1" /></form>
	 * </code>
	 *
	 * @see button_to_url()
	 * @see url_for()
	 * @param string $text Value of the <code><submit></code> tag
	 * @param mixed $options Options for URL and attributes
	 * @return string One button <code><form></code> tag
	 * @author Szymon Wrozynski
	 */
	function button_to($text, $options=array())
	{
		if ((array) $options !== $options)
			return button_to_url($text, url_for($options));
		
		$url = url_for($options);
		
		unset(
			$options['params'], 
			$options[0],
			$options['name'],
			$options['ssl'], 
			$options['anchor'],
			$options['locale'],
			$options['action'], 
			$options['controller']
		);
		
		return button_to_url($text, $url, $options);
	}
	
	/**
	 * Creates the one button form (An <code><input></code> tag enclosed in a <code><form></code>). 
	 * 
	 * The text is used as the value of the button. The URL serves as the form action. There are special options:
	 * <code>method</code>, <code>confirm</code>, and <code>hidden_fields</code> described here: {@link button_to()}.
	 * Other options are appended to the <code><input></code> tag as its attributes.
	 *
	 * @see button_to()
	 * @see link_to_url()
	 * @param string $text Value of the button
	 * @param string $url Form action
	 * @param array $options Options and attributes
	 * @return string One button <code><form></code> tag
	 * @author Szymon Wrozynski
	 */
	function button_to_url($text, $url, $options=array())
	{
		$form = '<form class="button-to" action="' . $url . '" method="';
		
		if (isset($options['method']))
		{
			$form .= $options['method'];
			unset($options['method']);
		}
		else
			$form .= 'post';
		
		if (isset($options['confirm']))
		{
			$form .= '" onSubmit="return confirm(\'' 
				. str_replace(array('\'', '"'), array('\\x27', '\\x22'), $options['confirm']) . '\');';
			
			unset($options['confirm']);
		}
		
		$form .= '">';
		
		if (isset($options['hidden_fields']))
		{
			foreach ($options['hidden_fields'] as $n => $v)
				$form .= '<input type="hidden" name="' . $n . '" value="' . $v . '" />';
			
			unset($options['hidden_fields']);
		}
		
		$form .= '<input type="submit" value="' . $text . '" ';
		
		foreach ($options as $n => $v)
			$form .= $n . '="' . $v . '" ';
		
		return $form . '/></form>';
	}
	
	/**
	 * Creates a form for a model. 
	 * 
	 * The model might be an object (usually {@link ActiveRecord\Model} or {@link ActiveRecord\TablelessModel} 
	 * instance), an array, or a null value. If the array is passed it is automatically cast to an object
	 * (<code>stdClass</code>). Although the model is not necessary, the form can work with it internally if present.
	 * Also, model values are present in form fields and as form properties.
	 *
	 * The options are used to construct a form action URL (see {@link url_for()} for syntax details). 
	 * The closure should be a function with one or two arguments. The first parameter is the {@link Tags\Form}
	 * instance. The second one is the instance of current controller. That way you can make the controller context
	 * (<code>$this</code>) available inside the closure. All other options are parsed as the <code><form></code> tag
	 * attributes. 
	 * 
	 * By default, the form method is equal to <code>post</code> and the <code>accept-charset</code> is set to
	 * <code>utf-8</code>.
	 * 
	 * The form body is constructed within the <code>$closure</code> function and it uses an instance of the helper
	 * class {@link Tags\Form}.
	 *
	 * <code>
	 * <?php echo form_for($this->person, 'update', function($f) { ?>
	 *
	 * <p>
	 *	   <?php echo $f->label('name', 'Name') ?>
	 *	   <?php echo $f->text_field('name', array('size' => 60)) ?>
	 *	   <?php echo $f->error_messages('name', array('wrap_in' => 'p', 
	 *		   'class' => 'error')) ?>
	 * </p>
	 *
	 * <p>
	 *	   <?php echo $f->submit('Save', array('class' => 'button')) ?>
	 * </p>
	 *
	 * <?php }) ?>
	 * </code>
	 *
	 * Example with two parameters used in the closure:
	 *
	 * <code>
	 * <?php echo form_for(null, 'search', function($f, $that) { ?>
	 *	   <p>Last search: <?php echo $that->session->last_search ?></p>
	 *	   <p><?php echo $f->text_field('q') ?></p>
	 * <?php }) ?>
	 * </code>
	 *
	 * @see ActiveRecord\Model
	 * @see ActiveRecord\TablelessModel
	 * @see Tags\Form
	 * @see form_for_url()
	 * @param mixed $model Model corresponding with the form or null
	 * @param mixed $options Array or string used to construct the form action
	 * @param \Closure $closure Form body constructing closure
	 * @return string <code><form></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function form_for($model, $options, $closure)
	{
		if ((array) $options !== $options)
			return form_for_url($model, url_for($options), null, $closure);
		
		$url = url_for($options);
		
		unset(
			$options['params'], 
			$options[0],
			$options['name'],
			$options['ssl'], 
			$options['anchor'],
			$options['locale'],
			$options['action'], 
			$options['controller']
		);
		
		return form_for_url($model, $url, $options, $closure);
	}
	
	/**
	 * Creates a form for a model. 
	 * 
	 * The model might be an object (usually {@link ActiveRecord\Model} or {@link ActiveRecord\TablelessModel} 
	 * instance), an array, or a null value. If the array is passed it is automatically cast to an object 
	 * (<code>stdClass</code>). Although the model is not necessary, the form can work with it internally if present.
	 * Also, model values are present in form fields and as form properties. The URL is used as the form action.
	 *
	 * @see form_for()
	 * @param mixed $model Model corresponding with the form or null
	 * @param string $url Form action
	 * @param mixed $options Form attributes or null to use default ones
	 * @param \Closure $closure Form body constructing closure
	 * @return string <code><form></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function form_for_url($model, $url, $options, $closure)
	{	
		$html = '<form action="' . $url . '"';
		
		if (isset($options['confirm']))
		{
			$html .= ' onSubmit="return confirm(\'' 
				. str_replace(array('\'', '"'), array('\\x27', '\\x22'), $options['confirm']) . '\');"';
			unset($options['confirm']);
		}
			
		if (!isset($options['method']))
			$html .= ' method="post"';
			
		if (!isset($options['accept-charset']))
			$html .= ' accept-charset="utf-8"';
		
		if ($options)
		{
			foreach ($options as $n => $v)
				$html .= ' ' . $n . '="' . $v . '"';
		}
		
		ob_start();
		$closure(new Tags\Form($model), Application\Controller::instance());
		return $html . '>' . ob_get_clean() . '</form>';
	}
	
	/**
	 * Creates a <code>mailto</code> link for the specified email and options.
	 *
	 * The following options are available:
	 *
	 * <ul>
	 * <li><b>text</b>: The text to be displayed within the created hyperlink. If not specified, the <code>$email</code>
	 *     will be used.</li>
	 * <li><b>replace_at</b>: sets a replacement for the <code>@</code> sign, to obfuscate the email address displayed
	 *     if there is no custom text for the link</li>
	 * <li><b>replace_dot</b>: same as above but obfuscates all dots in the email address</li>
	 * <li><b>subject</b>: sets the subject line of the email</li>
	 * <li><b>body</b>: sets the body of the email</li>
	 * <li><b>cc</b>: sets Carbon Copy recipients on the email</li>
	 * <li><b>bcc</b>: sets Blind Carbon Copy recipients on the email</li>
	 * </ul>
	 *
	 * Other options are appended to the <code><a></code> tag as its attributes.
	 *
	 * @see link_to_url()
	 * @param string $email Email address to use
	 * @param array $options Options and attributes
	 * @return string <code><a></code> tag with a <code>mailto</code> reference
	 * @author Szymon Wrozynski
	 */
	function mail_to($email, $options=array())
	{
		if (isset($options['text']))
		{
			$text = $options['text'];
			unset($options['text']);
		}
		else
		{
			$text = $email;
			
			if (isset($options['replace_at']))
			{
				$text = str_replace('@', $options['replace_at'], $text);
				unset($options['replace_at']);
			}
			
			if (isset($options['replace_dot']))
			{
				$text = str_replace('.', $options['replace_dot'], $text);
				unset($options['replace_dot']);
			}
		}
		
		$params = array();
		
		if (isset($options['subject']))
		{
			$params['subject'] = $options['subject'];
			unset($options['subject']);
		}
		
		if (isset($options['body']))
		{
			$params['body'] = $options['body'];
			unset($options['body']);
		}
		
		if (isset($options['cc']))
		{
			$params['cc'] = $options['cc'];
			unset($options['cc']);
		}
		
		if (isset($options['bcc']))
		{
			$params['bcc'] = $options['bcc'];
			unset($options['bcc']);
		}
		
		$url = 'mailto:' . $email;
		
		if ($params)
			$url .= '?' .  str_replace('+', '%20', http_build_query($params));
		
		return link_to_url($text, $url, $options);	  
	}
	
	/**
	 * Returns the <code><img></code> tag with the URL to the static image according to file specified as the parameter.
	 *
	 * If the <code>$file</code> starts with <code>/</code> it is treated as it would reflect the public directory
	 * structure. Otherwise, the file is get along to the <code>IMAGES_PATH</code> constant defined in the 'index.php'
	 * file. The path defined there can be a local public directory like '/images' or even a standalone server 
	 * (e.g. 'http://static.mydomain.com/images'). Also the <code>$file</code> can be an independent full URL address:
	 *
	 * <code>
	 * <?php echo image_tag('http://static.mydomain.com/images/my_logo.png') ?>
	 * </code>
	 *
	 * @see url_for()
	 * @param string $file Image file name or path
	 * @param array $options HTML attributes appended to the <code><img></code> tag
	 * @return string <code><img></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function image_tag($file, $options=array())
	{
		static $images_path;
		
		if (!isset($images_path))
			$images_path = \Application\Configuration::instance()->images_path;
		
		$html = '<img src="' . Tags\_asset_url($images_path, $file) . '"';
		
		foreach ($options as $n => $v)
			$html .= ' '. $n . '="' . $v . '"';
		
		return $html . ' />';
	}
	
	/**
	 * Returns the <code><link></code> tag with the URL to the CSS file according to the specified parameter. 
	 * 
	 * If the <code>$file</code> starts with <code>/</code> it is treated as it would reflect the public directory
	 * structure. Otherwise the file is get along to the <code>STYLESHEETS_PATH</code> constant defined in the
	 * 'index.php' file. The path defined there can be a local public directory like '/stylesheets' or even a standalone
	 * server (e.g. 'http://static.mydomain.com/stylesheets').
	 *
	 * @see url_for()
	 * @param string $file CSS file name or path
	 * @param array $options HTML attributes appended to the <code><link></code> tag
	 * @return string <code><link></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function stylesheet_link_tag($file, $options=array())
	{
		static $stylesheets_path;
		
		if (!isset($stylesheets_path))
			$stylesheets_path = \Application\Configuration::instance()->stylesheets_path;
		
		$html = '<link rel="stylesheet" href="' . Tags\_asset_url($stylesheets_path, $file) . '"';
			
		if (!isset($options['type']))
			$html .= ' type="text/css"';
		
		if (!isset($options['media']))
			$html .= ' media="screen"';
					
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';
	}
	
	/**
	 * Returns the <code><script></code> tag with the URL to the javascript file according to specified parameter. 
	 *
	 * If the <code>$file</code> starts with <code>/</code> is treated as it would reflect the public directory
	 * structure. Otherwise the file is get along to the <code>JAVASCRIPTS_PATH</code> constant defined in the
	 * 'index.php' file. The path defined there can be a local public directory like '/javascripts' or even 
	 * a standalone server (e.g. 'http://static.mydomain.com/javascripts').
	 *
	 * @see url_for()
	 * @param string $file Javascript file name or path
	 * @param array $options HTML attributes appended to the <code><script></code> tag
	 * @return string <code><script></code> HTML tag
	 * @author Szymon Wrozynski
	 */
	function javascript_include_tag($file, $options=array())
	{
		static $javascripts_path;
		
		if (!isset($javascripts_path))
			$javascripts_path = \Application\Configuration::instance()->javascripts_path;
		
		$html = '<script src="' . Tags\_asset_url($javascripts_path, $file) .'"';
			
		if (!isset($options['type']))
			$html .= ' type="text/javascript"';
		
		if (!isset($options['charset']))
			$html .= ' charset="utf-8"';
					
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . '></script>';
	}
	
	spl_autoload_register(function($class)
	{
		if ($class === 'Tags\Form')
			require MODULES . 'Tags' . DIRECTORY_SEPARATOR . 'Form.php';
	});
}

namespace Tags
{
	/**
	 * An internal function for resolving URLs of assets.
	 *
	 * @internal This function should not be used explicitly! Internal use only.	
	 * @param string $static Static asset path
	 * @param mixed $asset Requested asset
	 * @return string URL to the asset
	 * @author Szymon Wrozynski
	 */
	function _asset_url($static, $asset)
	{
		if ($asset[0] === '/')
			return url_for($asset);
		
		if (strpos($asset, '://') !== false) 
			return $asset;
		
		return ($static[0] === '/') ? url_for($static . '/' . $asset) : $static . '/' . $asset;
	}
}
?>
TAGS
	), $GLOBALS['STRIP_PHPDOC']);
	
	$path .= 'Tags';
	
	if (is_dir($path))
		rmtree($path);
	
	mkdir($path, 0755);
	
	write($path . DIRECTORY_SEPARATOR . 'Form.php', _strip_phpdoc(<<< 'TAGS'
<?php
namespace Tags;

/**
 * The helper class used inside the form body building closure of the {@link form_for()} function. 
 * 
 * It serves as a container of functions creating fields of the form as well as a wrapper of the attached model. 
 * All public properties of the model are available as properties of the form class.
 * Also, all form methods are aware of corresponding model values. 
 *
 * @see form_for()
 * @author Szymon Wrozynski
 */
class Form
{
	private $_model;
	
	/**
	 * The default constructor. 
	 * 
	 * The model might be an object, an array, or a null. If the array is passed it is automatically cast to an object.
	 *
	 * @param mixed $model Model passed to the {@link form_for()} function
	 */
	public function __construct($model=null)
	{
		if ($model)
			$this->_model = ((array) $model === $model) ? (object) $model : $model;
	}
		
	/**
	 * Sets a model property (if a model has been attached).
	 *
	 * @param string $name Name of the property
	 * @param mixed $value Property value
	 */
	public function __set($name, $value)
	{
		if ($this->_model)
			$this->_model->$name = $value;
	}
	
	/**
	 * Gets a model property (if a model has been attached).
	 *
	 * @param string $name Name of the property
	 * @return mixed Model property or null
	 */
	public function __get($name)
	{
		return ($this->_model) ? $this->_model->$name : null;
	}
		
	/**
	 * Returns a model reference.
	 *
	 * @return mixed Reference to the attached model (or null)
	 */
	public function &model()
	{
		return $this->_model;
	}
	
	/**
	 * Returns <code>true</code> if there are any error messages in the model for the specified field or for all fields
	 * (if none given).
	 *
	 * @param mixed $name Field name or e.g. null for all fields
	 * @return bool True if there are error messages or false otherwise
	 */
	public function is_error($name=null)
	{
		return $name 
			? $this->_model && $this->_model->errors && $this->_model->errors->$name
			: $this->_model && $this->_model->errors && !$this->_model->errors->is_empty();
	}

	/**
	 * Returns error messages after the form validation for the given field name or for all fields if no name was 
	 * passed. 
	 * 
	 * If there are no errors the null is returned. It works with ActiveRecord validation engine and expects 
	 * {@link ActiveRecords\Errors} object to be present in the model.
	 *
	 * The following options are available:
	 *
	 * <ul>
	 * <li><b>separator</b>: separator between a displayed name and a message. If empty, the field names in the
	 *     constructed messages are omitted. Otherwise field names optionally translated are used.  Default: ' '</li>
	 * <li><b>wrap_in</b>: name of the enclosing tag</li>
	 * <li><b>localize</b>: <b>true</b>/<b>false</b> to explicitly turn on/off localization</li>
	 * </ul>
	 *
	 * If the <code>wrap_in</code> is not present then error messages are separated with a dot. If localization is
	 * turned on, the message and name are translated separately.
	 *
	 * All other options are appended to the enclosing tag as attributes.
	 *
	 * @param mixed $name Field name or e.g. null for all fields
	 * @param array $options Formatting options
	 * @return string Error messages or HTML tag(s)
	 */
	public function error_messages($name, $options=array())
	{
		if ($this->_model && $this->_model->errors)
		{
			static $localization;
			
			if (!isset($localization))
				$localization = \Application\Configuration::instance()->localization;
			
			$localize = isset($options['localize']) ? $options['localize'] : ($localization !== false);
			$separator = isset($options['separator']) ? $options['separator'] : ' ';
			
			if ($name)
			{
				$error_messages = $this->_model->errors->$name;
			
				if (!$error_messages)
					return;
				
				if ($separator)
					$name = $localize ? t($name) : ucfirst(str_replace('_', ' ', $name));
				else
					$name = '';
				
				foreach ($error_messages as &$em)
					$em = $name . $separator . ($localize ? t($em) : $em);
			}
			else
				$error_messages = $this->_model->errors->full_messages($separator, $localize);
			
			if (isset($options['wrap_in']))
			{
				$tag_opening = '<' . $options['wrap_in'];
				$tag_close = '</' . $options['wrap_in'] . '>'; 
				
				unset($options['wrap_in'], $options['localize'], $options['separator']);
				
				foreach ($options as $n => $v) 
					$tag_opening .= ' ' . $n . '="' . $v . '"';
				
				$tag_opening .= '>';
				
				$html = '';
				
				foreach ($error_messages as $msg)
					$html .= $tag_opening . $msg . $tag_close;
				
				return $html;
			}
			else
				return implode('. ', $error_messages);
		}
	}
	
	/**
	 * Creates the <code><label></code> tag for the given field name. 
	 * 
	 * It uses localization or simple name humanization if no value supplied.
	 * 
	 * @param string $name Field name
	 * @param string $value Label value
	 * @param array $options Formatting options
	 * @return string <code><label></code> HTML tag
	 */
	public function label($name, $value=null, $options=array())
	{
		static $localization;
		
		if (!isset($localization))
			$localization = \Application\Configuration::instance()->localization;
		
		$html = '<label';
		
		if ($value === null) 
			$value = ($localization !== false) ? t($name) : ucfirst(str_replace('_', ' ', $name));
		
		if (!isset($options['for']))
			$html .= ' for="' . $name . '-field"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . '>' . $value . '</label>';
	}

	/**
	 * Creates the <code><select></code> tag for the given field name. 
	 *
	 * The passed <code>$collection</code> is an array of possible select values. The array may contain objects and/or
	 * key-value pairs, or just strings (strings will be used both as keys and values). For objects it is possible to
	 * set property names for the option text and value or even more specified closures.
	 *
	 * Formatting options:
	 *
	 * <ul>
	 * <li><b>option_text</b>: property name or a closure</li>
	 * <li><b>option_value</b>: property name or a closure</li>
	 * <li><b>selected</b>: closure comparing the current value and the
	 *	   model</li>
	 * <li><b>blank</b>: special blank option value</li>
	 * </ul> 
	 *
	 * The <code>option_text</code> and <code>option_value</code> might be property names or anonymous functions which
	 * transform an object from the <code>$collection</code> into the option text or value:
	 *
	 * <code>
	 * $f->select('person', $this->persons, array('option_text' =>
	 *	   function($p) { return $p->first_name . ' ' . $p->last_name; }));
	 * </code>
	 *
	 * The default value for <code>option_text</code> is <code>name</code> and 
	 * for <code>option_value</code> - <code>id</code>.
	 *
	 * The <code>selected</code> could be a closure of form: 
	 *
	 * <code> 
	 * bool function($model, $value)
	 * </code>
	 *
	 * The default closure used looks similarily to this one: 
	 *
	 * <code>
	 * function($model, $value) use ($name) 
	 * {
	 *	   return $model && $model->$name == $value;
	 * }
	 * </code>
	 *
	 * The <code>blank</code> option could be: 
	 *
	 * <code>
	 * $f->select('opt', $this->options, array('blank' => array(
	 *	   'Please choose a value' => 0
	 * )));
	 * </code>
	 *
	 * Other options are appended as the <code><select></code> tag attributes.
	 *
	 * @param string $name Field name
	 * @param string $collection Possible selectable options
	 * @param array $options Formatting options
	 * @return string <code><select></code> HTML tag
	 */
	public function select($name, $collection, $options=array())
	{
		$html = '<select name="' . $name . '"';
		
		if (!isset($options['id'])) 
			$html . ' id="' . $name . '-field"';
		
		if (isset($options['option_text'])) 
		{
			$option_text = $options['option_text'];
			unset($options['option_text']);
		} 
		else 
			$option_text = 'name';
		
		if (isset($options['option_value'])) 
		{
			$option_value = $options['option_value'];
			unset($options['option_value']);
		}
		else 
			$option_value = 'id';
			
		if (isset($options['selected']))
		{
			$selected_closure = $options['selected'];
			unset($options['selected']);
		}
		else
		{
			$selected_closure = function($model, $value) use ($name) 
			{
				return $model && $model->$name == $value;
			};
		}
		
		if (isset($options['blank']))
		{
			if ((array) $options['blank'] === $options['blank'])
				$collection = array_merge($options['blank'], $collection);
			else
				array_unshift($collection, $options['blank']);
			
			unset($options['blank']);
		}
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		$html .= '>';
		
		foreach ($collection as $n => $v) 
		{
			if ((object) $v === $v)
			{
				$n = ((string) $option_text === $option_text) ? $v->$option_text : $option_text($v);
				$v = ((string) $option_value === $option_value) ? $v->$option_value : $option_value($v);
			}
			elseif ((int) $n === $n)
				$n = $v;
			
			$html .= '<option value="' . $v . '"';
			
			if ($selected_closure($this->_model, $v))
				$html .= ' selected="selected"';
			
			$html .= '>' . $n . '</option>';
		}
		
		return $html . '</select>';
	}

	private function checked_input($name, $options) 
	{
		$html = '<input name="' . $name . '"';
		
		if (!isset($options['id']))
			$html .= ' id="' . $name . '-field"';
		
		if (!isset($options['value'])) 
			$options['value'] = 1;
		
		if (isset($options['checked'])) 
		{
			if ($options['checked'])
				$html .= ' checked="checked"';
			
			unset($options['checked']);
		} 
		elseif ($this->_model && ($this->_model->$name == $options['value']))
			$html .= ' checked="checked"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
			
		return $html . ' />';
	}

	/**
	 * Creates the <code><input></code> radio tag for the given field name. 
	 *
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name, 
	 * the default value is set to 1. The <code>checked</code> attribute can be set explicitly or estimated 
	 * from the comparision of the model field (<code>$name</code>) and the value.
	 *
	 * @see check_box()
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> radio button
	 */
	public function radio_button($name, $options=array()) 
	{
		$options['type'] = 'radio';
		return $this->checked_input($name, $options);
	}
	
	/**
	 * Creates the <code><input></code> check box tag for the given field name. 
	 *
	 * Formatting options:
	 *
	 * <ul>
	 * <li><b>unchecked</b>: value of the unchecked box</li>
	 * </ul>
	 *
	 * There is a hidden field put before the the check box containing the value of the <code>unchecked</code> option.
	 * If the check box is not checked, the hidden field value is sent instead of nothing. If the <code>unchecked</code> 
	 * option is not present then it is implicitly set to 0. If the <code>unchecked</code> is set to <code>false</code> 
	 * then no hidden field prepends the check box tag.
	 *
	 * The other options serve as attributes. The default <code>name</code> attribute is set to the field name, 
	 * the default value is set to 1. The <code>checked</code> attribute can be set explicitly or estimated
	 * from the comparision of the model field (<code>$name</code>) and the value.
	 *
	 * @see radio_button()
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> check box
	 */
	public function check_box($name, $options=array())
	{
		$options['type'] = 'checkbox';

		if (isset($options['unchecked']))
		{	
			$hidden = ($options['unchecked'] === false)
				? '' 
				: $this->hidden_field($name, array('value' => $options['unchecked']));
			
			unset($options['unchecked']);
			return $hidden . $this->checked_input($name, $options);
		}
		else
			return $this->hidden_field($name, array('value' => 0)) . $this->checked_input($name, $options);
	}
	
	/**
	 * Creates the <code><textarea></code> tag for the given field name. 
	 *
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name as well 
	 * as the <code>id</code> one. 
	 *
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><textarea></code> HTML tag
	 */
	public function text_area($name, $options=array()) 
	{
		$html = '<textarea name="' . $name . '"';
			
		if (!isset($options['id']))
			$html .= ' id="' . $name . '-field"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . '>' . htmlspecialchars($this->_model->$name) . '</textarea>';
	}
	
	/**
	 * Creates the <code><input></code> file tag for the given field name. 
	 *
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name as well 
	 * as the <code>id</code> one. 
	 *
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> file HTML tag
	 */
	public function file_field($name, $options=array())
	{
		$html = '<input type="file" name="' . $name . '"';
			
		if (!isset($options['id']))
			$html .= ' id="' . $name . '-field"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
			
		return $html . ' />';
	}
	
	private function valued_input($name, $options)
	{
		$html = '<input name="' . $name . '"';
		
		if (!isset($options['id']))
			$html .= ' id="' . $name . '-field"';
		
		if (!isset($options['value']) && $this->_model)
			$html .= ' value="' .htmlspecialchars($this->_model->$name).'"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';
	}
	
	/**
	 * Creates the <code><input></code> hidden tag for the given field name. 
	 *
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name as well 
	 * as the <code>id</code> one. The <code>value</code> is set to the field name by default.
	 *
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> hidden tag
	 */
	public function hidden_field($name, $options=array())
	{
		$options['type'] = 'hidden';
		return $this->valued_input($name, $options);
	}
	
	/**
	 * Creates the <code><input></code> text tag for the given field name.
	 * 
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name as well 
	 * as the <code>id</code> one. The <code>value</code> is set to the field name by default.
	 *
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> text tag
	 */
	public function text_field($name, $options=array())
	{
		$options['type'] = 'text';
		return $this->valued_input($name, $options);
	}
	
	/**
	 * Creates the <code><input></code> password tag for the given field name. 
	 *
	 * The options serve as tag attributes. The default <code>name</code> attribute is set to the field name as well 
	 * as the <code>id</code> one. The <code>value</code> is set to the field name by default.
	 *
	 * @param string $name Field name
	 * @param array $options Formatting options
	 * @return string <code><input></code> password tag
	 */
	public function password_field($name, $options=array()) 
	{
		$options['type'] = 'password';
		return $this->valued_input($name, $options);
	}
	
	/**
	 * Creates the <code><input></code> submit button. 
	 * 
	 * The options serve as tag attributes. The <code>value</code> is set to the given parameter value.
	 *
	 * @param string $value Submit button value
	 * @param array $options Formatting options
	 * @return string <code><input></code> submit button
	 */
	public function submit($value, $options=array()) 
	{
		$html = '<input type="submit" value="' . $value . '"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';			 
	}
	
	/**
	 * Creates the <code><input></code> button tag. 
	 * 
	 * The options serve as tag attributes. The <code>value</code> is set to the given parameter value.
	 *
	 * @param string $value Button value
	 * @param array $options Formatting options
	 * @return string <code><input></code> button tag
	 */
	public function button($value, $options=array())
	{
		$html = '<input type="button" value="' . $value . '"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';
	}
	
	/**
	 * Creates the <code><input></code> image button tag. 
	 * 
	 * Options serve as tag attributes. The image file is resolved in the same way as in the 
	 * {@link image_tag()} function.
	 *
	 * @see image_tag
	 * @param string $file Button image file
	 * @param array $options Formatting options
	 * @return string <code><input></code> image button tag
	 */
	public function image($file, $options=array()) 
	{
		static $images_path;
		
		if (!isset($images_path))
			$images_path = \Application\Configuration::instance()->images_path;
		
		$html = '<input type="image" src="' . _asset_url($images_path, $file) . '"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';
	}
	
	/**
	 * Creates the <code><input></code> reset button tag. 
	 * 
	 * Options serve as tag attributes. The <code>value</code> is set to the given parameter value.
	 *
	 * @param string $value Button value
	 * @param array $options Formatting options
	 * @return string <code><input></code> reset button tag
	 */
	public function reset($value, $options=array())
	{
		$html = '<input type="reset" value="' . $value . '"';
		
		foreach ($options as $n => $v)
			$html .= ' ' . $n . '="' . $v . '"';
		
		return $html . ' />';			 
	}
}
?>
TAGS
	), $GLOBALS['STRIP_PHPDOC']);
}

function make_paginate_module($work)
{
	$path = $work . DIRECTORY_SEPARATOR . 'modules' . DIRECTORY_SEPARATOR . 'paginate.php';
	write($path, sprintf(<<< 'PAG'
<?php
/**
 * Paginate Module 1.1 for Pragwork %s
 *
 * @copyright %s
 * @license %s
 * @version %s
 * @package Paginate
 */


PAG
		, PRAGWORK_VERSION, AUTHOR, LICENSE, PRAGWORK_VERSION)
	. _strip_phpdoc(<<< 'PAG'
/**
 * Splits the collection into smaller chunks and returns the chunk, its ordinal number (page) and the overall number 
 * of extracts (total pages).
 * 
 * <code>
 * list($people, $current_page, $total_pages) = paginate($all_people, 3, 10);
 * </code>
 * 
 * Creates the $people array containing 10 people max (if possible it would be records 20 to 29 of the 
 * <code>$all_people array</code>) along with the <code>$current_page</code> and <code>$total_pages</code> variables. 
 * The <code>$current_page</code> it is not always the same as the passed <code>$page</code> parameter. 
 * If the passed <code>$page</code> parameter was lower than 1 the <code>$current_page</code> is set to 1, 
 * and if the passed <code>$page</code> was greater than the greatest possible value, the <code>$current_page</code> 
 * is corrected accordingly. The <code>$total_pages</code> is computed according to the <code>$per_page</code> parameter
 * and the passed collection size.	 
 *
 * @param array $collection Collection to split
 * @param int $page Ordinal number of the extract to return
 * @param int $per_page Extract size
 * @return array Array of the extract, current page, and total pages count
 * @author Szymon Wrozynski
 */
function paginate($collection, $page, $per_page)
{
	if ($page < 1)
		$page = 1;
	
	$size = count($collection);
	$total_pages = ($size > $per_page) ? intval(ceil($size / $per_page)) : 1;
	
	if ($page > $total_pages)
		$page = $total_pages;
	
	$start = $per_page * ($page - 1);
	return array(array_slice($collection, $start, $per_page), $page, $total_pages);
}
?>
PAG
	), $GLOBALS['STRIP_PHPDOC']);
}

# Application Context functions ##############################################

function create_application_context($env='development')
{
	global $ROUTES;
	
	if (isset($ROUTES))
		return;
		
	$_SERVER['SERVER_NAME'] = 'localhost';

	check_dir_exists('modules');
	
	if ($env === 'test')
		require 'modules' . DIRECTORY_SEPARATOR . 'Test' . DIRECTORY_SEPARATOR . 'Application' . DIRECTORY_SEPARATOR
			. 'Singleton.php';
	
	require 'modules' . DIRECTORY_SEPARATOR . 'application.php';
	
	\Application\Configuration::instance()->environment = $env;
	
	require CONFIG . 'routes.php';
	
	if ($ROUTES)
		$ROUTES[0][0] = '/';
	
	$rc = $rc2 = null;
		
	foreach ($ROUTES as $n => $r) 
	{	
		$rc[$r['controller']][$r['action']] = $rc2["{$r['controller']}\\{$r['action']}"] = $n;
		
		$t = strtok($r[0], '/.');

		if (($t !== false) && $t[0] === ':')
			$ROUTES[$n]['pp'][] = substr($t, 1);

		while (($t = strtok('/.')) !== false)
		{
			if ($t[0] === ':')
				$ROUTES[$n]['pp'][] = substr($t, 1);
		}		  
	}
	
	$ROUTES['__RC'] =& $rc;
	$ROUTES['__RC2'] =& $rc2;
}

function _db_create($url, $user, $pass)
{
	$info = \ActiveRecord\Connection::parse_connection_url($url);
	
	$root_url = $pass ? "$info->protocol://$user:$pass@$info->host" : "$info->protocol://$user@$info->host";
	
	if (isset($info->charset))
		$root_url .= "?charset=$info->charset";

	$config = \ActiveRecord\Configuration::instance();
	$old_env = $config->environment;
	$config->environment = '__prag_root';
	$config->connection = $root_url;
	$conn = \ActiveRecord\Connection::instance('__prag_root');
	$conn->query(<<< DB
DROP DATABASE IF EXISTS $info->db;
CREATE DATABASE $info->db CHARACTER SET utf8 COLLATE utf8_general_ci;
GRANT ALL ON $info->db.* to '$info->user'@'localhost';
SET PASSWORD FOR '$info->user'@'localhost' = PASSWORD('$info->pass');
DB
	);
	$config->environment = $old_env;
	echo "Database $info->db created.\n";
}

function db_prepare($env, $user, $pass)
{
	if (!$user)
		error('Unknown root user name');
	
	create_application_context();
	modules('activerecord');
	
	$connections = \ActiveRecord\Configuration::instance()->all_for('connection');

	if ($env !== 'all')
	{
		if (isset($connections[$env]))
			$connections = array($env => $connections[$env]);
		else
			error("Undefined environment: $env");
	}

	foreach ($connections as $name => $url)
	{
		_db_create($url, $user, $pass);
		db_schema($name);
		db_data($name);
	}
}

function _db_query($env, $sql_file, $empty_warning, $success_msg)
{
	check_file_exists($sql_file);
	
	$sql = file_get_contents($sql_file);
	
	if (!$sql)
	{
		echo "WARNING: $empty_warning\n";
		return;
	}
	
	create_application_context();
	modules('activerecord');
	
	$cfg = \ActiveRecord\Configuration::instance();
	$connections = $cfg->all_for('connection');

	if ($env !== 'all')
	{
		if (isset($connections[$env]))
			$connections = array($env => $connections[$env]);
		else
			error("Undefined environment: $env");
	}
	
	foreach ($connections as $name => $url)
	{
		$conn = \ActiveRecord\Connection::instance($name);
		$conn->query($sql);
		echo sprintf($success_msg, $name), "\n";
	}
}

function db_schema($env)
{
	_db_query(
		$env, 
		'sql' . DIRECTORY_SEPARATOR . 'schema.sql',
		'The database schema is empty',
		'Database schema updated for environment: %s'
	);
}

function db_data($env)
{
	_db_query(
		$env, 
		'sql' . DIRECTORY_SEPARATOR . 'data.sql',
		'No initial data',
		'Initial data restored for environment: %s'
	);
}

# Command-line parsing and dispatching #######################################

function get_fields($args)
{
	$declarations = array();
	$decl_size = 0;
	$next_add_to_prev = false;
	foreach ($args as $a)
	{
		if (strrpos($a, ':nullable') === strlen($a) - 9)
		{
			$next_add_to_prev = true;
			$declarations[$decl_size++] = $a;
		}
		elseif ($next_add_to_prev)
		{
			$declarations[$decl_size - 1] .= ' ' . $a;
			$next_add_to_prev = false;
		}
		else
			$declarations[$decl_size++] = $a;
	}
	
	$res = array();
	
	foreach ($declarations as $decl)
		$res[] = new Field($decl);
	
	return $res;
}
	
function fix_colon($args)
{
	$new_args = array();
	
	foreach ($args as $a)
	{
		if ($new_args)
		{
			if (strpos($a, ':') === 0)
			{
				$new_args[-1] .= $a;
				continue;
			}
			elseif (strrpos($a, ':') === strlen($a) - 1)
			{
				$new_args[-1] .= $a;
				continue;
			}
		}
		$new_args[] = $a;
	}
	
	return $new_args;
}

function fix_case($args)
{
	$new_args = array();
	
	foreach ($args as $a)
	{
		if (in_array($a, array('GET', 'POST', 'PUT', 'DELETE'), true))
			$new_args[] = $a;
		else
			$new_args[] = _uncamelize($a);
	}
	
	return $new_args;
}

function parse_overwriting($command)
{
	$overwrite = (strrpos($command, '!') === strlen($command) - 1); 
	return $overwrite ? array($overwrite, "Overwriting a ") : array($overwrite, "Generating new ");
}

function print_routes_footnote()
{
	global $SSL, $EXT, $ASTERISK_USED;
	
	if (!(($SSL || $EXT) && $ASTERISK_USED))
		return;
	
	$msg = "* ";
	
	if ($SSL)
	{
		$msg .= "SSL";
		if ($EXT)
			$msg .= " and the '$EXT' extension have";
		else
			$msg .= " has";
	}
	else
		$msg .= "The '$EXT' extension has";
	
	$msg .= " been set";
	
	echo "\n$msg\n";
}
	
function print_no_phpdoc_footnote()
{
	global $ASTERISK_USED, $STRIP_PHPDOC;
	if ($ASTERISK_USED && $STRIP_PHPDOC)
		echo "\n* PHPDoc has been excluded\n";
}

function main($argv)
{
	printf(<<< 'MAIN'
PRAG %s
The Console Tool for Pragwork %s
%s
%s


MAIN
	, PRAG_VERSION, PRAGWORK_VERSION, AUTHOR, LICENSE);
	
	$argv = fix_case(fix_colon($argv));
	
	if ((count($argv) > 2) && ($argv[1] === 'ssl'))
	{
		global $SSL;
		$SSL = true;
		unset($argv[1]);
		$argv = array_merge(array(), $argv);
	}
		
	if ((count($argv) > 2) && ($argv[1][0] === '.'))
	{
		global $EXT;
		$EXT = $argv[1];
		unset($argv[1]);
		$argv = array_merge(array(), $argv);
	}
	
	global $WRITE_MSG;
	$print_only = false;
	
	if (count($argv) === 1)
	{
		echo 'Type "php prag help" for more info.', "\n";
		$print_only = true;
	}
	elseif ((count($argv) === 2) && (in_array($argv[1], array('help', 'h'), true)))
	{
		help();
		$print_only = true;
	}
	elseif ((count($argv) >= 2) && (in_array($argv[1], array('test', 't'), true)))
	{
		$test_dir = 'test';
		check_dir_exists($test_dir);
		$fixtures = array();
		
		if (count($argv) > 2)
		{
			foreach (array_slice($argv, 2) as $f)
				$fixtures[] = $f;
		}
		else
		{
			check_dir_exists($test_dir . DIRECTORY_SEPARATOR .'fixtures');
			foreach (scandir($test_dir . DIRECTORY_SEPARATOR .'fixtures') as $f)
			{
				if (strrpos($f, '_test_fixture.php') === strlen($f) - 17)
					$fixtures[] = substr($f, 0, -17);
			}
		}
		
		if (!$fixtures)
			error('No test fixtures');
		
		create_application_context('test');
		
		$test_dir .= DIRECTORY_SEPARATOR . 'fixtures' . DIRECTORY_SEPARATOR;
		
		foreach ($fixtures as $i => $f)
		{
			$file = $test_dir . $f . '_test_fixture.php';
			check_file_exists($file);			 
			db_data('test');
			echo "\nRunning tests ($f):\n\n";
			require $file;
			
			if (isset($fixtures[$i + 1]))
				echo "\n";
		}
		
		$print_only = true;
	}
	elseif ((count($argv) >= 2) && (in_array($argv[1], array('db'), true)))
	{
		if (!isset($argv[2]))
			error("No database action");
		
		$print_only = true;
		$env = isset($argv[3]) ? $argv[3] : null;
		switch ($argv[2]) 
		{
			case 'prepare':
				$user = isset($argv[4]) ? $argv[4] : null;
				$pass = isset($argv[5]) ? $argv[5] : null;
				db_prepare($env, $user, $pass);
				break;
			case 'schema':
				db_schema($env);
				break;
			case 'data':
				db_data($env);
				break;
			default:
				error("Unknown database action: {$argv[2]}");
				break;
		}	
	}
	elseif (in_array(count($argv), array(2, 3),true) && ($argv[1] === 'update'))
	{
		echo "Updating modules to Pragwork ", PRAGWORK_VERSION, "...\n\n";
		if (count($argv) === 3)
		{
			if ($argv[2] === 'nodoc')
				$GLOBALS['STRIP_PHPDOC'] = true;
			else
				error("Unknown modifier: {$argv[2]}");
		}
		check_dir_exists('modules');
		$work = getcwd();
		chdir('..');
		make_modules($work);
	}
	elseif ((count($argv) >= 2) && in_array($argv[1], array('localize','l','localize!','l!'), true))
	{
		list($overwrite, $msg) = parse_overwriting($argv[1]);
		check_dir_exists('locales');
		
		if (count($argv) === 2)
		{
			$locales = array_map(function($l) { 
				$arr = explode('.', $l);
				return $arr[0]; 
			}, array_filter(scandir('locales'), function($l) { 
				return $l[0] !== '.'; 
			})); 
		}
		else
			$locales = array_slice($argv, 2);
		
		$msg = $overwrite ? "Overwriting " : "Generating ";
		$msg .= "localization files";
		
		if (count($locales) > 0)
			$msg .= " (" . join(", ", $locales) . ")";
		
		echo $msg, "...\n\n";
		
		foreach ($locales as $l)
			find_locale_keys_and_create_locale($l, $overwrite);
	}
	elseif (count($argv) === 2)
		error("Unknown command: {$argv[1]}");
	elseif ($argv[1] === 'work')
	{
		echo "Generating new project structure ({$argv[2]})...\n\n";
		new_work($argv[2]);
	}
	elseif (in_array($argv[1], array('controller', 'c'), true))
	{
		$path = 'app' . DIRECTORY_SEPARATOR . 'Controllers' . DIRECTORY_SEPARATOR
			. str_replace('\\', DIRECTORY_SEPARATOR, _camelize(ensure_ident($argv[2]))) . 'Controller.php';
		
		$actions_count = 0;
		
		foreach(array_slice($argv, 3) as $m)
		{
			if (!in_array($m, array('GET', 'POST', 'PUT', 'DELETE'), true))
			{
				ensure_ident($m, true);
				$actions_count += 1;
			}
		}
		
		if (file_exists($path))
		{
			if ($actions_count > 1)
			{
				echo "Adding new actions to " . _camelize($argv[2]) . " controller...\n\n";
				$comment = 'New actions of controller ' . _camelize($argv[2]);
			}
			else
			{
				echo "Adding a new action to " . _camelize($argv[2]) . " controller...\n\n";
				$comment = 'New action of controller ' . _camelize($argv[2]);
			}
			new_actions_with_methods($argv[2], array_slice($argv, 3), $comment);
		}
		else
		{
			echo "Generating new controller (" ._camelize($argv[2]).")...\n\n";
			$comment = 'Controller ' . _camelize($argv[2]);
			new_controller($argv[2], array_slice($argv, 3), $comment);
		}
	}
	elseif (in_array($argv[1], array('scaffold', 's', 'scaffold!', 's!'), true))
	{
		list($overwrite, $msg) = parse_overwriting($argv[1]);
		list($ns, $name) = _get_ns_and_name(ensure_ident($argv[2]));
		echo $msg . "scaffolding (for " . _camelize($name) . ")...\n\n";
		new_scaffolding($argv[2], get_fields(array_slice($argv, 3)),$overwrite);
	}
	elseif (in_array($argv[1], array('model', 'm', 'model!', 'm!'), true))
	{
		list($overwrite, $msg) = parse_overwriting($argv[1]);
		list($ns, $name) = _get_ns_and_name(ensure_ident($argv[2]));
		echo $msg . "model (" . _camelize($name) . ")...\n\n";
		new_model($argv[2], get_fields(array_slice($argv, 3)), $overwrite);
	}
	elseif (in_array($argv[1], array('form', 'f', 'form!', 'f!'), true))
	{
		list($overwrite, $msg) = parse_overwriting($argv[1]);
		list($ns, $name) = _get_ns_and_name(ensure_ident($argv[2]));
		echo $msg . "form (" . _camelize($name) . ")...\n\n";
		new_form($argv[2], get_fields(array_slice($argv, 3)), $overwrite);
	}
	else
		error("Unknown commands");
	
	if ($WRITE_MSG)
		echo "\n";
	if (!($print_only || $WRITE_MSG))
		error("Nothing to write!");
	
	print_routes_footnote();
	print_no_phpdoc_footnote();
}

try
{
	set_time_limit(0);
	session_start();
	main($argv);
}
catch (\Exception $e)
{
	$msg = $e->getMessage();
	error(get_class($e) . "\n" . (isset($msg[160]) ? (substr($msg, 0, 157) . '...') : $msg));
}
?>